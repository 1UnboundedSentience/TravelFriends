{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","ringcentral-web-phone.js","webpack:/webpack/bootstrap 8c9fbab19495d2b63fcb","webpack:///src/index.js","webpack:///~/sip.js/src/SIP.js","webpack:///~/sip.js/package.json","webpack:///~/sip.js/src/Utils.js","webpack:///~/sip.js/src/Logger.js","webpack:///~/sip.js/src/LoggerFactory.js","webpack:///~/sip.js/src/EventEmitter.js","webpack:///~/sip.js/src/Constants.js","webpack:///~/sip.js/src/Exceptions.js","webpack:///~/sip.js/src/Timers.js","webpack:///~/sip.js/src/Transport.js","webpack:///~/sip.js/src/Parser.js","webpack:///~/sip.js/src/SIPMessage.js","webpack:///~/sip.js/src/URI.js","webpack:///~/sip.js/src/NameAddrHeader.js","webpack:///~/sip.js/src/Transactions.js","webpack:///~/sip.js/src/Dialog/RequestSender.js","webpack:///~/sip.js/src/Dialogs.js","webpack:///~/sip.js/src/RequestSender.js","webpack:///~/sip.js/src/RegisterContext.js","webpack:///~/sip.js/src/MediaHandler.js","webpack:///~/sip.js/src/ClientContext.js","webpack:///~/sip.js/src/ServerContext.js","webpack:///~/sip.js/src/Session/DTMF.js","webpack:///~/sip.js/src/Session.js","webpack:///~/sip.js/src/Subscription.js","webpack:///~/sip.js/src/WebRTC/MediaHandler.js","webpack:///~/sip.js/src/WebRTC/MediaStreamManager.js","webpack:///~/sip.js/src/WebRTC.js","webpack:///~/sip.js/src/UA.js","webpack:///~/sip.js/src/Hacks.js","webpack:///~/sip.js/src/SanityCheck.js","webpack:///~/sip.js/src/DigestAuthentication.js","webpack:///~/sip.js/src/Grammar/dist/Grammar.js","webpack:///src/emitter.js","webpack:///src/userAgent.js","webpack:///src/phoneLine.js","webpack:///src/utils.js","webpack:///src/eventNames.js","webpack:///src/dom.js","webpack:///src/audioHelper.js","webpack:///src/audio.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","WebPhone","options","service","__registerDeferred","undefined","__unregisterDeferred","__callDeferred","__sipRegistered","__sipOutboundEnabled","uuid","localStorage","activeLine","onMute","onHold","onRecord","contact","ua","UserAgent","on","bind","username","isRegistered","isRegistering","isUnregistering","events","EVENT_NAMES","causes","SIP","C","reasons","REASON_PHRASE","sipIncomingCall","line","eventEmitter","emit","incomingCall","outgoingCall","isOnHold","setHold","resolve","callEnded","callFailed","response","cause","test","status_code","session","onTransportError","setTimeout","reregister","sipRegistered","e","isUnregistered","sipRegistrationFailed","sipConnectionFailed","reject","sipUnRegistered","window","addEventListener","hangup","unregister","_audioHelper","audioHelper","createAudioHelper","_appKey","appKey","_appName","appName","_appVersion","appVersion","_x_userAgent","version","_client_id","appkey","EventEmitter","PhoneLine","AudioHelper","defer","extend","mediaStreamManagerProto","Object","create","WebRTC","MediaStreamManager","prototype","release","value","stream","streamId","acquisitions","stop","getTracks","forEach","track","console","log","register","info","checkFlags","sipFlags","outboundCallsEnabled","Error","sipInfo","headers","endpointId","push","extraHeaders","warn","promise","wsServers","outboundProxy","transport","toLowerCase","domain","sipDomain","userName","Array","isArray","uri","password","authorizationUser","authorizationId","traceSip","stunServers","turnServers","level","autostart","iceGatheringTimeout","setSIPConfig","start","Promise","reconnect","forceDisconnect","toNumber","fromNumber","country","Boolean","answer","incomingLines","getIncomingLinesArray","activeLines","getActiveLinesArray","self","length","promises","all","then","onCall","filter","getLine","sendDTMF","hold","unhold","isIncoming","mute","setMute","unmute","transfer","target","global","pkg","defineProperties","get","name","title","Logger","LoggerFactory","Exceptions","Timers","DialogRequestSender","MediaHandler","SessionDTMF","WebRTCMediaHandler","WebRTCMediaStreamManager","Utils","Hacks","DigestAuthentication","Grammar","_args","_from","_id","_inCache","_installable","_location","_npmUser","email","_npmVersion","_phantomChildren","_requested","raw","rawSpec","scope","spec","type","_requiredBy","_resolved","_shasum","_shrinkwrap","_spec","_where","author","bugs","url","contributors","dependencies","description","devDependencies","browserify","grunt","grunt-browserify","grunt-cli","grunt-contrib-copy","grunt-contrib-jasmine","grunt-contrib-jshint","grunt-contrib-uglify","grunt-peg","grunt-trimtrailingspaces","node-minify","pegjs","sdp-transform","directories","dist","shasum","tarball","engines","node","gitHead","homepage","keywords","license","main","maintainers","optionalDependencies","readme","repository","scripts","augment","object","constructor","args","override","idx","proto","apply","optionsOverride","winner","loser","isDeprecated","logger","defaultValue","desugarSessionOptions","HTMLMediaElement","media","constraints","audio","video","tagName","render","remote","str_utf8_length","string","encodeURIComponent","replace","getPrefixedProperty","capitalizedName","charAt","toUpperCase","slice","prefixedNames","i","property","generateFakeSDP","body","indexOf","end","isFunction","fn","toString","isDecimal","num","isNaN","parseFloat","parseInt","createRandomToken","size","base","r","token","Math","random","newTag","UA","TAG_LENGTH","newUUID","UUID","v","hostType","host","parse","host_type","normalizeTarget","target_array","target_user","target_domain","URI","split","join","escapeUser","user","decodeURIComponent","headerize","part","exceptions","Call-Id","Cseq","Rack","Rseq","Www-Authenticate","hname","parts","substring","sipErrorCause","SIP_ERROR_CAUSES","SIP_FAILURE_CODE","getRandomTestNetIP","getOctet","from","to","floor","getAllowedMethods","event","allowed","ALLOWED_METHODS","EVENT_METHODS","checkListener","calculateMD5","RotateLeft","lValue","iShiftBits","AddUnsigned","lX","lY","lX4","lY4","lX8","lY8","lResult","F","x","y","z","G","H","I","FF","a","b","d","s","ac","GG","HH","II","ConvertToWordArray","lWordCount","lMessageLength","lNumberOfWords_temp1","lNumberOfWords_temp2","lNumberOfWords","lWordArray","lBytePosition","lByteCount","charCodeAt","WordToHex","lByte","lCount","WordToHexValue","WordToHexValue_temp","substr","Utf8Encode","utftext","n","String","fromCharCode","k","AA","BB","CC","DD","S11","S12","S13","S14","S21","S22","S23","S24","S31","S32","S33","S34","S41","S42","S43","S44","temp","category","label","debug","content","error","levels","builtinEnabled","connector","loggers","getLogger","set","JSON","stringify","hasOwnProperty","print","prefix","Date","Event","MAX_LISTENERS","initEvents","initMoreEvents","maxListeners","checkEvent","listener","bindTarget","TypeError","listenerObj","once","listenOnce","arguments","off","splice","setMaxListeners","listeners","err","stack","sender","data","USER_AGENT","SIPS","CONNECTION_ERROR","REQUEST_TIMEOUT","INTERNAL_ERROR","BUSY","REJECTED","REDIRECTED","UNAVAILABLE","NOT_FOUND","ADDRESS_INCOMPLETE","INCOMPATIBLE_SDP","AUTHENTICATION_ERROR","DIALOG_ERROR","WEBRTC_NOT_SUPPORTED","WEBRTC_ERROR","CANCELED","NO_ANSWER","EXPIRES","NO_ACK","NO_PRACK","USER_DENIED_MEDIA_ACCESS","BAD_MEDIA_DESCRIPTION","RTP_TIMEOUT","supported","UNSUPPORTED","SUPPORTED","REQUIRED","ACK","BYE","CANCEL","INFO","INVITE","MESSAGE","NOTIFY","OPTIONS","REGISTER","UPDATE","SUBSCRIBE","REFER","PRACK",100,180,181,182,183,199,200,202,204,300,301,302,305,380,400,401,402,403,404,405,406,407,408,410,412,413,414,415,416,417,420,421,422,423,428,429,430,433,436,437,438,439,440,469,470,478,480,481,482,483,484,485,486,487,488,489,491,493,494,500,501,502,503,504,505,513,580,600,603,604,606,"ConfigurationError","exception","parameter","code","message","InvalidStateError","status","NotSupportedError","NotReadyError","T1","T2","T4","timers","TIMER_B","TIMER_D","TIMER_F","TIMER_H","TIMER_I","TIMER_J","TIMER_K","TIMER_L","TIMER_M","TIMER_N","PROVISIONAL_RESPONSE_INTERVAL","Transport","STATUS_READY","STATUS_DISCONNECTED","STATUS_ERROR","server","ws","reconnection_attempts","closed","connected","reconnectTimer","lastTransportError","connect","send","msg","readyState","WebSocket","OPEN","configuration","disconnect","clearTimeout","ws_uri","close","reason","CONNECTING","onTransportConnecting","binaryType","onopen","onOpen","onclose","onClose","onmessage","onMessage","onerror","onError","onTransportConnected","connected_before","wasClean","onTransportClosed","reConnect","transaction","Uint8Array","evt","Parser","parseMessage","STATUS_USER_CLOSED","IncomingRequest","sanityCheck","receiveRequest","IncomingResponse","method","transactions","ict","via_branch","receiveResponse","nict","wsServerMaxReconnection","wsServerReconnectionTimeout","getHeader","headerStart","partialEnd","match","parseHeader","headerEnd","header","parsed","hcolonIndex","headerName","trim","headerValue","addHeader","getHeaders","via","branch","setHeader","from_tag","getParam","to_tag","position","offset","call_id","cseq","refer_to","firstLine","contentLength","bodyStart","reason_phrase","ruri","hasHeader","OutgoingRequest","IncomingMessage","params","statusCode","reasonPhrase","route_set","usePreloadedRoute","sip_uri","MAX_FORWARDS","to_displayName","to_uri","NameAddrHeader","from_displayName","displayName","from_uri","sipjsId","regexp","RegExp","result","pub_gruu","temp_gruu","rel100","userAgentString","server_transaction","reply","onSuccess","onFailure","rr","vias","hasParam","reply_sl","scheme","port","parameters","param","setParam","key","deleteParam","clearParams","deleteHeader","clearHeaders","clone","name_addr_header","STATUS_TRYING","STATUS_PROCEEDING","STATUS_CALLING","STATUS_ACCEPTED","STATUS_COMPLETED","STATUS_TERMINATED","STATUS_CONFIRMED","NON_INVITE_CLIENT","NON_INVITE_SERVER","INVITE_CLIENT","INVITE_SERVER","NonInviteClientTransaction","request_sender","request","hackViaTcp","viaHost","newTransaction","stateChanged","state","tr","timer_F","K","destroyTransaction","onRequestTimeout","timer_K","InviteClientTransaction","cancel","cancel_request","B","timer_B","D","M","timer_M","timer_D","sendACK","ack","AckClientTransaction","NonInviteServerTransaction","last_response","timer_J","transportError","J","InviteServerTransaction","resendProvisionalTimer","timer_H","timer_I","timer_L","clearInterval","L","resend_provisional","setInterval","checkTransaction","ist","nist","Transactions","RequestSender","dialog","applicant","reattempt","reattemptTimer","owner","clientTransaction","uac_pending_reply","uas_pending_reply","onReadyToReinvite","onDialogError","local_seqnum","Session","getReattemptTimeout","Dialog","STATUS_EARLY","local_tag","remote_tag","remote_seqnum","local_uri","remote_uri","remote_target","invite_seqnum","pracked","reverse","hasOffer","mediaHandler","mediaHandlerFactory","dialogs","update","terminate","peerConnection","createRequest","checkInDialogRequest","retryAfter","sendRequest","credentials","challenged","staled","challenge","authorization_header_name","stale","authenticate","RegisterContext","regId","registrar","registrarServer","expires","registerExpires","instanceId","ClientContext","registrationTimer","registrationExpiredTimer","registered","contacts","unregistered","registrationFailure","registered_before","isReady","getDescription","mediaHint","setDescription","originalTarget","contentType","localIdentity","remoteIdentity","cancel_reason","applicants","ServerContext","progress","accept","DTMF","MIN_DURATION","MAX_DURATION","DEFAULT_DURATION","MIN_INTER_TONE_GAP","DEFAULT_INTER_TONE_GAP","tone","duration","interToneGap","direction","abs","STATUS_WAITING_FOR_ACK","originator","init_incoming","InviteServerContext","InviteClientContext","STATUS_NULL","STATUS_INVITE_SENT","STATUS_1XX_RECEIVED","STATUS_INVITE_RECEIVED","STATUS_WAITING_FOR_ANSWER","STATUS_ANSWERED","STATUS_WAITING_FOR_PRACK","STATUS_CANCELED","STATUS_ANSWERED_WAITING_FOR_PRACK","STATUS_EARLY_MEDIA","earlyDialogs","defaultFactory","hasAnswer","ackTimer","expiresTimer","invite2xxTimer","userNoAnswerTimer","rel1xxTimer","prackTimer","startTime","endTime","tones","local_hold","remote_hold","pending_actions","actions","isPending","shift","pop","early_sdp","dtmf","dtmfs","concat","timeout","bye","terminated","refer","followRefer","callback","targetString","open","Chrome","getsConfusedAboutGUM","referSession","invite","receiveNonInviteResponse","sessions","createDialog","early","early_dialog","failed","dia","isReadyToReinvite","ret","onmute","onunmute","onhold","sendReinvite","mangle","onunhold","local","receiveReinvite","setInvite2xxTimer","setACKTimer","eventHandlers","succeeded","reinviteSucceeded","reinviteFailed","receiveReinviteResponse","reg_tone","reg_duration","hasReferListener","notifyBody","acceptAndTerminate","invite2xxRetransmission","min","action","rejected","canceled","accepted","connecting","set100rel","h","fireNewSession","noAnswerTimeout","contentDisp","renderbody","rendertype","Firefox","cannotHandleExtraWhitespace","AllBrowsers","maskDtls","RTCConstraints","optional","DtlsSrtpKeyAgreement","getRemoteStreams","getLocalStreams","do100rel","isCanceled","rel1xxRetransmission","normalReply","sdpCreationSucceeded","replySucceeded","replyFailed","sdpCreationFailed","confirmSession","requestParams","iceServers","isMediaSupported","isSupported","inviteWithoutSdp","anonymous","outbound","received_100","receiveInviteResponse","configuration_check","offer","cancelReason","sdp","localMedia","hasMissingCLineInSDP","Subscription","N","sub_duration","errorCodes","subscribe","sub","timer_fire","createConfirmedDialog","subscriptions","INVALID_EXPIRES_HEADER","EXPIRES_HEADER_MISSING","unsubscribe","terminateDialog","setExpiresTimeout","sub_state","max","matchEvent","REASON_200","selfEmit","mh","mediaStreamManager","ready","audioMuted","videoMuted","servers","config","urls","credential","RTCPeerConnection","onaddstream","onremovestream","onicecandidate","candidate","onIceCompleted","callOnIceCompleted","onicegatheringstatechange","iceGatheringState","oniceconnectionstatechange","iceConnectionState","onstatechange","writable","signalingState","streamAdditionSucceeded","ondatachannel","dataChannel","channel","createDataChannel","createOfferOrAnswer","acquireSucceeded","addStream","acquire","rawDescription","RTCSessionDescription","setRemoteDescription","isMuted","getAudioTracks","getVideoTracks","toggleMuteAudio","toggleMuteVideo","audioUnMuted","videoUnMuted","pc","localStreams","remoteStreams","renderHint","streamGetters","keys","loc","streamGetter","streams","where","offerState","readySuccess","localDescription","needsExplicitlyInactiveSDP","unmaskDtls","hasIncompatibleCLineWithSomeSIPEndpoints","sdpWrapper","methodName","onSetLocalDescriptionSuccess","methodFailed","sessionDescription","setLocalDescription","toggleMuteHelper","trackGetter","enabled","defaultMediaHint","map","elements","attachAndPlay","element","attachMediaStream","ensureMediaPlaying","src","URL","revokeObjectURL","createObjectURL","srcObject","mozSrcObject","mediaElement","interval","ensurePlayingIntervalId","paused","play","volume","saveSuccess","isHintStream","emitThenCall","eventName","callbackArgs","newArgs","getUserMedia","_isSupported","MediaStream","navigator","STATUS_INIT","STATUS_NOT_READY","CONFIGURATION_ERROR","NETWORK_ERROR","ACCEPTED_BODY_TYPES","len","cache","transportRecoverAttempts","transportRecoveryTimer","transactionsCount","count","nictTransactionsCount","nistTransactionsCount","ictTransactionsCount","istTransactionsCount","loadConfig","registerContext","isConnected","context","mes","req","transactionsListener","subscription","getNextWsServer","hostportParams","saveCredentials","realm","getCredentials","client_transactions","closeSessionsOnTransportError","recoverTransport","attempts","ruriMatches","methodLower","content_type","findDialog","findSession","ws_server","candidates","weight","nextRetry","pow","connectionRecoveryMinInterval","connectionRecoveryMaxInterval","aliasUnderscored","underscored","hasParameter","checked_value","settings","hackIpInContact","hackWssInTransport","mandatory","emptyArraysAllowed","configuration_skeleton","skeleton","configurable","Number","stun_server","turn_server","Function","isFirefox","mozRTCPeerConnection","insertAt","mlines","search","index","rfc3261_8_2_2_1","rfc3261_16_3_4","rfc3261_18_3_request","rfc3261_8_2_2_2","fromTag","rfc3261_8_1_3_3","rfc3261_18_1_2","rfc3261_18_3_response","minimumHeaders","mandatoryHeaders","requests","responses","u","t","pass","cnonce","nc","ncHex","algorithm","nonce","opaque","qop","updateNcHex","calculateResponse","ha1","ha2","auth_params","hex","peg$subclass","child","parent","ctor","SyntaxError","expected","found","column","input","text","peg$reportedPos","peg$currPos","peg$computePosDetails","pos","advance","details","startPos","endPos","ch","seenCR","peg$cachedPos","peg$cachedPosDetails","peg$fail","peg$maxFailPos","peg$maxFailExpected","peg$buildException","cleanupExpected","sort","buildMessage","stringEscape","expectedDesc","foundDesc","expectedDescs","posDetails","peg$decode","bc","peg$parseRule","protect","peg$bytecode","ip","ips","ends","peg$consts","peg$FAILED","peg$silentFails","peg$result","peg$startRuleIndices","Contact","Name_Addr_Header","Record_Route","Request_Response","SIP_URI","Subscription_State","Via","absoluteURI","Call_ID","Content_Disposition","Content_Length","Content_Type","CSeq","From","Max_Forwards","Proxy_Authenticate","quoted_string","Refer_To","stun_URI","To","turn_URI","WWW_Authenticate","peg$startRuleIndex","escaped","contents","uri_params","uri_headers","startRule","uri_scheme","ttl","maddr","pname","pvalue","hvalue","sip_version","multi_header","q","delta_seconds","cseq_value","event_type","tag","forwards","min_expires","qop_value","rack_value","rseq_value","retry_after","via_ttl_value","via_maddr","via_received","received","response_port","rport","via_protocol","protocol","via_transport","via_sent_by_port","handlers","executeListener","list","__emit","utils","DomAudio","sipConfig","lines","userAgent","dom","checkConfig","enums","enumerable","defineProperty","useSecureConnection","document","location","__createLine","sipRTCSession","__clearInactiveLines","getActiveLines","arr","el","isClosed","__disconnectCount","__registerExtraOptions","sipConnected","retryCount","sipDisconnected","newLine","replaces","callId","foundLine","getId","types","incoming","callReplaced","number","inviteOptions","localAudio","remoteAudio","outgoing","cb","isConnecting","setStreamMute","val","tracks","delay","onEnd","timeCallStarted","terminateCallOnDisconnected","sessionId","muted","bothMuted","responseTimeout","controlSender","messages","park","reqid","command","startRecord","stopRecord","flip","monitor","barge","whisper","takeover","onInfo","obj","__receiveRequest","localSDP","callConnecting","__hasEarlyMedia","__receiveInviteReponse","__waitingForIce","sessionSelf","hasEarlyMedia","ICECompleted","ICEFailed","callProgress","callStarted","callRejected","callTerminated","onStateChange","__doubleCompleted","ICEConnected","ICEDisconnected","__ignoreReinviteDuplicates","__sendReinvite","res","__reinviteSucceeded","__reinviteFailed","callReinviteSucceeded","callReinviteFailed","__receiveReinviteResponse","getSession","record","peer","dtmfSender","createDTMFSender","canInsertDTMF","insertDTMF","sendInfoDTMF","blindTransfer","onNotify","forward","onAnswered","onFail","callMute","callUnmute","setMuteBoth","__legacyHold","__hold","onSucceeded","onFailed","callHold","callUnhold","isOnMute","isOnRecord","getContact","getCallDuration","getTime","ms","deferred","dst","copy","sipConnecting","ICEChecking","ICEClosed","LOCAL_AUDIO","createElement","REMOTE_AUDIO","LOCAL_AUDIO_ID","REMOTE_AUDIO_ID","setAttribute","appendChild","localAudioId","remoteAudioId","rcSIPUA","_rcSIPUA","_incoming","_outgoing","_audio","playIncoming","playOutgoing","_playSound","reset","loop","emitter","Audio","currentTime","resumed","pause","resume","ceil","load","prop"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,SAAAA,OAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,SAAAD,KAEAD,EAAA,YAAAA,EAAA,gBAAiDA,EAAA,YAAA,SAAAC,MAChDK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,EAAAA,EAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,EAASM,GAEhCL,EAAOD,QAAUM,EAAoB,IAK/B,SAASL,EAAQD,EAASM,GEhBhC,QAAAS,GAAAC,GAEAA,EAAAA,KAEA,IAAAC,GAAAb,IAEAA,MAAAc,mBAAAC,OACAf,KAAAgB,qBAAAD,OACAf,KAAAiB,eAAAF,OACAf,KAAAkB,iBAAA,EACAlB,KAAAmB,sBAAA,EAEAP,EAAAQ,KACApB,KAAAoB,KAAAR,EAAAQ,MAEAC,aAAA,oBAAAA,aAAA,qBAAAD,IACApB,KAAAoB,KAAAC,aAAA,qBAGArB,KAAAsB,WAAA,KAEAtB,KAAAuB,QAAA,EACAvB,KAAAwB,QAAA,EACAxB,KAAAyB,UAAA,EACAzB,KAAA0B,QAAAX,MAEA,IAAAY,GAAA,GAAAC,EAEA5B,MAAA2B,GAAAA,EACA3B,KAAA6B,GAAAF,EAAAE,GAAAC,KAAAH,GAEA3B,KAAA+B,SAAA,KAEA/B,KAAAgC,cAAA,EACAhC,KAAAiC,eAAA,EACAjC,KAAAkC,iBAAA,EAEAlC,KAAAmC,OAAAC,EAEApC,KAAAqC,OAAAC,EAAAC,EAAAF,OACArC,KAAAwC,QAAAF,EAAAC,EAAAE,cAGA5B,EAAAgB,GAAAO,EAAAM,gBAAA,SAAAC,GACA9B,EAAAc,GAAAiB,aAAAC,KAAAT,EAAAU,aAAAH,KAIA9B,EAAAgB,GAAAO,EAAAW,aAAA,SAAAJ,GACA9B,EAAAS,aAAAT,EAAAS,WAAA0B,YACAnC,EAAAS,WAAA2B,UAEApC,EAAAI,gBAAAJ,EAAAI,eAAAiC,QAAAP,GACA9B,EAAAI,eAAA,OAIAJ,EAAAgB,IAAAO,EAAAe,UAAAf,EAAAgB,YAAA,SAAA7C,GAEAA,GAAAM,EAAAS,YAAAf,IAAAM,EAAAS,aACAT,EAAAS,WAAA,QAKAT,EAAAgB,GAAAO,EAAAgB,WAAA,SAAA7C,EAAA8C,EAAAC,GACA,GAAAD,EACA,QAAA,GAEA,IAAA,QAAAE,KAAAF,EAAAG,aAEAjD,EAAAkD,QAAAC,iBAAA,aAEAC,WAAA9C,EAAA+C,WAAA9B,KAAAjB,GAAA,GAAA,QAQAA,EAAAgB,GAAAO,EAAAyB,cAAA,SAAAC,GACAjD,EAAAK,iBAAA,EACAL,EAAAC,oBAAAD,EAAAC,mBAAAoC,QAAAY,GACAjD,EAAAmB,cAAA,EACAnB,EAAAoB,eAAA,EACApB,EAAAqB,iBAAA,EACArB,EAAAkD,gBAAA,IAGAlD,EAAAgB,IAAAO,EAAA4B,sBAAA5B,EAAA6B,qBAAA,SAAAH,GACAjD,EAAAK,iBAAA,EACAL,EAAAC,oBAAAD,EAAAC,mBAAAoD,OAAAJ,GACAjD,EAAAmB,cAAA,EACAnB,EAAAoB,eAAA,EACApB,EAAAqB,iBAAA,EACArB,EAAAkD,gBAAA,IAGAlD,EAAAgB,GAAAO,EAAA+B,gBAAA,SAAAL,GACAjD,EAAAK,iBAAA,EACAL,EAAAG,sBAAAH,EAAAG,qBAAAkC,QAAAY,GACAjD,EAAAmB,cAAA,EACAnB,EAAAoB,eAAA,EACApB,EAAAkD,gBAAA,EACAlD,EAAAqB,iBAAA,IAGAkC,OAAAC,iBAAA,SAAA,WACAxD,EAAAyD,SACAzD,EAAA0D,eAGAvE,KAAAwE,aAAA,KACA5D,EAAA6D,aAAA5D,EAAA6D,kBAAA9D,EAAA6D,aAEAzE,KAAA2E,QAAA/D,EAAAgE,OACA5E,KAAA6E,SAAAjE,EAAAkE,QACA9E,KAAA+E,YAAAnE,EAAAoE,WAEAhF,KAAAiF,cAAArE,EAAAkE,QAAAlE,EAAAkE,SAAAlE,EAAAoE,WAAA,IAAApE,EAAAoE,WAAA,IAAA,IAAA,IACA,cAAArE,EAAAuE,QAEAlF,KAAAmF,WAAAvE,EAAAwE,OAxKA,GAAA9C,GAAApC,EAAA,GACAmF,EAAAnF,EAAA,IACA0B,EAAA1B,EAAA,IACAoF,EAAApF,EAAA,IACAqF,EAAArF,EAAA,IACAsF,EAAAtF,EAAA,IAAAsF,MACApE,EAAAlB,EAAA,IAAAkB,KACAqE,EAAAvF,EAAA,IAAAuF,OACArD,EAAAlC,EAAA,IAMAwF,EAAAC,OAAAC,OAAAtD,EAAAuD,OAAAC,mBAAAC,WACAC,SACAC,MAAA,SAAAC,GACA,GAAAC,GAAA7D,EAAAuD,OAAAC,mBAAAK,SAAAD,EACAlG,MAAAoG,aAAAD,MAAA,IAEA,kBAAAD,GAAA,KACAA,EAAAG,OAGAH,EAAAI,YAAAC,QAAA,SAAAC,GACAA,EAAAH,gBAIArG,MAAAoG,aAAAD,MAKA7D,GAAAuD,OAAAC,mBAAAC,UAAAL,EA4IA/E,EAAAuE,QAAA,QAEAvE,EAAA2E,UAAAA,EACA3E,EAAA0E,aAAAA,EACA1E,EAAAiB,UAAAA,EACAjB,EAAA4E,YAAAA,EAQA5E,EAAAoF,UAAArB,kBAAA,SAAA9D,GAKA,MAJAZ,MAAAwE,eACAiC,QAAAC,IAAA,kBACA1G,KAAAwE,aAAA,GAAAe,GAAAvF,KAAAY,IAEAZ,KAAAwE,cAKA7D,EAAAoF,UAAAY,SAAA,SAAAC,EAAAC,GAEA,IACA,GAAAhG,GAAAb,IAIA,IAAA6G,IACA,gBAAAD,GAAA,UAEA7F,SAAA6F,EAAAE,SAAAC,sBAAAH,EAAAE,SAAAC,wBAAA,GAUA,KAAA,IAAAC,OAAA,gCANAhH,MAAAmB,qBAAAyF,EAAAE,SAAAC,qBAGAH,EAAAA,EAAAK,QAAA,EAMA,IAAAC,MACAC,EAAAnH,KAAAoB,IAWA,IAVA+F,IACAD,EAAAE,KAAA,qBAAAD,GACAD,EAAAE,KAAA,gBAAApH,KAAAiF,cACAiC,EAAAE,KAAA,aAAApH,KAAAmF,aAGAM,EAAAmB,GACAS,aAAAH,IAGArG,EAAAmB,aAEA,MADAyE,SAAAa,KAAA,sDACAzG,EAAAC,mBAAAyG,OAGA,IAAA1G,EAAAoB,cAEA,MADAwE,SAAAa,KAAA,8BACAzG,EAAAC,mBAAAyG,OAGA1G,GAAAC,mBAAA0E,IACA3E,EAAAoB,eAAA,EACApB,EAAAmB,cAAA,EAGA4E,EAAAY,UAAAZ,EAAAa,eAAAb,EAAAc,UACAd,EAAAc,UAAAC,cAAA,MAAAf,EAAAa,cACAb,EAAAY,UACAZ,EAAAgB,OAAAhB,EAAAgB,QAAAhB,EAAAiB,UACAjB,EAAA7E,SAAA6E,EAAA7E,UAAA6E,EAAAkB,SAEAlB,EAAAS,aAAAU,MAAAC,QAAApB,EAAAS,cAAAT,EAAAS,eAMA,IAAAzG,IACA4G,UAAAZ,EAAAY,UACAS,IAAA,OAAArB,EAAA7E,SAAA,IAAA6E,EAAAgB,OACAM,SAAAtB,EAAAsB,SACAC,kBAAAvB,EAAAwB,gBACAC,UAAA,EACAC,YAAA1B,EAAA0B,cAAA,6BACAC,eACA7B,KACA8B,MAAA,GAEAZ,OAAAhB,EAAAgB,OACAa,WAAA,EACA9B,UAAA,EACA+B,oBAAA9B,EAAA8B,qBAAA,IAEAxB,QAAAA,EAGArG,GAAAkB,SAAA6E,EAAAkB,SACAjH,EAAAc,GAAAgH,aAAA/H,GACAC,EAAAc,GAAAiH,OACAvB,aAAAT,EAAAS,eAGA,MAAAvD,GAGA,MAFAjD,GAAAoB,eAAA,EACApB,EAAAmB,cAAA,EACA6G,QAAA3E,OAAAJ,GAGA,MAAAjD,GAAAC,mBAAAyG,SAKA5G,EAAAoF,UAAAnC,WAAA,SAAAkF,GACA,GAAAjI,GAAAb,IACA,OAAAa,GAAAoB,cAAApB,EAAAC,oBACAD,EAAAC,mBAAA0E,IACA3E,EAAAoB,eAAA,EACApB,EAAAc,GAAAiC,gBAA4BkF,GAC5BjI,EAAAC,mBAAAyG,UAKA5G,EAAAoF,UAAAxB,WAAA,WACA,GAAA1D,GAAAb,IASA,OARAa,GAAAoB,gBACApB,EAAAc,GAAAoH,kBACAlI,EAAAoB,eAAA,EACApB,EAAAqB,iBAAA,EACArB,EAAAmB,cAAA,EACAnB,EAAAkD,gBAAA,GAGAlD,EAAAkD,gBAAAlD,EAAAqB,gBAAArB,EAAAG,sBAEAH,EAAAqB,iBAAA,EACArB,EAAAkD,gBAAA,EAEAlD,EAAAG,qBAAAwE,IACA3E,EAAAK,gBACAL,EAAAc,GAAA0E,OAGAxF,EAAAG,qBAAAkC,QAAA,MAEArC,EAAAG,qBAAAuG,QAAA1G,SAAA,WACA,MAAA,UAMAF,EAAAoF,UAAAgD,gBAAA,WACA/I,KAAA2B,GAAAoH,mBAKApI,EAAAoF,UAAAxF,KAAA,SAAAyI,EAAAC,EAAAC,GACA,GAAArI,GAAAb,IACA,KAAAA,KAAAmB,uBAAA,IAAAgI,QAAAnJ,KAAAmB,sBACA,KAAA,IAAA6F,OAAA,+BAEA,KAAAgC,EACA,KAAA,IAAAhC,OAAA,kCAQA,OAPAnG,GAAAI,iBACAJ,EAAAI,eAAAuE,IACAxF,KAAAsB,WAAAT,EAAAc,GAAApB,KAAAA,KAAAM,EAAAc,GAAAqH,GACAC,WAAAA,EACAC,QAAAA,KAGArI,EAAAI,gBAKAN,EAAAoF,UAAAqD,OAAA,SAAAzG,GACA,GAAA0G,GAAArJ,KAAA2B,GAAA2H,wBACAC,EAAAvJ,KAAA2B,GAAA6H,sBACAC,EAAAzJ,IAEA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GAKA,GAJAvB,IACAA,EAAA0G,EAAAK,OAAA,GAAAL,EAAA,IAGA1G,EAAA,CACA,GAAAgH,KACAJ,GAAAhD,QAAA,SAAAjF,GACAA,IAAAqB,IACArB,EAAA0B,YAAA2G,EAAAvC,KAAA9F,EAAA2B,SAAA,MAGAC,EAAA2F,QACAe,IAAAD,GACAE,KAAA,WACAJ,EAAAnI,WAAAqB,EACA8G,EAAA9H,GAAAyH,OAAAzG,KAJAkG,SAMA,SAAA/E,GAEA,KADA2F,GAAAnF,OAAA3B,GACAmB,SAGAI,QAQAvD,EAAAoF,UAAA+D,OAAA,WACA,MAAA9J,MAAA2B,GAAA6H,sBAAAO,OAAA,SAAApH,GACA,MAAAA,GAAAmH,SACSJ,OAAA,GAST/I,EAAAoF,UAAAzB,OAAA,SAAA3B,GACA,GAAA8G,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACAvB,EAAA8G,EAAAO,QAAArH,GACA8G,EAAA9H,GAAA2C,OAAA3B,GACAA,IAAA8G,EAAAnI,aAAAmI,EAAAnI,WAAA,MACA4B,OAIAvC,EAAAoF,UAAAiE,QAAA,SAAArH,GAEA,GADAA,IAAAA,EAAA3C,KAAAsB,aACAqB,EAAA,KAAA,IAAAqE,OAAA,4BACA,OAAArE,IAYAhC,EAAAoF,UAAAkE,SAAA,SAAAhE,EAAAtD,GACA,GAAA8G,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACAvB,EAAA8G,EAAAO,QAAArH,GACAA,GAAAA,EAAAsH,SAAA1J,KAAAoC,EAAAsD,GACA/C,OAUAvC,EAAAoF,UAAAmE,KAAA,SAAAvH,GACA,GAAA8G,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACAvB,EAAA8G,EAAAO,QAAArH,GACAA,GAAAA,EAAAM,SAAA,GACAN,IAAA8G,EAAAnI,aAAAmI,EAAAnI,WAAA,MACA4B,OAUAvC,EAAAoF,UAAAoE,OAAA,SAAAxH,GACA,GAAA8G,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACAvB,EAAA8G,EAAAO,QAAArH,GACAA,IACA8G,EAAA9H,GAAA6H,sBAAAjD,QAAA,SAAAjF,GACAA,IAAAqB,GAAArB,EAAA8I,cAAA9I,EAAA0B,YACA1B,EAAA2B,SAAA,KAGAN,EAAAM,SAAA,GACAwG,EAAAnI,WAAAqB,GAEAO,OAWAvC,EAAAoF,UAAAsE,KAAA,SAAA1H,GACA,GAAA8G,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACAvB,EAAA8G,EAAAO,QAAArH,GACAA,GAAAA,EAAA2H,SAAA,GACApH,OAUAvC,EAAAoF,UAAAwE,OAAA,SAAA5H,GACA,GAAA8G,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACAvB,EAAA8G,EAAAO,QAAArH,GACAA,GAAAA,EAAA2H,SAAA,GACApH,OAaAvC,EAAAoF,UAAAyE,SAAA,SAAA7H,EAAA8H,EAAA7J,GACA,GAAA6I,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACAvB,EAAA8G,EAAAO,QAAArH,GACAA,GAAAA,EAAA6H,SAAAC,EAAA7J,GACA+B,IAAA8G,EAAAnI,aAAAmI,EAAAnI,WAAA,MACA4B,OAIArD,EAAAD,QAAAe,GFoEM,SAASd,EAAQD,EAASM,IGvlBhC,SAAAwK,GAIA7K,EAAAD,QAAA,SAAAwE,GACA,YAEA,IAAA9B,MAEAqI,EAAAzK,EAAA,EAEAyF,QAAAiF,iBAAAtI,GACA4C,SACA2F,IAAA,WAAsB,MAAAF,GAAAzF,UAEtB4F,MACAD,IAAA,WAAsB,MAAAF,GAAAI,UAItB7K,EAAA,GAAAoC,EACA,IAAA0I,GAAA9K,EAAA,EACAoC,GAAA2I,cAAA/K,EAAA,GAAAkE,EAAA4G,GACA9K,EAAA,GAAAoC,GACAA,EAAAC,EAAArC,EAAA,GAAAoC,EAAAwI,KAAAxI,EAAA4C,SACA5C,EAAA4I,WAAAhL,EAAA,GACAoC,EAAA6I,OAAAjL,EAAA,IAAAkE,GACAlE,EAAA,IAAAoC,EAAA8B,GACAlE,EAAA,IAAAoC,GACApC,EAAA,IAAAoC,GACApC,EAAA,IAAAoC,GACApC,EAAA,IAAAoC,GACApC,EAAA,IAAAoC,EAAA8B,EACA,IAAAgH,GAAAlL,EAAA,IAAAoC,EAAA8B,EACAlE,GAAA,IAAAoC,EAAA8I,GACAlL,EAAA,IAAAoC,GACApC,EAAA,IAAAoC,EAAA8B,GACA9B,EAAA+I,aAAAnL,EAAA,IAAAoC,EAAA+C,cACAnF,EAAA,IAAAoC,GACApC,EAAA,IAAAoC,EACA,IAAAgJ,GAAApL,EAAA,IAAAoC,EACApC,GAAA,IAAAoC,EAAA8B,EAAAkH,GACApL,EAAA,IAAAoC,EAAA8B,EACA,IAAAmH,GAAArL,EAAA,IAAAoC,GACAkJ,EAAAtL,EAAA,IAAAoC,EAQA,OAPAA,GAAAuD,OAAA3F,EAAA,IAAAoC,EAAAmJ,MAAArH,EAAAmH,EAAAC,GACAtL,EAAA,IAAAoC,EAAA8B,GACA9B,EAAAoJ,MAAAxL,EAAA,IAAAoC,GACApC,EAAA,IAAAoC,GACAA,EAAAqJ,qBAAAzL,EAAA,IAAAoC,EAAAmJ,OACAnJ,EAAAsJ,QAAA1L,EAAA,IAAAoC,GAEAA,GACC,mBAAA8B,QAAAA,OAAAsG,KH2lB4BnK,KAAKX,EAAU,WAAa,MAAOI,WAI1D,SAASH,EAAQD,GIppBvBC,EAAAD,SACAiM,QAEA,eACA,oDAGAC,MAAA,eACAC,IAAA,eACAC,UAAA,EACAC,cAAA,EACAC,UAAA,UACAC,UACAC,MAAA,uBACAtB,KAAA,gBAEAuB,YAAA,SACAC,oBACAC,YACAzB,KAAA,SACA0B,IAAA,eACAC,QAAA,QACAC,MAAA,KACAC,KAAA,QACAC,KAAA,WAEAC,aACA,KAEAC,UAAA,uDACAC,QAAA,2CACAC,YAAA,KACAC,MAAA,eACAC,OAAA,kDACAC,QACAf,MAAA,iBACAtB,KAAA,iBAEAsC,MACAC,IAAA,0CAEAC,eAEAD,IAAA,8BAGAE,gBACAC,YAAA,iEACAC,iBACAC,WAAA,SACAC,MAAA,SACAC,mBAAA,SACAC,YAAA,SACAC,qBAAA,SACAC,wBAAA,SACAC,uBAAA,SACAC,uBAAA,SACAC,YAAA,SACAC,2BAAA,SACAC,cAAA,SACAC,MAAA,QACAC,gBAAA,UAEAC,eACAC,MACAC,OAAA,2CACAC,QAAA,uDAEAC,SACAC,KAAA,SAEAC,QAAA,2CACAC,SAAA,mBACAC,UACA,MACA,YACA,SACA,UACA,cAEAC,QAAA,MACAC,KAAA,aACAC,cAEA9C,MAAA,mBACAtB,KAAA,iBAGAsB,MAAA,uBACAtB,KAAA,iBAGAA,KAAA,SACAqE,wBACAC,OAAA,+BACAC,YACAzC,KAAA,MACAS,IAAA,2CAEAiC,SACA/L,KAAA,0BAEAwH,MAAA,SACA7F,QAAA,UJ2pBM,SAASrF,EAAQD,IKlwBvB,SAAA8K,GAIA7K,EAAAD,QAAA,SAAA0C,GACA,GAAAmJ,EAEAA,IAEA8D,QAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAC,CAGAA,GAAAJ,EAAA1J,SACA,KAAA6J,IAAAC,IACAF,GAAA5O,SAAAyO,EAAAI,MACAJ,EAAAI,GAAAC,EAAAD,GAKAH,GAAAK,MAAAN,EAAAE,IAGAK,gBAAA,SAAAnP,EAAAoP,EAAAC,EAAAC,EAAAC,EAAAC,GACAF,GAAAtP,EAAAqP,IACAE,EAAA7I,KAAA2I,EAAA,8BAAAD,EAAA,YAGApP,EAAAoP,IAAApP,EAAAqP,IACAE,EAAA7I,KAAA0I,EAAA,eAAAC,GAGArP,EAAAoP,GAAApP,EAAAoP,IAAApP,EAAAqP,IAAAG,GAGAC,sBAAA,SAAAzP,GAgBA,MAfA8J,GAAA4F,kBAAA1P,YAAA8J,GAAA4F,mBACA1P,GACA2P,OACAC,aACAC,OAAA,EACAC,MAAA,UAAA9P,EAAA+P,SAEAC,QACAC,QACAH,MAAA9P,OAMAA,GAGAkQ,gBAAA,SAAAC,GACA,MAAAC,oBAAAD,GAAAE,QAAA,eAA0D,KAAAvH,QAG1DwH,oBAAA,SAAA1B,EAAA1E,GACA,GAAA,MAAA0E,EAAA,CAGA,GAAA2B,GAAArG,EAAAsG,OAAA,GAAAC,cAAAvG,EAAAwG,MAAA,GACAC,GAAAzG,EAAA,SAAAqG,EAAA,MAAAA,EACA,KAAA,GAAAK,KAAAD,GAAA,CACA,GAAAE,GAAAjC,EAAA+B,EAAAC,GACA,IAAAC,EACA,MAAAA,MAKAC,gBAAA,SAAAC,GACA,GAAAA,EAAA,CAIA,GAAA/I,GAAA+I,EAAAC,QAAA,MACAC,EAAAF,EAAAC,QAAA,OAAAhJ,EAEA,OAAA,UAAA+I,EAAAL,MAAA1I,EAAAiJ,GAAA,yCAGAC,WAAA,SAAAC,GACA,MAAAhR,UAAAgR,EACA,sBAAApM,OAAAI,UAAAiM,SAAAzR,KAAAwR,IAEA,GAIAE,UAAA,SAAAC,GACA,OAAAC,MAAAD,IAAAE,WAAAF,KAAAG,SAAAH,EAAA,KAGAI,kBAAA,SAAAC,EAAAC,GACA,GAAAhB,GAAAiB,EACAC,EAAA,EAIA,KAFAF,EAAAA,GAAA,GAEAhB,EAAA,EAAae,EAAAf,EAAUA,IACvBiB,EAAAE,KAAAC,SAAAJ,EAAA,EACAE,GAAAD,EAAAT,SAAAQ,EAGA,OAAAE,IAGAG,OAAA,WACA,MAAAvQ,GAAAmJ,MAAA6G,kBAAAhQ,EAAAwQ,GAAAvQ,EAAAwQ,aAIAC,QAAA,WACA,GAAAC,GAAA,uCAAAhC,QAAA,QAAA,SAAAxQ,GACA,GAAAgS,GAAA,GAAAE,KAAAC,SAAA,EAAAM,EAAA,MAAAzS,EAAAgS,EAAA,EAAAA,EAAA,CACA,OAAAS,GAAAlB,SAAA,KAGA,OAAAiB,IAGAE,SAAA,SAAAC,GACA,MAAAA,IAGAA,EAAA9Q,EAAAsJ,QAAAyH,MAAAD,EAAA,QACA,KAAAA,EACAA,EAAAE,UADA,QAJA,QAoBAC,gBAAA,SAAA9I,EAAA7C,GACA,GAAAK,GAAAuL,EAAAC,EAAAC,CAGA,IAAAjJ,EAAA,CAGK,GAAAA,YAAAnI,GAAAqR,IACL,MAAAlJ,EAKK,IAAA,gBAAAA,GAAA,CAGL,OAFA+I,EAAA/I,EAAAmJ,MAAA,KAEAJ,EAAA9J,QACA,IAAA,GACA,IAAA9B,EACA,MAEA6L,GAAAhJ,EACAiJ,EAAA9L,CACA,MACA,KAAA,GACA6L,EAAAD,EAAA,GACAE,EAAAF,EAAA,EACA,MACA,SACAC,EAAAD,EAAAlC,MAAA,EAAAkC,EAAA9J,OAAA,GAAAmK,KAAA,KACAH,EAAAF,EAAAA,EAAA9J,OAAA,GAeA,MAXA+J,GAAAA,EAAAxC,QAAA,iBAAA,IAGA,iCAAA1N,KAAAkQ,KACAA,EAAAA,EAAAxC,QAAA,cAAA,KAIAxG,EAAAnI,EAAAC,EAAAD,IAAA,IAAAA,EAAAmJ,MAAAqI,WAAAL,GAAA,IAAAC,GAGAzL,EAAA3F,EAAAqR,IAAAN,MAAA5I,IACAxC,EAEA,eAYA6L,WAAA,SAAAC,GAEA,MAAA/C,oBAAAgD,mBAAAD,IAAA9C,QAAA,QAAA,KAAAA,QAAA,QAAA,KAAAA,QAAA,QAAA,KAAAA,QAAA,QAAA,MAGAgD,UAAA,SAAAlD,GACA,GASAmD,GATAC,GACAC,UAAA,UACAC,KAAA,OACAC,KAAA,OACAC,KAAA,OACAC,mBAAA,oBAEA1J,EAAAiG,EAAApJ,cAAAsJ,QAAA,KAAA,KAAA2C,MAAA,KACAa,EAAA,GACAC,EAAA5J,EAAApB,MAEA,KAAAwK,EAAA,EAAkBQ,EAAAR,EAAcA,IAChC,IAAAA,IACAO,GAAA,KAEAA,GAAA3J,EAAAoJ,GAAA9C,OAAA,GAAAC,cAAAvG,EAAAoJ,GAAAS,UAAA,EAKA,OAHAR,GAAAM,KACAA,EAAAN,EAAAM,IAEAA,GAGAG,cAAA,SAAApR,GACA,GAAAF,EAEA,KAAAA,IAAAhB,GAAAC,EAAAsS,iBACA,GAAA,KAAAvS,EAAAC,EAAAsS,iBAAAvR,GAAAsO,QAAApO,GACA,MAAAlB,GAAAC,EAAAF,OAAAiB,EAIA,OAAAhB,GAAAC,EAAAF,OAAAyS,kBAOAC,mBAAA,WACA,QAAAC,GAAAC,EAAAC,GACA,MAAAvC,MAAAwC,MAAAxC,KAAAC,UAAAsC,EAAAD,EAAA,GAAAA,GAEA,MAAA,WAAAD,EAAA,EAAA,MAGAI,kBAAA,SAAAzT,GACA,GAAA0T,GACAC,EAAAhT,EAAAwQ,GAAAvQ,EAAAgT,gBAAAvD,UAEA,KAAAqD,IAAA/S,GAAAwQ,GAAAvQ,EAAAiT,cACA7T,EAAA8T,cAAAJ,KACAC,GAAA,IAAAhT,EAAAwQ,GAAAvQ,EAAAiT,cAAAH,GAIA,OAAAC,IAIAI,aAAA,SAAA3E,GACA,QAAA4E,GAAAC,EAAAC,GACA,MAAAD,IAAAC,EAAAD,IAAA,GAAAC,EAGA,QAAAC,GAAAC,EAAAC,GACA,GAAAC,GAAAC,EAAAC,EAAAC,EAAAC,CAMA,OALAF,GAAA,WAAAJ,EACAK,EAAA,WAAAJ,EACAC,EAAA,WAAAF,EACAG,EAAA,WAAAF,EACAK,GAAA,WAAAN,IAAA,WAAAC,GACAC,EAAAC,EACA,WAAAG,EAAAF,EAAAC,EAEAH,EAAAC,EACA,WAAAG,EACA,WAAAA,EAAAF,EAAAC,EAEA,WAAAC,EAAAF,EAAAC,EAGAC,EAAAF,EAAAC,EAIA,QAAAE,GAAAC,EAAAC,EAAAC,GACA,MAAAF,GAAAC,GAAAD,EAAAE,EAGA,QAAAC,GAAAH,EAAAC,EAAAC,GACA,MAAAF,GAAAE,EAAAD,GAAAC,EAGA,QAAAE,GAAAJ,EAAAC,EAAAC,GACA,MAAAF,GAAAC,EAAAC,EAGA,QAAAG,GAAAL,EAAAC,EAAAC,GACA,MAAAD,IAAAD,GAAAE,GAGA,QAAAI,GAAAC,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAU,EAAAC,GAEA,MADAJ,GAAAhB,EAAAgB,EAAAhB,EAAAA,EAAAQ,EAAAS,EAAAtW,EAAAuW,GAAAT,GAAAW,IACApB,EAAAH,EAAAmB,EAAAG,GAAAF,GAGA,QAAAI,GAAAL,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAU,EAAAC,GAEA,MADAJ,GAAAhB,EAAAgB,EAAAhB,EAAAA,EAAAY,EAAAK,EAAAtW,EAAAuW,GAAAT,GAAAW,IACApB,EAAAH,EAAAmB,EAAAG,GAAAF,GAGA,QAAAK,GAAAN,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAU,EAAAC,GAEA,MADAJ,GAAAhB,EAAAgB,EAAAhB,EAAAA,EAAAa,EAAAI,EAAAtW,EAAAuW,GAAAT,GAAAW,IACApB,EAAAH,EAAAmB,EAAAG,GAAAF,GAGA,QAAAM,GAAAP,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAU,EAAAC,GAEA,MADAJ,GAAAhB,EAAAgB,EAAAhB,EAAAA,EAAAc,EAAAG,EAAAtW,EAAAuW,GAAAT,GAAAW,IACApB,EAAAH,EAAAmB,EAAAG,GAAAF,GAGA,QAAAO,GAAAvG,GASA,IARA,GAAAwG,GACAC,EAAAzG,EAAArH,OACA+N,EAAAD,EAAA,EACAE,GAAAD,EAAAA,EAAA,IAAA,GACAE,EAAA,IAAAD,EAAA,GACAE,EAAA7P,MAAA4P,EAAA,GACAE,EAAA,EACAC,EAAA,EACAN,EAAAM,GACAP,GAAAO,EAAAA,EAAA,GAAA,EACAD,EAAAC,EAAA,EAAA,EACAF,EAAAL,GAAAK,EAAAL,GAAAxG,EAAAgH,WAAAD,IAAAD,EACAC,GAOA,OALAP,IAAAO,EAAAA,EAAA,GAAA,EACAD,EAAAC,EAAA,EAAA,EACAF,EAAAL,GAAAK,EAAAL,GAAA,KAAAM,EACAD,EAAAD,EAAA,GAAAH,GAAA,EACAI,EAAAD,EAAA,GAAAH,IAAA,GACAI,EAGA,QAAAI,GAAApC,GACA,GAAAqC,GAAAC,EAAAC,EAAA,GAAAC,EAAA,EACA,KAAAF,EAAA,EAAsB,GAAAA,EAAUA,IAChCD,EAAArC,IAAA,EAAAsC,EAAA,IACAE,EAAA,IAAAH,EAAAjG,SAAA,IACAmG,GAAAC,EAAAC,OAAAD,EAAA1O,OAAA,EAAA,EAEA,OAAAyO,GAGA,QAAAG,GAAAvH,GACAA,EAAAA,EAAAE,QAAA,QAAA,KAGA,KAAA,GAFAsH,GAAA,GAEAC,EAAA,EAAqBA,EAAAzH,EAAArH,OAAmB8O,IAAA,CACxC,GAAA/X,GAAAsQ,EAAAgH,WAAAS,EAEA,KAAA/X,EACA8X,GAAAE,OAAAC,aAAAjY,GAEAA,EAAA,KAAA,KAAAA,GACA8X,GAAAE,OAAAC,aAAAjY,GAAA,EAAA,KACA8X,GAAAE,OAAAC,aAAA,GAAAjY,EAAA,OAGA8X,GAAAE,OAAAC,aAAAjY,GAAA,GAAA,KACA8X,GAAAE,OAAAC,aAAAjY,GAAA,EAAA,GAAA,KACA8X,GAAAE,OAAAC,aAAA,GAAAjY,EAAA,MAGA,MAAA8X,GAGA,GACAI,GAAAC,EAAAC,EAAAC,EAAAC,EAAAjC,EAAAC,EAAAtW,EAAAuW,EADAT,KAEAyC,EAAA,EAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,GACAC,EAAA,EAAAC,EAAA,EAAAC,EAAA,GAAAC,EAAA,GACAC,EAAA,EAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,GACAC,EAAA,EAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,EAQA,KANAhJ,EAAAuH,EAAAvH,GAEAwF,EAAAe,EAAAvG,GAEA+F,EAAA,WAAmBC,EAAA,WAAgBtW,EAAA,WAAgBuW,EAAA,UAEnD2B,EAAA,EAAaA,EAAApC,EAAA7M,OAAWiP,GAAA,GACxBC,EAAA9B,EAAW+B,EAAA9B,EAAM+B,EAAArY,EAAMsY,EAAA/B,EACvBF,EAAAD,EAAAC,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,GAAAK,EAAA,YACAhC,EAAAH,EAAAG,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,GAAAM,EAAA,YACAxY,EAAAoW,EAAApW,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,GAAAO,EAAA,WACAnC,EAAAF,EAAAE,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,GAAAQ,EAAA,YACArC,EAAAD,EAAAC,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,GAAAK,EAAA,YACAhC,EAAAH,EAAAG,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,GAAAM,EAAA,YACAxY,EAAAoW,EAAApW,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,GAAAO,EAAA,YACAnC,EAAAF,EAAAE,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,GAAAQ,EAAA,YACArC,EAAAD,EAAAC,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,GAAAK,EAAA,YACAhC,EAAAH,EAAAG,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,GAAAM,EAAA,YACAxY,EAAAoW,EAAApW,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,IAAAO,EAAA,YACAnC,EAAAF,EAAAE,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,IAAAQ,EAAA,YACArC,EAAAD,EAAAC,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,IAAAK,EAAA,YACAhC,EAAAH,EAAAG,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,IAAAM,EAAA,YACAxY,EAAAoW,EAAApW,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,IAAAO,EAAA,YACAnC,EAAAF,EAAAE,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,IAAAQ,EAAA,YACArC,EAAAK,EAAAL,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,GAAAS,EAAA,YACApC,EAAAG,EAAAH,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,GAAAU,EAAA,YACA5Y,EAAA0W,EAAA1W,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,IAAAW,EAAA,WACAvC,EAAAI,EAAAJ,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,GAAAY,EAAA,YACAzC,EAAAK,EAAAL,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,GAAAS,EAAA,YACApC,EAAAG,EAAAH,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,IAAAU,EAAA,UACA5Y,EAAA0W,EAAA1W,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,IAAAW,EAAA,YACAvC,EAAAI,EAAAJ,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,GAAAY,EAAA,YACAzC,EAAAK,EAAAL,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,GAAAS,EAAA,WACApC,EAAAG,EAAAH,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,IAAAU,EAAA,YACA5Y,EAAA0W,EAAA1W,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,GAAAW,EAAA,YACAvC,EAAAI,EAAAJ,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,GAAAY,EAAA,YACAzC,EAAAK,EAAAL,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,IAAAS,EAAA,YACApC,EAAAG,EAAAH,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,GAAAU,EAAA,YACA5Y,EAAA0W,EAAA1W,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,GAAAW,EAAA,YACAvC,EAAAI,EAAAJ,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,IAAAY,EAAA,YACAzC,EAAAM,EAAAN,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,GAAAa,EAAA,YACAxC,EAAAI,EAAAJ,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,GAAAc,EAAA,YACAhZ,EAAA2W,EAAA3W,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,IAAAe,EAAA,YACA3C,EAAAK,EAAAL,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,IAAAgB,EAAA,YACA7C,EAAAM,EAAAN,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,GAAAa,EAAA,YACAxC,EAAAI,EAAAJ,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,GAAAc,EAAA,YACAhZ,EAAA2W,EAAA3W,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,GAAAe,EAAA,YACA3C,EAAAK,EAAAL,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,IAAAgB,EAAA,YACA7C,EAAAM,EAAAN,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,IAAAa,EAAA,WACAxC,EAAAI,EAAAJ,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,GAAAc,EAAA,YACAhZ,EAAA2W,EAAA3W,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,GAAAe,EAAA,YACA3C,EAAAK,EAAAL,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,GAAAgB,EAAA,UACA7C,EAAAM,EAAAN,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,GAAAa,EAAA,YACAxC,EAAAI,EAAAJ,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,IAAAc,EAAA,YACAhZ,EAAA2W,EAAA3W,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,IAAAe,EAAA,WACA3C,EAAAK,EAAAL,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,GAAAgB,EAAA,YACA7C,EAAAO,EAAAP,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,GAAAiB,EAAA,YACA5C,EAAAK,EAAAL,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,GAAAkB,EAAA,YACApZ,EAAA4W,EAAA5W,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,IAAAmB,EAAA,YACA/C,EAAAM,EAAAN,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,GAAAoB,EAAA,YACAjD,EAAAO,EAAAP,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,IAAAiB,EAAA,YACA5C,EAAAK,EAAAL,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,GAAAkB,EAAA,YACApZ,EAAA4W,EAAA5W,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,IAAAmB,EAAA,YACA/C,EAAAM,EAAAN,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,GAAAoB,EAAA,YACAjD,EAAAO,EAAAP,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,GAAAiB,EAAA,YACA5C,EAAAK,EAAAL,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,IAAAkB,EAAA,YACApZ,EAAA4W,EAAA5W,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,GAAAmB,EAAA,YACA/C,EAAAM,EAAAN,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,IAAAoB,EAAA,YACAjD,EAAAO,EAAAP,EAAAC,EAAAtW,EAAAuW,EAAAT,EAAAoC,EAAA,GAAAiB,EAAA,YACA5C,EAAAK,EAAAL,EAAAF,EAAAC,EAAAtW,EAAA8V,EAAAoC,EAAA,IAAAkB,EAAA,YACApZ,EAAA4W,EAAA5W,EAAAuW,EAAAF,EAAAC,EAAAR,EAAAoC,EAAA,GAAAmB,EAAA,WACA/C,EAAAM,EAAAN,EAAAtW,EAAAuW,EAAAF,EAAAP,EAAAoC,EAAA,GAAAoB,EAAA,YACAjD,EAAAhB,EAAAgB,EAAA8B,GACA7B,EAAAjB,EAAAiB,EAAA8B,GACApY,EAAAqV,EAAArV,EAAAqY,GACA9B,EAAAlB,EAAAkB,EAAA+B,EAGA,IAAAiB,GAAAhC,EAAAlB,GAAAkB,EAAAjB,GAAAiB,EAAAvX,GAAAuX,EAAAhB,EAEA,OAAAgD,GAAArS,gBAIArF,EAAAmJ,MAAAA,KLuwB6BlL,KAAKX,EAAU,WAAa,MAAOI,WAI1D,SAASH,EAAQD,GM1uCvBC,EAAAD,QAAA,WAEA,GAAAoL,GAAA,SAAAmF,EAAA8J,EAAAC,GACAla,KAAAmQ,OAAAA,EACAnQ,KAAAia,SAAAA,EACAja,KAAAka,MAAAA,EAoBA,OAhBAlP,GAAAjF,UAAAoU,MAAA,SAAAC,GACApa,KAAAmQ,OAAAgK,MAAAna,KAAAia,SAAAja,KAAAka,MAAAE,IAGApP,EAAAjF,UAAAW,IAAA,SAAA0T,GACApa,KAAAmQ,OAAAzJ,IAAA1G,KAAAia,SAAAja,KAAAka,MAAAE,IAGApP,EAAAjF,UAAAuB,KAAA,SAAA8S,GACApa,KAAAmQ,OAAA7I,KAAAtH,KAAAia,SAAAja,KAAAka,MAAAE,IAGApP,EAAAjF,UAAAsU,MAAA,SAAAD,GACApa,KAAAmQ,OAAAkK,MAAAra,KAAAia,SAAAja,KAAAka,MAAAE,IAGApP,MNmvCM,SAASnL,EAAQD,GO5wCvBC,EAAAD,QAAA,SAAAwE,EAAA4G,GAGA,GAAAvE,GAAArC,EAAAqC,UACA0T,MAAA,aACAzT,IAAA,aACAY,KAAA,aACA+S,MAAA,cAGApP,EAAA,WACA,GAAAkF,GACAmK,GACAD,MAAA,EACA/S,KAAA,EACAZ,IAAA,EACAyT,MAAA,GAGA3R,EAAA,EACA+R,GAAA,EACAC,EAAA,IAEAxa,MAAAya,WAEAtK,EAAAnQ,KAAA0a,UAAA,qBAGA/U,OAAAiF,iBAAA5K,MACAua,gBACA1P,IAAA,WAAsB,MAAA0P,IACtBI,IAAA,SAAA1U,GACA,iBAAAA,GACAsU,EAAAtU,EAEAkK,EAAAkK,MAAA,6CAAAO,KAAAC,UAAA5U,MAKAuC,OACAqC,IAAA,WAAuB,MAAArC,IACvBmS,IAAA,SAAA1U,GACAA,GAAA,GAAA,GAAAA,EACAuC,EAAAvC,EACSA,EAAA,EACTuC,EAAA,EACS8R,EAAAQ,eAAA7U,GACTuC,EAAA8R,EAAArU,GAEAkK,EAAAkK,MAAA,oCAAAO,KAAAC,UAAA5U,MAKAuU,WACA3P,IAAA,WAAuB,MAAA2P,IACvBG,IAAA,SAAA1U,GACA,OAAAA,GAAA,KAAAA,GAAAlF,SAAAkF,EACAuU,EAAA,KACS,kBAAAvU,GACTuU,EAAAvU,EAEAkK,EAAAkK,MAAA,wCAAAO,KAAAC,UAAA5U,QAuFA,OAhFAgF,GAAAlF,UAAAgV,MAAA,SAAAtQ,EAAAwP,EAAAC,EAAAE,GACA,GAAAY,KAEAA,GAAA5T,KAAA,GAAA6T,OAEAD,EAAA5T,KAAA6S,GAEAC,GACAc,EAAA5T,KAAA8S,GAGAc,EAAA5T,KAAA,IAEA,gBAAAgT,GACA3P,EAAAlK,KAAAkG,EAAAuU,EAAAnH,KAAA,OAAAuG,GAEA3P,EAAAlK,KAAAkG,EAAA2T,IAIAnP,EAAAlF,UAAAoU,MAAA,SAAAF,EAAAC,EAAAE,GACA,IAAApa,KAAAwI,QACAxI,KAAAua,gBACAva,KAAA+a,MAAAtU,EAAA0T,MAAAF,EAAAC,EAAAE,GAGApa,KAAAwa,WACAxa,KAAAwa,UAAA,QAAAP,EAAAC,EAAAE,KAKAnP,EAAAlF,UAAAW,IAAA,SAAAuT,EAAAC,EAAAE,GACApa,KAAAwI,OAAA,IACAxI,KAAAua,gBACAva,KAAA+a,MAAAtU,EAAAC,IAAAuT,EAAAC,EAAAE,GAGApa,KAAAwa,WACAxa,KAAAwa,UAAA,MAAAP,EAAAC,EAAAE,KAKAnP,EAAAlF,UAAAuB,KAAA,SAAA2S,EAAAC,EAAAE,GACApa,KAAAwI,OAAA,IACAxI,KAAAua,gBACAva,KAAA+a,MAAAtU,EAAAa,KAAA2S,EAAAC,EAAAE,GAGApa,KAAAwa,WACAxa,KAAAwa,UAAA,OAAAP,EAAAC,EAAAE,KAKAnP,EAAAlF,UAAAsU,MAAA,SAAAJ,EAAAC,EAAAE,GACApa,KAAAua,gBACAva,KAAA+a,MAAAtU,EAAA4T,MAAAJ,EAAAC,EAAAE,GAGApa,KAAAwa,WACAxa,KAAAwa,UAAA,QAAAP,EAAAC,EAAAE,IAIAnP,EAAAlF,UAAA2U,UAAA,SAAAT,EAAAC,GACA,GAAA/J,EAEA,OAAA+J,IAAA,IAAAla,KAAAwI,MACA,GAAAwC,GAAAhL,KAAAia,EAAAC,GACGla,KAAAya,QAAAR,GACHja,KAAAya,QAAAR,IAEA9J,EAAA,GAAAnF,GAAAhL,KAAAia,GACAja,KAAAya,QAAAR,GAAA9J,EACAA,IAIAlF,IPqxCM,SAASpL,EAAQD,GQp6CvBC,EAAAD,QAAA,SAAA0C,GACA,GACA+C,GACA6V,EACA/K,GAAA,GAAA7N,GAAA2I,eAAAyP,UAAA,oBACAnY,GACA4Y,cAAA,GAGA9V,GAAA,aACAA,EAAAU,WAKAqV,WAAA,SAAAjZ,GAGA,MAFAnC,MAAAmC,UAEAnC,KAAAqb,eAAAlZ,IAGAkZ,eAAA,SAAAlZ,GACA,GAAAyN,EAQA,KANA5P,KAAAmQ,SACAnQ,KAAAmQ,OAAAA,GAGAnQ,KAAAsb,aAAA/Y,EAAA4Y,cAEAvL,EAAA,EAAiBA,EAAAzN,EAAAuH,OAAqBkG,IACtC5P,KAAAmC,OAAAA,EAAAyN,IAIA5P,KAAAmQ,OAAAzJ,IAAA,kBAAAvE,EAAAyN,GAAA,oBAHA5P,KAAAmQ,OAAAzJ,IAAA,gBAAAvE,EAAAyN,IACA5P,KAAAmC,OAAAA,EAAAyN,OAMA,OAAA5P,OAQAub,WAAA,SAAAlG,GACA,SAAArV,KAAAmC,SAAAnC,KAAAmC,OAAAkT,KAQAI,cAAA,SAAAJ,GACA,MAAArV,MAAAub,WAAAlG,IAAArV,KAAAmC,OAAAkT,GAAA3L,OAAA,GAQA7H,GAAA,SAAAwT,EAAAmG,EAAAC,GACA,GAAA1a,SAAAya,EACA,MAAAxb,KACK,IAAA,kBAAAwb,GAEL,MADAxb,MAAAmQ,OAAAkK,MAAA,+BACAra,IACK,KAAAA,KAAAub,WAAAlG,GAEL,KADArV,MAAAmQ,OAAAkK,MAAA,mDAAAhF,GACA,GAAAqG,WAAA,mCAAArG,EAGA,IAAAsG,IAAuBH,SAAAA,EAKvB,OAJAC,KACAE,EAAAF,WAAAA,GAGAzb,KAAAmC,OAAAkT,GAAA3L,QAAA1J,KAAAsb,cACAtb,KAAAmQ,OAAA7I,KAAA,oCAAA+N,GACArV,OAGAA,KAAAmC,OAAAkT,GAAAjO,KAAAuU,GACA3b,KAAAmQ,OAAAzJ,IAAA,+BAAA2O,GACArV,OASA4b,KAAA,SAAAvG,EAAAmG,EAAAC,GAEA,QAAAI,KACAL,EAAA1L,MAAA9P,KAAA8b,WACArS,EAAAsS,IAAA1G,EAAAwG,EAAAJ,GAHA,GAAAhS,GAAAzJ,IAMA,OAAAA,MAAA6B,GAAAwT,EAAAwG,EAAAJ,IASAM,IAAA,SAAA1G,EAAAmG,EAAAC,GACA,GAAAtZ,GAAAuH,EACAkG,EAAA,CAEA,IAAA4L,GAAA,kBAAAA,GAEA,MADAxb,MAAAmQ,OAAAkK,MAAA,+BACAra,IACK,KAAAqV,EAAA,CACL,IAAAzF,IAAA5P,MAAAmC,OACAnC,KAAAmC,OAAAyN,KAEA,OAAA5P,MACK,IAAAA,KAAAub,WAAAlG,GAEL,KADArV,MAAAmQ,OAAAkK,MAAA,wDAAAhF,GACA,GAAAqG,WAAA,mCAAArG,EAMA,KAHAlT,EAAAnC,KAAAmC,OAAAkT,GACA3L,EAAAvH,EAAAuH,OAEAA,EAAAkG,IACAzN,EAAAyN,IACA4L,GAAArZ,EAAAyN,GAAA4L,WAAAA,GACAC,GAAAtZ,EAAAyN,GAAA6L,aAAAA,EAGA7L,IAFAzN,EAAA6Z,OAAApM,EAAA,EAMA,OAAA5P,OASAic,gBAAA,SAAAC,GACA,MAAA,gBAAAA,IAAA,EAAAA,GACAlc,KAAAmQ,OAAAkK,MAAA,uCACAra,OAGAA,KAAAsb,aAAAY,EACAlc,OAQA6C,KAAA,SAAAwS,GACA,IAAArV,KAAAub,WAAAlG,GAEA,KADArV,MAAAmQ,OAAAkK,MAAA,sCAAAhF,GACA,GAAAqG,WAAA,mCAAArG,EAGArV,MAAAmQ,OAAAzJ,IAAA,kBAAA2O,EAGA,IAAA3F,GAAA3H,MAAAhC,UAAAuL,MAAA/Q,KAAAub,UAAA,EASA,OARA9b,MAAAmC,OAAAkT,GAAA/D,QAAA/K,QAAA,SAAAiV,GACA,IACAA,EAAAA,SAAA1L,MAAA0L,EAAAC,YAAAzb,KAAA0P,GACO,MAAAyM,GACPnc,KAAAmQ,OAAAkK,MAAA8B,EAAAC,SAEKpc,MAELA,OAIAkb,EAAA,SAAAtO,EAAAyP,EAAAC,GACAtc,KAAA4M,KAAAA,EACA5M,KAAAqc,OAAAA,EACArc,KAAAsc,KAAAA,GAGAjX,EAAA9C,EAAAA,EAEAD,EAAA+C,aAAAA,EACA/C,EAAA4Y,MAAAA,IRo7CM,SAASrb,EAAQD,GSznDvBC,EAAAD,QAAA,SAAAkL,EAAA5F,GACA,OACAqX,WAAAzR,EAAA,IAAA5F,EAGA5C,IAAA,MACAka,KAAA,OAGAna,QAEAoa,iBAAA,mBACAC,gBAAA,kBACA5H,iBAAA,mBACA6H,eAAA,iBAGAC,KAAA,OACAC,SAAA,WACAC,WAAA,aACAC,YAAA,cACAC,UAAA,YACAC,mBAAA,qBACAC,iBAAA,mBACAC,qBAAA,uBACAC,aAAA,eAGAC,qBAAA,uBACAC,aAAA,eACAC,SAAA,WACAC,UAAA,YACAC,QAAA,UACAC,OAAA,SACAC,SAAA,WACAC,yBAAA,2BACAC,sBAAA,wBACAC,YAAA,eAGAC,WACAC,YAAA,OACAC,UAAA,YACAC,SAAA,YAGArJ,kBACAiI,YAAA,IAAA,IAAA,IAAA,IAAA,KACAF,MAAA,IAAA,KACAC,UAAA,IAAA,KACAG,WAAA,IAAA,KACAD,aAAA,IAAA,IAAA,IAAA,KACAE,oBAAA,KACAC,kBAAA,IAAA,KACAC,sBAAA,IAAA,MAIAgB,IAAA,MACAC,IAAA,MACAC,OAAA,SACAC,KAAA,OACAC,OAAA,SACAC,QAAA,UACAC,OAAA,SACAC,QAAA,UACAC,SAAA,WACAC,OAAA,SACAC,UAAA,YACAC,MAAA,QACAC,MAAA,QAMAtc,eACAuc,IAAA,SACAC,IAAA,UACAC,IAAA,0BACAC,IAAA,SACAC,IAAA,mBACAC,IAAA,0BACAC,IAAA,KACAC,IAAA,WACAC,IAAA,kBACAC,IAAA,mBACAC,IAAA,oBACAC,IAAA,oBACAC,IAAA,YACAC,IAAA,sBACAC,IAAA,cACAC,IAAA,eACAC,IAAA,mBACAC,IAAA,YACAC,IAAA,YACAC,IAAA,qBACAC,IAAA,iBACAC,IAAA,gCACAC,IAAA,kBACAC,IAAA,OACAC,IAAA,6BACAC,IAAA,2BACAC,IAAA,uBACAC,IAAA,yBACAC,IAAA,yBACAC,IAAA,4BACAC,IAAA,gBACAC,IAAA,qBACAC,IAAA,6BACAC,IAAA,qBACAC,IAAA,sBACAC,IAAA,4BACAC,IAAA,cACAC,IAAA,uBACAC,IAAA,oBACAC,IAAA,0BACAC,IAAA,0BACAC,IAAA,mCACAC,IAAA,uBACAC,IAAA,mBACAC,IAAA,iBACAC,IAAA,2BACAC,IAAA,0BACAC,IAAA,kCACAC,IAAA,gBACAC,IAAA,gBACAC,IAAA,qBACAC,IAAA,YACAC,IAAA,YACAC,IAAA,qBACAC,IAAA,sBACAC,IAAA,YACAC,IAAA,kBACAC,IAAA,iBACAC,IAAA,8BACAC,IAAA,wBACAC,IAAA,kBACAC,IAAA,cACAC,IAAA,sBACAC,IAAA,kBACAC,IAAA,wBACAC,IAAA,oBACAC,IAAA,uBACAC,IAAA,kBACAC,IAAA,UACAC,IAAA,0BACAC,IAAA,qBT4oDM,SAASzjB,EAAQD,GUhyDvBC,EAAAD,SACA2jB,mBAAA,WACA,GAAAC,GAAA,SAAAC,EAAAxd,GACAjG,KAAA0jB,KAAA,EACA1jB,KAAA8K,KAAA,sBACA9K,KAAAyjB,UAAAA,EACAzjB,KAAAiG,MAAAA,EACAjG,KAAA2jB,QAAA3jB,KAAAiG,MAAA,iBAAA2U,KAAAC,UAAA7a,KAAAiG,OAAA,mBAAAjG,KAAAyjB,UAAA,IAAA,sBAAAzjB,KAAAyjB,UAGA,OADAD,GAAAzd,UAAA,GAAAiB,OACAwc,KAGAI,kBAAA,WACA,GAAAJ,GAAA,SAAAK,GACA7jB,KAAA0jB,KAAA,EACA1jB,KAAA8K,KAAA,sBACA9K,KAAA6jB,OAAAA,EACA7jB,KAAA2jB,QAAA,mBAAAE,EAGA,OADAL,GAAAzd,UAAA,GAAAiB,OACAwc,KAGAM,kBAAA,WACA,GAAAN,GAAA,SAAAG,GACA3jB,KAAA0jB,KAAA,EACA1jB,KAAA8K,KAAA,sBACA9K,KAAA2jB,QAAAA,EAGA,OADAH,GAAAzd,UAAA,GAAAiB,OACAwc,KAGAO,cAAA,WACA,GAAAP,GAAA,SAAAG,GACA3jB,KAAA0jB,KAAA,EACA1jB,KAAA8K,KAAA,kBACA9K,KAAA2jB,QAAAA,EAGA,OADAH,GAAAzd,UAAA,GAAAiB,OACAwc,OVizDM,SAAS3jB,EAAQD,GW31DvB,GACAokB,GAAA,IACAC,EAAA,IACAC,EAAA,GACArkB,GAAAD,QAAA,SAAAukB,GACA,GAAAvkB,IACAokB,GAAAA,EACAC,GAAAA,EACAC,GAAAA,EACAE,QAAA,GAAAJ,EACAK,QAAA,EAAAL,EACAM,QAAA,GAAAN,EACAO,QAAA,GAAAP,EACAQ,QAAA,EAAAR,EACAS,QAAA,EAAAT,EACAU,QAAA,EAAAR,EACAS,QAAA,GAAAX,EACAY,QAAA,GAAAZ,EACAa,QAAA,GAAAb,EACAc,8BAAA,IAYA,QATA,aAAA,eAAA,cAAA,iBACAve,QAAA,SAAAuE,GAGAlL,EAAAkL,GAAA,WACA,MAAAqZ,GAAArZ,GAAAgF,MAAAqU,EAAArI,cAIAlc,IX02DM,SAASC,EAAQD,GYt4DvBC,EAAAD,QAAA,SAAA0C,EAAA8B,GACA,GAAA2gB,GACAxiB,GAEAyiB,aAAA,EACAC,oBAAA,EACAC,aAAA,EAGAH,GAAA,SAAApjB,EAAAwjB,GAEAnlB,KAAAmQ,OAAAxO,EAAA+Y,UAAA,iBACA1a,KAAA2B,GAAAA,EACA3B,KAAAolB,GAAA,KACAplB,KAAAmlB,OAAAA,EACAnlB,KAAAqlB,sBAAA,EACArlB,KAAAslB,QAAA,EACAtlB,KAAAulB,WAAA,EACAvlB,KAAAwlB,eAAA,KACAxlB,KAAAylB,sBAEAzlB,KAAA2B,GAAA+F,UAAA1H,KAGAA,KAAA0lB,WAGAX,EAAAhf,WAMA4f,KAAA,SAAAC,GACA,GAAAjC,GAAAiC,EAAA5T,UAEA,OAAAhS,MAAAolB,IAAAplB,KAAAolB,GAAAS,aAAAzhB,EAAA0hB,UAAAC,MACA/lB,KAAA2B,GAAAqkB,cAAA3d,YAAA,GACArI,KAAAmQ,OAAAzJ,IAAA,iCAAAid,EAAA,MAEA3jB,KAAAolB,GAAAO,KAAAhC,IACA,IAEA3jB,KAAAmQ,OAAA7I,KAAA,kDACA,IAOA2e,WAAA,WACAjmB,KAAAolB,KAEA9iB,EAAA6I,OAAA+a,aAAAlmB,KAAAwlB,gBAEAxlB,KAAAslB,QAAA,EACAtlB,KAAAmQ,OAAAzJ,IAAA,qBAAA1G,KAAAmlB,OAAAgB,QACAnmB,KAAAolB,GAAAgB,SAGA,OAAApmB,KAAAwlB,iBACAljB,EAAA6I,OAAA+a,aAAAlmB,KAAAwlB,gBACAxlB,KAAAwlB,eAAA,KACAxlB,KAAA2B,GAAAkB,KAAA,gBACA6E,UAAA1H,KACA0jB,KAAA1jB,KAAAylB,mBAAA/B,KACA2C,OAAArmB,KAAAylB,mBAAAY,WAQAX,QAAA,WACA,GAAAhe,GAAA1H,IAEA,IAAAA,KAAAolB,KAAAplB,KAAAolB,GAAAS,aAAAC,UAAAC,MAAA/lB,KAAAolB,GAAAS,aAAAC,UAAAQ,YAEA,MADAtmB,MAAAmQ,OAAAzJ,IAAA,aAAA1G,KAAAmlB,OAAAgB,OAAA,0BACA,CAGAnmB,MAAAolB,IACAplB,KAAAolB,GAAAgB,QAGApmB,KAAAmQ,OAAAzJ,IAAA,2BAAA1G,KAAAmlB,OAAAgB,QACAnmB,KAAA2B,GAAA4kB,sBAAAvmB,KACA,IAAAA,KAAAqlB,sBAAA,EAAArlB,KAAAqlB,sBAEA,KACArlB,KAAAolB,GAAA,GAAAhhB,GAAA0hB,UAAA9lB,KAAAmlB,OAAAgB,OAAA,OACK,MAAAriB,GACL9D,KAAAmQ,OAAA7I,KAAA,iCAAAtH,KAAAmlB,OAAAgB,OAAA,KAAAriB,GAGA9D,KAAAolB,GAAAoB,WAAA,cAEAxmB,KAAAolB,GAAAqB,OAAA,WACA/e,EAAAgf,UAGA1mB,KAAAolB,GAAAuB,QAAA,SAAA7iB,GACA4D,EAAAkf,QAAA9iB,IAGA9D,KAAAolB,GAAAyB,UAAA,SAAA/iB,GACA4D,EAAAof,UAAAhjB,IAGA9D,KAAAolB,GAAA2B,QAAA,SAAAjjB,GACA4D,EAAAsf,QAAAljB,KAUA4iB,OAAA,WACA1mB,KAAAulB,WAAA,EAEAvlB,KAAAmQ,OAAAzJ,IAAA,aAAA1G,KAAAmlB,OAAAgB,OAAA,cAEA,OAAAnmB,KAAAwlB,iBACAljB,EAAA6I,OAAA+a,aAAAlmB,KAAAwlB,gBACAxlB,KAAAwlB,eAAA,MAGAxlB,KAAAqlB,sBAAA,EAEArlB,KAAAslB,QAAA,EAEAtlB,KAAA2B,GAAAslB,qBAAAjnB,OAOA4mB,QAAA,SAAA9iB,GACA,GAAAojB,GAAAlnB,KAAAulB,SAEAvlB,MAAAulB,WAAA,EACAvlB,KAAAylB,mBAAA/B,KAAA5f,EAAA4f,KACA1jB,KAAAylB,mBAAAY,OAAAviB,EAAAuiB,OACArmB,KAAAmQ,OAAAzJ,IAAA,iCAAA5C,EAAA4f,MAAA5f,EAAAuiB,OAAA,aAAAviB,EAAAuiB,OAAA,IAAA,KAEAviB,EAAAqjB,YAAA,GACAnnB,KAAAmQ,OAAA7I,KAAA,kCAGA4f,KAAA,GACAlnB,KAAA2B,GAAAylB,kBAAApnB,MAEAA,KAAAslB,OAGAtlB,KAAA2B,GAAAkB,KAAA,gBACA6E,UAAA1H,KACA0jB,KAAA1jB,KAAAylB,mBAAA/B,KACA2C,OAAArmB,KAAAylB,mBAAAY,SALArmB,KAAAqnB,aAWArnB,KAAA2B,GAAA+B,iBAAA1D,OAQA8mB,UAAA,SAAAhjB,GACA,GAAA6f,GAAA2D,EACAhL,EAAAxY,EAAAwY,IAGA,IAAA,SAAAA,EAIA,YAHAtc,KAAA2B,GAAAqkB,cAAA3d,YAAA,GACArI,KAAAmQ,OAAAzJ,IAAA,4DAMA,IAAA,gBAAA4V,GAAA,CACA,IACAA,EAAA7D,OAAAC,aAAA5I,MAAA,KAAA,GAAAyX,YAAAjL,IACO,MAAAkL,GAEP,WADAxnB,MAAAmQ,OAAA7I,KAAA,2FAIAtH,KAAA2B,GAAAqkB,cAAA3d,YAAA,GACArI,KAAAmQ,OAAAzJ,IAAA,yCAAA4V,EAAA,UAMAtc,MAAA2B,GAAAqkB,cAAA3d,YAAA,GACArI,KAAAmQ,OAAAzJ,IAAA,uCAAA4V,EAAA,KAMA,IAFAqH,EAAArhB,EAAAmlB,OAAAC,aAAApL,EAAAtc,KAAA2B,IAEAgiB,KAIA3jB,KAAA2B,GAAAkiB,SAAAvhB,EAAAwQ,GAAAvQ,EAAAolB,oBAAAhE,YAAArhB,GAAAslB,kBAKAtlB,EAAAulB,YAAAlE,EAAA3jB,KAAA2B,GAAA3B,MACA,GAAA2jB,YAAArhB,GAAAslB,gBACAjE,EAAAjc,UAAA1H,KACAA,KAAA2B,GAAAmmB,eAAAnE,OACO,IAAAA,YAAArhB,GAAAylB,iBAKP,OAAApE,EAAAqE,QACA,IAAA1lB,GAAAC,EAAAgc,OACA+I,EAAAtnB,KAAA2B,GAAAsmB,aAAAC,IAAAvE,EAAAwE,YACAb,GACAA,EAAAc,gBAAAzE,EAEA,MACA,KAAArhB,GAAAC,EAAA4b,IAEA,KACA,SACAmJ,EAAAtnB,KAAA2B,GAAAsmB,aAAAI,KAAA1E,EAAAwE,YACAb,GACAA,EAAAc,gBAAAzE,KAYAqD,QAAA,SAAAljB,GACA9D,KAAAmQ,OAAA7I,KAAA,+BAAAxD,IAOAujB,UAAA,WACA,GAAA3f,GAAA1H,IAEAA,MAAAqlB,uBAAA,EAEArlB,KAAAqlB,sBAAArlB,KAAA2B,GAAAqkB,cAAAsC,yBACAtoB,KAAAmQ,OAAA7I,KAAA,+CAAAtH,KAAAmlB,OAAAgB,QACAnmB,KAAA2B,GAAA+B,iBAAA1D,QAEAA,KAAAmQ,OAAAzJ,IAAA,oCAAA1G,KAAAmlB,OAAAgB,OAAA,0BAAAnmB,KAAAqlB,sBAAA,KAEArlB,KAAAwlB,eAAAljB,EAAA6I,OAAAxH,WAAA,WACA+D,EAAAge,UACAhe,EAAA8d,eAAA,MACO,IAAAxlB,KAAA2B,GAAAqkB,cAAAuC,gCAKPxD,EAAAxiB,EAAAA,EACAD,EAAAyiB,UAAAA,IZw5DM,SAASllB,EAAQD,GarrEvBC,EAAAD,QAAA,SAAA0C,GAGA,QAAAkmB,GAAAlM,EAAAmM,GACA,GAEA7f,GAAA6f,EAEA5W,EAAA,EAEA6W,EAAA,CAGA,IAAApM,EAAA3H,UAAA/L,EAAAA,EAAA,GAAA+f,MAAA,WACA,MAAA,EAGA,MAAA,IAAA9W,GAAA,CAKA,GAHA6W,EAAApM,EAAA1K,QAAA,OAAAhJ,GAGA,KAAA8f,EACA,MAAAA,IAGApM,EAAA3H,UAAA+T,EAAA,EAAAA,EAAA,GAAAC,MAAA,YAAArM,EAAAlL,OAAAsX,EAAA,GAAAC,MAAA,UAEA/f,EAAA8f,EAAA,EAEA7W,EAAA6W,EAIA,MAAA7W,GAGA,QAAA+W,GAAAjF,EAAArH,EAAAmM,EAAAI,GACA,GAAAC,GAAAlZ,EAAAlG,EAAAqf,EACAC,EAAA1M,EAAA1K,QAAA,IAAA6W,GACAQ,EAAA3M,EAAA3H,UAAA8T,EAAAO,GAAAE,OACAC,EAAA7M,EAAA3H,UAAAqU,EAAA,EAAAH,GAAAK,MAGA,QAAAD,EAAAthB,eACA,IAAA,MACA,IAAA,IACAgc,EAAAyF,UAAA,MAAAD,GACA,IAAAxF,EAAA0F,WAAA,OAAA3f,QACAqf,EAAApF,EAAAiF,YAAA,OACAG,IACApF,EAAA2F,IAAAP,EACApF,EAAAwE,WAAAY,EAAAQ,SAGAR,EAAA,CAEA,MACA,KAAA,OACA,IAAA,IACApF,EAAA6F,UAAA,OAAAL,GACAJ,EAAApF,EAAAiF,YAAA,QACAG,IACApF,EAAA1O,KAAA8T,EACApF,EAAA8F,SAAAV,EAAAW,SAAA,OAEA,MACA,KAAA,KACA,IAAA,IACA/F,EAAA6F,UAAA,KAAAL,GACAJ,EAAApF,EAAAiF,YAAA,MACAG,IACApF,EAAAzO,GAAA6T,EACApF,EAAAgG,OAAAZ,EAAAW,SAAA,OAEA,MACA,KAAA,eAGA,GAFAX,EAAAzmB,EAAAsJ,QAAAyH,MAAA8V,EAAA,gBAEA,KAAAJ,EAAA,CACAA,EAAAhoB,MACA,OAIA,IADA2I,EAAAqf,EAAArf,OACAkG,EAAA,EAAmBlG,EAAAkG,EAAcA,IACjCkZ,EAAAC,EAAAnZ,GACA+T,EAAAyF,UAAA,eAAAD,EAAAxU,UAAAmU,EAAAc,SAAAd,EAAAe,SACAlG,EAAAzc,QAAA,gBAAAyc,EAAA0F,WAAA,gBAAA3f,OAAA,GAAAqf,OAAAD,EAAAC,MAEA,MACA,KAAA,UACA,IAAA,IACApF,EAAA6F,UAAA,UAAAL,GACAJ,EAAApF,EAAAiF,YAAA,WACAG,IACApF,EAAAmG,QAAAX,EAEA,MACA,KAAA,UACA,IAAA,IAGA,GAFAJ,EAAAzmB,EAAAsJ,QAAAyH,MAAA8V,EAAA,WAEA,KAAAJ,EAAA,CACAA,EAAAhoB,MACA,OAIA,IADA2I,EAAAqf,EAAArf,OACAkG,EAAA,EAAmBlG,EAAAkG,EAAcA,IACjCkZ,EAAAC,EAAAnZ,GACA+T,EAAAyF,UAAA,UAAAD,EAAAxU,UAAAmU,EAAAc,SAAAd,EAAAe,SACAlG,EAAAzc,QAAA,QAAAyc,EAAA0F,WAAA,WAAA3f,OAAA,GAAAqf,OAAAD,EAAAC,MAEA,MACA,KAAA,iBACA,IAAA,IACApF,EAAA6F,UAAA,iBAAAL,GACAJ,EAAApF,EAAAiF,YAAA,iBACA,MACA,KAAA,eACA,IAAA,IACAjF,EAAA6F,UAAA,eAAAL,GACAJ,EAAApF,EAAAiF,YAAA,eACA,MACA,KAAA,OACAjF,EAAA6F,UAAA,OAAAL,GACAJ,EAAApF,EAAAiF,YAAA,QACAG,IACApF,EAAAoG,KAAAhB,EAAA9iB,OAEA0d,YAAArhB,GAAAylB,mBACApE,EAAAqE,OAAAe,EAAAf,OAEA,MACA,KAAA,eACArE,EAAA6F,UAAA,eAAAL,GACAJ,EAAApF,EAAAiF,YAAA,eACA,MACA,KAAA,mBACAjF,EAAA6F,UAAA,mBAAAL,GACAJ,EAAApF,EAAAiF,YAAA,mBACA,MACA,KAAA,qBACAjF,EAAA6F,UAAA,qBAAAL,GACAJ,EAAApF,EAAAiF,YAAA,qBACA,MACA,KAAA,WACA,IAAA,IACAjF,EAAA6F,UAAA,WAAAL,GACAJ,EAAApF,EAAAiF,YAAA,YACAG,IACApF,EAAAqG,SAAAjB,EAEA,MACA,SAEApF,EAAA6F,UAAAP,EAAAE,GACAJ,EAAA,EAGA,MAAAhoB,UAAAgoB,GAEA1O,MAAA,yBAAA4O,EAAA,MAGA,EArKA,GAAAxB,EA+KAA,MACAA,EAAAC,aAAA,SAAApL,EAAA3a,GACA,GAAAgiB,GAAAsG,EAAAC,EAAAC,EAAApB,EACAN,EAAA,EACAI,EAAAvM,EAAA1K,QAAA,QACAzB,EAAAxO,EAAA+Y,UAAA,aAEA,IAAA,KAAAmO,EAEA,WADA1Y,GAAA7I,KAAA,8CAQA,IAHA2iB,EAAA3N,EAAA3H,UAAA,EAAAkU,GACAE,EAAAzmB,EAAAsJ,QAAAyH,MAAA4W,EAAA,oBAEA,KAAAlB,EAEA,WADA5Y,GAAA7I,KAAA,6CAAA2iB,EAAA,IAkBA,KAhBGlB,EAAAvlB,aAKHmgB,EAAA,GAAArhB,GAAAylB,iBAAApmB,GACAgiB,EAAAngB,YAAAulB,EAAAvlB,YACAmgB,EAAAyG,cAAArB,EAAAqB,gBANAzG,EAAA,GAAArhB,GAAAslB,gBAAAjmB;AACAgiB,EAAAqE,OAAAe,EAAAf,OACArE,EAAA0G,KAAAtB,EAAA9gB,KAOA0b,EAAArH,KAAAA,EACAmM,EAAAI,EAAA,IAKA,CAIA,GAHAA,EAAAL,EAAAlM,EAAAmM,GAGA,KAAAI,EAAA,CACAsB,EAAA1B,EAAA,CACA,OAGA,GAAA,KAAAI,EAEA,WADA1Y,GAAAkK,MAAA,oBAMA,IAFA0O,EAAAH,EAAAjF,EAAArH,EAAAmM,EAAAI,GAEAE,KAAA,EAEA,WADA5Y,GAAAkK,MAAA0O,EAAA1O,MAIAoO,GAAAI,EAAA,EAcA,MAPAlF,GAAA2G,UAAA,mBACAJ,EAAAvG,EAAA6E,UAAA,kBACA7E,EAAAhS,KAAA2K,EAAAjE,OAAA8R,EAAAD,IAEAvG,EAAAhS,KAAA2K,EAAA3H,UAAAwV,GAGAxG,GAGArhB,EAAAmlB,OAAAA,IbssEM,SAAS5nB,EAAQD,Gcp8EvBC,EAAAD,QAAA,SAAA0C,GACA,GACAioB,GACAC,EACA5C,EACAG,CAcAwC,GAAA,SAAAvC,EAAAqC,EAAA1oB,EAAA8oB,EAAApjB,EAAAsK,GACA,GACAuD,GACAD,EACA6U,EACAC,CAKA,OAHAU,GAAAA,MAGAzC,GAAAqC,GAAA1oB,GAIA3B,KAAAmQ,OAAAxO,EAAA+Y,UAAA,kBACA1a,KAAA2B,GAAAA,EACA3B,KAAAkH,WACAlH,KAAAgoB,OAAAA,EACAhoB,KAAAqqB,KAAAA,EACArqB,KAAA2R,KAAAA,EACA3R,KAAAqH,cAAAA,OAAAiK,QACAtR,KAAA0qB,WAAAD,EAAAjnB,YACAxD,KAAA2qB,aAAAF,EAAAL,cAKAK,EAAAG,UACA5qB,KAAAwpB,UAAA,QAAAiB,EAAAG,WACGjpB,EAAAqkB,cAAA6E,mBACH7qB,KAAAwpB,UAAA,QAAA7nB,EAAA+F,UAAAyd,OAAA2F,SAKA9qB,KAAAwpB,UAAA,MAAA,IAGAxpB,KAAAwpB,UAAA,eAAAlnB,EAAAwQ,GAAAvQ,EAAAwoB,cAGA7V,EAAAuV,EAAAO,gBAAA,IAAAP,EAAAO,eAAA,IAAAP,EAAAO,eAAA,KAAA,GACA9V,GAAA,KAAAuV,EAAAQ,QAAAZ,GAAA,IACAnV,GAAAuV,EAAAd,OAAA,QAA0Bc,EAAAd,OAAA,GAC1B3pB,KAAAkV,GAAA,GAAA5S,GAAA4oB,eAAA7X,MAAA6B,GACAlV,KAAAwpB,UAAA,KAAAtU,GAIAD,EADAwV,EAAAU,kBAAA,IAAAV,EAAAU,iBACA,IAAAV,EAAAU,iBAAA,KACGxpB,EAAAqkB,cAAAoF,YACH,IAAAzpB,EAAAqkB,cAAAoF,YAAA,KAEA,GAEAnW,GAAA,KAAAwV,EAAAY,UAAA1pB,EAAAqkB,cAAA/d,KAAA,SACAgN,GAAAwV,EAAAhB,UAAAnnB,EAAAmJ,MAAAoH,SACA7S,KAAAiV,KAAA,GAAA3S,GAAA4oB,eAAA7X,MAAA4B,GACAjV,KAAAwpB,UAAA,OAAAvU,GAGA6U,EAAAW,EAAAX,SAAAnoB,EAAAqkB,cAAAsF,QAAAhpB,EAAAmJ,MAAA6G,kBAAA,IACAtS,KAAA8pB,QAAAA,EACA9pB,KAAAwpB,UAAA,UAAAM,GAGAC,EAAAU,EAAAV,MAAApX,KAAAwC,MAAA,IAAAxC,KAAAC,UACA5S,KAAA+pB,KAAAA,MACA/pB,MAAAwpB,UAAA,OAAAO,EAAA,IAAA/B,IAzDA,MA4DAuC,EAAAxkB,WAMAyjB,UAAA,SAAA1e,EAAA7E,GACAjG,KAAAkH,QAAA5E,EAAAmJ,MAAAwI,UAAAnJ,IAAA7E,YAAA8B,OAAA9B,GAAAA,IAQAuiB,UAAA,SAAA1d,GACA,GAAAygB,GAAA3b,EACAlG,EAAA1J,KAAAqH,aAAAqC,OACAof,EAAA9oB,KAAAkH,QAAA5E,EAAAmJ,MAAAwI,UAAAnJ,GAEA,IAAAge,GACA,GAAAA,EAAA,GACA,MAAAA,GAAA,OAIA,KADAyC,EAAA,GAAAC,QAAA,QAAA1gB,EAAA,QAAA,KACA8E,EAAA,EAAmBlG,EAAAkG,EAAcA,IAEjC,GADAkZ,EAAA9oB,KAAAqH,aAAAuI,GACA2b,EAAAhoB,KAAAulB,GACA,MAAAA,GAAAnU,UAAAmU,EAAAlX,QAAA,KAAA,GAAAsX,QAaAG,WAAA,SAAAve,GACA,GAAA8E,GAAAlG,EAAA6hB,EACAzC,EAAA9oB,KAAAkH,QAAA5E,EAAAmJ,MAAAwI,UAAAnJ,IACA2gB,IAEA,IAAA3C,EAAA,CAEA,IADApf,EAAAof,EAAApf,OACAkG,EAAA,EAAmBlG,EAAAkG,EAAcA,IACjC6b,EAAArkB,KAAA0hB,EAAAlZ,GAEA,OAAA6b,GAIA,IAFA/hB,EAAA1J,KAAAqH,aAAAqC,OACA6hB,EAAA,GAAAC,QAAA,QAAA1gB,EAAA,QAAA,KACA8E,EAAA,EAAmBlG,EAAAkG,EAAcA,IACjCkZ,EAAA9oB,KAAAqH,aAAAuI,GACA2b,EAAAhoB,KAAAulB,IACA2C,EAAArkB,KAAA0hB,EAAAnU,UAAAmU,EAAAlX,QAAA,KAAA,GAAAsX,OAGA,OAAAuC,IASAnB,UAAA,SAAAxf,GACA,GAAAygB,GAAA3b,EACAlG,EAAA1J,KAAAqH,aAAAqC,MAEA,IAAA1J,KAAAkH,QAAA5E,EAAAmJ,MAAAwI,UAAAnJ,IACA,OAAA,CAGA,KADAygB,EAAA,GAAAC,QAAA,QAAA1gB,EAAA,QAAA,KACA8E,EAAA,EAAmBlG,EAAAkG,EAAcA,IACjC,GAAA2b,EAAAhoB,KAAAvD,KAAAqH,aAAAuI,IACA,OAAA,CAKA,QAAA,GAGAoC,SAAA,WACA,GAAA8W,GAAApf,EAAAkG,EAAAgW,EAAA,GAAA7H,IAEA6H,IAAA5lB,KAAAgoB,OAAA,IAAAhoB,KAAAqqB,KAAA,cAEA,KAAAvB,IAAA9oB,MAAAkH,QAEA,IADAwC,EAAA1J,KAAAkH,QAAA4hB,GAAApf,OACAkG,EAAA,EAAmBlG,EAAAkG,EAAcA,IACjCgW,GAAAkD,EAAA,KAAA9oB,KAAAkH,QAAA4hB,GAAAlZ,GAAA,MAKA,KADAlG,EAAA1J,KAAAqH,aAAAqC,OACAkG,EAAA,EAAiBlG,EAAAkG,EAAcA,IAC/BgW,GAAA5lB,KAAAqH,aAAAuI,GAAAsZ,OAAA,MA4BA,OAxBAlpB,MAAAgoB,SAAA1lB,EAAAC,EAAAoc,SACAZ,EAAA3W,KAAA,OAAA,QACKpH,KAAAgoB,SAAA1lB,EAAAC,EAAAgc,SACLve,KAAA2B,GAAAD,QAAAgqB,UAAA1rB,KAAA2B,GAAAD,QAAAiqB,YACA5N,EAAA3W,KAAA,QAGApH,KAAA2B,GAAAqkB,cAAA4F,SAAAtpB,EAAAC,EAAAwb,UAAAE,WACAF,EAAA3W,KAAA,UAGA2W,EAAA3W,KAAA,YAEAwe,GAAA,cAAA7H,EAAA,OACA6H,GAAA,eAAA5lB,KAAA2B,GAAAqkB,cAAA6F,gBAAA,OAEA7rB,KAAA2R,MACAjI,EAAApH,EAAAmJ,MAAAqF,gBAAA9Q,KAAA2R,MACAiU,GAAA,mBAAAlc,EAAA,WACAkc,GAAA5lB,KAAA2R,MAEAiU,GAAA,4BAGAA,IAQA4E,EAAA,WACAxqB,KAAAsc,KAAA,KACAtc,KAAAkH,QAAA,KACAlH,KAAAgoB,OAAA,KACAhoB,KAAAspB,IAAA,KACAtpB,KAAAmoB,WAAA,KACAnoB,KAAA8pB,QAAA,KACA9pB,KAAA+pB,KAAA,KACA/pB,KAAAiV,KAAA,KACAjV,KAAAypB,SAAA,KACAzpB,KAAAkV,GAAA,KACAlV,KAAA2pB,OAAA,KACA3pB,KAAA2R,KAAA,MAGA6Y,EAAAzkB,WAOAqjB,UAAA,SAAAte,EAAA7E,GACA,GAAA6iB,IAAkBtc,IAAAvG,EAElB6E,GAAAxI,EAAAmJ,MAAAwI,UAAAnJ,GAEA9K,KAAAkH,QAAA4D,GACA9K,KAAAkH,QAAA4D,GAAA1D,KAAA0hB,GAEA9oB,KAAAkH,QAAA4D,IAAAge,IASAN,UAAA,SAAA1d,GACA,GAAAge,GAAA9oB,KAAAkH,QAAA5E,EAAAmJ,MAAAwI,UAAAnJ,GAEA,IAAAge,EACA,MAAAA,GAAA,GACAA,EAAA,GAAAtc,IADA,QAaA6c,WAAA,SAAAve,GACA,GAAA8E,GAAAlG,EACAof,EAAA9oB,KAAAkH,QAAA5E,EAAAmJ,MAAAwI,UAAAnJ,IACA2gB,IAEA,KAAA3C,EACA,QAIA,KADApf,EAAAof,EAAApf,OACAkG,EAAA,EAAiBlG,EAAAkG,EAAcA,IAC/B6b,EAAArkB,KAAA0hB,EAAAlZ,GAAApD,IAGA,OAAAif,IAQAnB,UAAA,SAAAxf,GACA,QAAA9K,KAAAkH,QAAA5E,EAAAmJ,MAAAwI,UAAAnJ,KASA8d,YAAA,SAAA9d,EAAA8E,GACA,GAAAkZ,GAAA7iB,EAAA8iB,CAMA,OAJAje,GAAAxI,EAAAmJ,MAAAwI,UAAAnJ,GAEA8E,EAAAA,GAAA,EAEA5P,KAAAkH,QAAA4D,GAGK8E,GAAA5P,KAAAkH,QAAA4D,GAAApB,WACL1J,MAAAmQ,OAAAzJ,IAAA,gBAAAoE,EAAA,sBAIAge,EAAA9oB,KAAAkH,QAAA4D,GAAA8E,GACA3J,EAAA6iB,EAAAtc,IAEAsc,EAAAC,OACAD,EAAAC,QAIAA,EAAAzmB,EAAAsJ,QAAAyH,MAAApN,EAAA6E,EAAAmG,QAAA,KAAA,MAEA,KAAA8X,GACA/oB,KAAAkH,QAAA4D,GAAAkR,OAAApM,EAAA,OACA5P,MAAAmQ,OAAA7I,KAAA,kBAAAwD,EAAA,8BAAA7E,EAAA,OAGA6iB,EAAAC,OAAAA,EACAA,SAvBA/oB,MAAAmQ,OAAAzJ,IAAA,WAAAoE,EAAA,kBAoCAmM,EAAA,SAAAnM,EAAA8E,GACA,MAAA5P,MAAA4oB,YAAA9d,EAAA8E,IAQA4Z,UAAA,SAAA1e,EAAA7E,GACA,GAAA6iB,IAAkBtc,IAAAvG,EAClBjG,MAAAkH,QAAA5E,EAAAmJ,MAAAwI,UAAAnJ,KAAAge,IAGA9W,SAAA,WACA,MAAAhS,MAAAsc,OAQAsL,EAAA,SAAAjmB,GACA3B,KAAAmQ,OAAAxO,EAAA+Y,UAAA,kBACA1a,KAAA2B,GAAAA,EACA3B,KAAAkH,WACAlH,KAAAqqB,KAAA,KACArqB,KAAA0H,UAAA,KACA1H,KAAA8rB,mBAAA,MAEAlE,EAAA7hB,UAAA,GAAAykB,GAWA5C,EAAA7hB,UAAAgmB,MAAA,SAAArI,EAAA2C,EAAAhf,EAAAsK,EAAAqa,EAAAC,GACA,GAAAC,GAAAC,EAAAziB,EAAAkG,EAAAvM,EACA0a,KACA7I,EAAAlV,KAAAwoB,UAAA,MACA/V,EAAA,EACAS,EAAA,CAMA,IAJAwQ,EAAAA,GAAA,KACA2C,EAAAA,GAAA,MAGA3C,GAAA,IAAAA,GAAAA,EAAA,IACA,KAAA,IAAAhI,WAAA,wBAAAgI,EACG,IAAA2C,GAAA,gBAAAA,MAAAA,YAAA5N,SACH,KAAA,IAAAiD,WAAA,0BAAA2K,EAQA,IALAA,EAAAA,GAAA/jB,EAAAC,EAAAE,cAAAihB,IAAA,GACArc,GAAAA,OAAAiK,QAEAjO,EAAA,WAAAqgB,EAAA,IAAA2C,EAAA,OAEArmB,KAAAgoB,SAAA1lB,EAAAC,EAAAgc,QAAAmF,EAAA,KAAA,KAAAA,EAIA,IAHAwI,EAAAlsB,KAAAqpB,WAAA,gBACA3f,EAAAwiB,EAAAxiB,OAEA+I,EAAU/I,EAAA+I,EAAYA,IACtBpP,GAAA,iBAAA6oB,EAAAzZ,GAAA,MAOA,KAHA0Z,EAAAnsB,KAAAqpB,WAAA,OACA3f,EAAAyiB,EAAAziB,OAEAwJ,EAAQxJ,EAAAwJ,EAAYA,IACpB7P,GAAA,QAAA8oB,EAAAjZ,GAAA,MAeA,MAZAlT,KAAA2pB,QAAAjG,EAAA,IACAxO,GAAA,QAAY5S,EAAAmJ,MAAAoH,SACT7S,KAAA2pB,SAAA3pB,KAAAiX,EAAA,MAAAmV,SAAA,SACHlX,GAAA,QAAYlV,KAAA2pB,QAGZtmB,GAAA,OAAA6R,EAAA,OACA7R,GAAA,SAAArD,KAAAwoB,UAAA,QAAA,OACAnlB,GAAA,YAAArD,KAAA8pB,QAAA,OACAzmB,GAAA,SAAArD,KAAA+pB,KAAA,IAAA/pB,KAAAgoB,OAAA,OAEAte,EAAArC,EAAAqC,OACAkG,EAAA,EAAelG,EAAAkG,EAAcA,IAC7BvM,GAAAgE,EAAAuI,GAAAsZ,OAAA,MA4BA,OAxBAlpB,MAAAgoB,SAAA1lB,EAAAC,EAAAgc,SACAve,KAAA2B,GAAAD,QAAAgqB,UAAA1rB,KAAA2B,GAAAD,QAAAiqB,YACA5N,EAAA3W,KAAA,QAGApH,KAAA2B,GAAAqkB,cAAA4F,SAAAtpB,EAAAC,EAAAwb,UAAAE,WACAF,EAAA3W,KAAA,UAGA2W,EAAA3W,KAAA,YAEA/D,GAAA,cAAA0a,EAAA,OAEApM,GACAjI,EAAApH,EAAAmJ,MAAAqF,gBAAAa,GACAtO,GAAA,oCACAA,GAAA,mBAAAqG,EAAA,WACArG,GAAAsO,GAEAtO,GAAA,4BAGArD,KAAA8rB,mBAAA1D,gBAAA1E,EAAArgB,EAAA2oB,EAAAC,GAEA5oB,GAQAukB,EAAA7hB,UAAAsmB,SAAA,SAAA3I,EAAA2C,GACA,GAAAnR,GAAA7R,EACA6P,EAAA,EACAiZ,EAAAnsB,KAAAqpB,WAAA,OACA3f,EAAAyiB,EAAAziB,MAMA,IAJAga,EAAAA,GAAA,KACA2C,EAAAA,GAAA,MAGA3C,GAAA,IAAAA,GAAAA,EAAA,IACA,KAAA,IAAAhI,WAAA,wBAAAgI,EACG,IAAA2C,GAAA,gBAAAA,MAAAA,YAAA5N,SACH,KAAA,IAAAiD,WAAA,0BAAA2K,EAOA,KAJAA,EAAAA,GAAA/jB,EAAAC,EAAAE,cAAAihB,IAAA,GAEArgB,EAAA,WAAAqgB,EAAA,IAAA2C,EAAA,OAEAnT,EAAQxJ,EAAAwJ,EAAYA,IACpB7P,GAAA,QAAA8oB,EAAAjZ,GAAA,MAGAgC,GAAAlV,KAAAwoB,UAAA,OAEAxoB,KAAA2pB,QAAAjG,EAAA,IACAxO,GAAA,QAAY5S,EAAAmJ,MAAAoH,SACT7S,KAAA2pB,SAAA3pB,KAAAiX,EAAA,MAAAmV,SAAA,SACHlX,GAAA,QAAYlV,KAAA2pB,QAGZtmB,GAAA,OAAA6R,EAAA,OACA7R,GAAA,SAAArD,KAAAwoB,UAAA,QAAA,OACAnlB,GAAA,YAAArD,KAAA8pB,QAAA,OACAzmB,GAAA,SAAArD,KAAA+pB,KAAA,IAAA/pB,KAAAgoB,OAAA,OACA3kB,GAAA,4BAEArD,KAAA0H,UAAAie,KAAAtiB,IAQA0kB,EAAA,SAAApmB,GACA3B,KAAAmQ,OAAAxO,EAAA+Y,UAAA,kBACA1a,KAAAkH,WACAlH,KAAAwD,YAAA,KACAxD,KAAAoqB,cAAA,MAEArC,EAAAhiB,UAAA,GAAAykB,GAEAloB,EAAAioB,gBAAAA,EACAjoB,EAAAslB,gBAAAA,EACAtlB,EAAAylB,iBAAAA,Idg9EM,SAASloB,EAAQD,Get+FvBC,EAAAD,QAAA,SAAA0C,GACA,GAAAqR,EAEAA,GAAA,SAAA2Y,EAAAvY,EAAAX,EAAAmZ,EAAAC,EAAAtlB,GACA,GAAAulB,GAAA3D,CAGA,KAAA1V,EACA,KAAA,IAAAsI,WAAA,sCAIA4Q,GAAAA,GAAAhqB,EAAAC,EAAAD,IACAtC,KAAAwsB,cACAxsB,KAAAkH,UAEA,KAAAulB,IAAAD,GACAxsB,KAAA0sB,SAAAD,EAAAD,EAAAC,GAGA,KAAA3D,IAAA5hB,GACAlH,KAAAwpB,UAAAV,EAAA5hB,EAAA4hB,GAGAnjB,QAAAiF,iBAAA5K,MACAssB,QACAzhB,IAAA,WAAsB,MAAAyhB,IACtB3R,IAAA,SAAA1U,GACAqmB,EAAArmB,EAAA0B,gBAIAoM,MACAlJ,IAAA,WAAsB,MAAAkJ,IACtB4G,IAAA,SAAA1U,GACA8N,EAAA9N,IAIAmN,MACAvI,IAAA,WAAsB,MAAAuI,IACtBuH,IAAA,SAAA1U,GACAmN,EAAAnN,EAAA0B,gBAIA4kB,MACA1hB,IAAA,WAAsB,MAAA0hB,IACtB5R,IAAA,SAAA1U,GACAsmB,EAAA,IAAAtmB,EAAAA,EAAAoM,SAAApM,EAAA,KAAA,UAKA0N,EAAA5N,WACA2mB,SAAA,SAAAC,EAAA1mB,GACA0mB,IACA3sB,KAAAwsB,WAAAG,EAAAhlB,eAAA,mBAAA1B,IAAA,OAAAA,EAAA,KAAAA,EAAA+L,WAAArK,gBAIA+hB,SAAA,SAAAiD,GACA,MAAAA,GACA3sB,KAAAwsB,WAAAG,EAAAhlB,eADA,QAKAykB,SAAA,SAAAO,GACA,MAAAA,GACA3sB,KAAAwsB,WAAA1R,eAAA6R,EAAAhlB,iBAAA,IAAA,EADA,QAKAilB,YAAA,SAAAnJ,GACA,GAAAxd,EAEA,OADAwd,GAAAA,EAAA9b,cACA3H,KAAAwsB,WAAA1R,eAAA2I,IACAxd,EAAAjG,KAAAwsB,WAAA/I,SACAzjB,MAAAwsB,WAAA/I,GACAxd,GAHA,QAOA4mB,YAAA,WACA7sB,KAAAwsB,eAGAhD,UAAA,SAAA1e,EAAA7E,GACAjG,KAAAkH,QAAA5E,EAAAmJ,MAAAwI,UAAAnJ,IAAA7E,YAAA8B,OAAA9B,GAAAA,IAGAuiB,UAAA,SAAA1d,GACA,MAAAA,GACA9K,KAAAkH,QAAA5E,EAAAmJ,MAAAwI,UAAAnJ,IADA,QAKAwf,UAAA,SAAAxf,GACA,MAAAA,GACA9K,KAAAkH,QAAA4T,eAAAxY,EAAAmJ,MAAAwI,UAAAnJ,MAAA,IAAA,EADA,QAKAgiB,aAAA,SAAAhE,GACA,GAAA7iB,EAEA,OADA6iB,GAAAxmB,EAAAmJ,MAAAwI,UAAA6U,GACA9oB,KAAAkH,QAAA4T,eAAAgO,IACA7iB,EAAAjG,KAAAkH,QAAA4hB,SACA9oB,MAAAkH,QAAA4hB,GACA7iB,GAHA,QAOA8mB,aAAA,WACA/sB,KAAAkH,YAGA8lB,MAAA,WACA,MAAA,IAAArZ,GACA3T,KAAAssB,OACAtsB,KAAA+T,KACA/T,KAAAoT,KACApT,KAAAusB,KACA3R,KAAAvH,MAAAuH,KAAAC,UAAA7a,KAAAwsB,aACA5R,KAAAvH,MAAAuH,KAAAC,UAAA7a,KAAAkH,YAGA8K,SAAA,WACA,GAAA8W,GAAArF,EAAA7T,EAAA3H,EACAf,IAEAe,GAAAjI,KAAAssB,OAAA,IAEAtsB,KAAAssB,OAAA3D,MAAA,aACA1gB,GAAA,MAEAjI,KAAA+T,OACA9L,GAAA3F,EAAAmJ,MAAAqI,WAAA9T,KAAA+T,MAAA,KAEA9L,GAAAjI,KAAAoT,MACApT,KAAAusB,MAAA,IAAAvsB,KAAAusB,QACAtkB,GAAA,IAAAjI,KAAAusB,KAGA,KAAA9I,IAAAzjB,MAAAwsB,WACAvkB,GAAA,IAAewb,EAEf,OAAAzjB,KAAAwsB,WAAA/I,KACAxb,GAAA,IAAAjI,KAAAwsB,WAAA/I,GAIA,KAAAqF,IAAA9oB,MAAAkH,QACA,IAAA0I,IAAA5P,MAAAkH,QAAA4hB,GACA5hB,EAAAE,KAAA0hB,EAAA,IAAA9oB,KAAAkH,QAAA4hB,GAAAlZ,GAQA,OAJA1I,GAAAwC,OAAA,IACAzB,GAAA,IAAAf,EAAA2M,KAAA,MAGA5L,IAWA0L,EAAAN,MAAA,SAAApL,GAGA,MAFAA,GAAA3F,EAAAsJ,QAAAyH,MAAApL,EAAA,WAEA,KAAAA,EACAA,EAEA,QAIA3F,EAAAqR,IAAAA,If8/FM,SAAS9T,EAAQD,GgBxrGvBC,EAAAD,QAAA,SAAA0C,GACA,GAAA4oB,EAEAA,GAAA,SAAAjjB,EAAAmjB,EAAAoB,GACA,GAAAC,EAGA,MAAAxkB,GAAAA,YAAA3F,GAAAqR,KACA,KAAA,IAAA+H,WAAA,qCAIA1b,MAAAiI,IAAAA,EACAjI,KAAAwsB,aAEA,KAAAC,IAAAD,GACAxsB,KAAA0sB,SAAAD,EAAAD,EAAAC,GAGA9mB,QAAAiF,iBAAA5K,MACAorB,aACAvgB,IAAA,WAAuB,MAAAugB,IACvBzQ,IAAA,SAAA1U,GACAmlB,EAAA,IAAAnlB,EAAA,IAAAA,OAKAilB,EAAAnlB,WACA2mB,SAAA,SAAAC,EAAA1mB,GACA0mB,IACA3sB,KAAAwsB,WAAAG,EAAAhlB,eAAA,mBAAA1B,IAAA,OAAAA,EAAA,KAAAA,EAAA+L,aAGA0X,SAAApnB,EAAAqR,IAAA5N,UAAA2jB,SACA0C,SAAA9pB,EAAAqR,IAAA5N,UAAAqmB,SACAQ,YAAAtqB,EAAAqR,IAAA5N,UAAA6mB,YACAC,YAAAvqB,EAAAqR,IAAA5N,UAAA8mB,YAEAG,MAAA,WACA,MAAA,IAAA9B,GACAlrB,KAAAiI,IAAA+kB,QACAhtB,KAAAorB,YACAxQ,KAAAvH,MAAAuH,KAAAC,UAAA7a,KAAAwsB,eAGAxa,SAAA,WACA,GAAAL,GAAA8R,CAEA9R,GAAA3R,KAAAorB,aAAA,IAAAprB,KAAAorB,YAAA,IAAAprB,KAAAorB,YAAA,KAAA,GACAzZ,GAAA,IAAA3R,KAAAiI,IAAA+J,WAAA,GAEA,KAAAyR,IAAAzjB,MAAAwsB,WACA7a,GAAA,IAAgB8R,EAEhB,OAAAzjB,KAAAwsB,WAAA/I,KACA9R,GAAA,IAAA3R,KAAAwsB,WAAA/I,GAIA,OAAA9R,KAWAuZ,EAAA7X,MAAA,SAAA4Z,GAGA,MAFAA,GAAA3qB,EAAAsJ,QAAAyH,MAAA4Z,EAAA,oBAEA,KAAAA,EACAA,EAEA,QAIA3qB,EAAA4oB,eAAAA,IhB6sGM,SAASrrB,EAAQD,GiBnyGvBC,EAAAD,QAAA,SAAA0C,GACA,GACAC,IAEA2qB,cAAA,EACAC,kBAAA,EACAC,eAAA,EACAC,gBAAA,EACAC,iBAAA,EACAC,kBAAA,EACAC,iBAAA,EAGAC,kBAAA,OACAC,kBAAA,OACAC,cAAA,MACAC,cAAA,OAUAC,EAAA,SAAAC,EAAAC,EAAArmB,GACA,GAAA4hB,GACAnnB,GAAA,eAEAnC,MAAA4M,KAAArK,EAAAkrB,kBACAztB,KAAA0H,UAAAA,EACA1H,KAAAK,GAAA,UAAAsS,KAAAwC,MAAA,IAAAxC,KAAAC,UACA5S,KAAA8tB,eAAAA,EACA9tB,KAAA+tB,QAAAA,EAEA/tB,KAAAmQ,OAAA2d,EAAAnsB,GAAA+Y,UAAA,uBAAA1a,KAAAK,IAEAipB,EAAA,YAAAwE,EAAAnsB,GAAAqkB,cAAAgI,WAAA,MAAAtmB,EAAAyd,OAAAmH,QACAhD,GAAA,IAAAwE,EAAAnsB,GAAAqkB,cAAAiI,QAAA,WAA2DjuB,KAAAK,GAE3DL,KAAA+tB,QAAAvE,UAAA,MAAAF,GAEAtpB,KAAA8tB,eAAAnsB,GAAAusB,eAAAluB,MAEAA,KAAAob,WAAAjZ,GAEA0rB,GAAA9nB,UAAA,GAAAzD,GAAA+C,aAEAwoB,EAAA9nB,UAAAooB,aAAA,SAAAC,GACApuB,KAAAouB,MAAAA,EACApuB,KAAA6C,KAAA,iBAGAgrB,EAAA9nB,UAAA4f,KAAA,WACA,GAAA0I,GAAAruB,IAEAA,MAAAmuB,aAAA5rB,EAAA2qB,eACAltB,KAAAsW,EAAAhU,EAAA6I,OAAAxH,WAAA0qB,EAAAC,QAAAxsB,KAAAusB,GAAA/rB,EAAA6I,OAAAmZ,SAEAtkB,KAAA0H,UAAAie,KAAA3lB,KAAA+tB,UACA/tB,KAAA0D,oBAIAmqB,EAAA9nB,UAAArC,iBAAA,WACA1D,KAAAmQ,OAAAzJ,IAAA,oEAAA1G,KAAAK,IACAiC,EAAA6I,OAAA+a,aAAAlmB,KAAAsW,GACAhU,EAAA6I,OAAA+a,aAAAlmB,KAAAuuB,GACAvuB,KAAAmuB,aAAA5rB,EAAAgrB,mBACAvtB,KAAA8tB,eAAAnsB,GAAA6sB,mBAAAxuB,MACAA,KAAA8tB,eAAApqB,oBAGAmqB,EAAA9nB,UAAAuoB,QAAA,WACAtuB,KAAAmQ,OAAAzJ,IAAA,qDAAA1G,KAAAK,IACAL,KAAAmuB,aAAA5rB,EAAAgrB,mBACAvtB,KAAA8tB,eAAAnsB,GAAA6sB,mBAAAxuB,MACAA,KAAA8tB,eAAAW,oBAGAZ,EAAA9nB,UAAA2oB,QAAA,WACA1uB,KAAAmuB,aAAA5rB,EAAAgrB,mBACAvtB,KAAA8tB,eAAAnsB,GAAA6sB,mBAAAxuB,OAGA6tB,EAAA9nB,UAAAqiB,gBAAA,SAAA/kB,GACA,GACAgrB,GAAAruB,KACAwD,EAAAH,EAAAG,WAEA,IAAA,IAAAA,EACA,OAAAxD,KAAAouB,OACA,IAAA7rB,GAAA2qB,cACA,IAAA3qB,GAAA4qB,kBACAntB,KAAAmuB,aAAA5rB,EAAA4qB,mBACAntB,KAAA8tB,eAAA1F,gBAAA/kB,OAIA,QAAArD,KAAAouB,OACA,IAAA7rB,GAAA2qB,cACA,IAAA3qB,GAAA4qB,kBACAntB,KAAAmuB,aAAA5rB,EAAA+qB,kBACAhrB,EAAA6I,OAAA+a,aAAAlmB,KAAAsW,GAEA,MAAA9S,EACAxD,KAAA8tB,eAAAW,mBAEAzuB,KAAA8tB,eAAA1F,gBAAA/kB,GAGArD,KAAAuuB,EAAAjsB,EAAA6I,OAAAxH,WAAA0qB,EAAAK,QAAA5sB,KAAAusB,GAAA/rB,EAAA6I,OAAAuZ,QACA,MACA,KAAAniB,GAAA+qB,mBAeA,IAAAqB,GAAA,SAAAb,EAAAC,EAAArmB,GACA,GAAA4hB,GACA+E,EAAAruB,KACAmC,GAAA,eAEAnC,MAAA4M,KAAArK,EAAAorB,cACA3tB,KAAA0H,UAAAA,EACA1H,KAAAK,GAAA,UAAAsS,KAAAwC,MAAA,IAAAxC,KAAAC,UACA5S,KAAA8tB,eAAAA,EACA9tB,KAAA+tB,QAAAA,EAEA/tB,KAAAmQ,OAAA2d,EAAAnsB,GAAA+Y,UAAA,sBAAA1a,KAAAK,IAEAipB,EAAA,YAAAwE,EAAAnsB,GAAAqkB,cAAAgI,WAAA,MAAAtmB,EAAAyd,OAAAmH,QACAhD,GAAA,IAAAwE,EAAAnsB,GAAAqkB,cAAAiI,QAAA,WAA2DjuB,KAAAK,GAE3DL,KAAA+tB,QAAAvE,UAAA,MAAAF,GAEAtpB,KAAA8tB,eAAAnsB,GAAAusB,eAAAluB,MAIAA,KAAA+tB,QAAAa,OAAA,SAAAvI,GACAgI,EAAAQ,eAAAR,EAAAhI,IAGArmB,KAAAob,WAAAjZ,GAEAwsB,GAAA5oB,UAAA,GAAAzD,GAAA+C,aAEAspB,EAAA5oB,UAAAooB,aAAA,SAAAC,GACApuB,KAAAouB,MAAAA,EACApuB,KAAA6C,KAAA,iBAGA8rB,EAAA5oB,UAAA4f,KAAA,WACA,GAAA0I,GAAAruB,IACAA,MAAAmuB,aAAA5rB,EAAA6qB,gBACAptB,KAAA8uB,EAAAxsB,EAAA6I,OAAAxH,WAAA0qB,EAAAU,QAAAjtB,KAAAusB,GAAA/rB,EAAA6I,OAAAiZ,SAEApkB,KAAA0H,UAAAie,KAAA3lB,KAAA+tB,UACA/tB,KAAA0D,oBAIAirB,EAAA5oB,UAAArC,iBAAA,WACA1D,KAAAmQ,OAAAzJ,IAAA,gEAAA1G,KAAAK,IACAiC,EAAA6I,OAAA+a,aAAAlmB,KAAA8uB,GACAxsB,EAAA6I,OAAA+a,aAAAlmB,KAAAgvB,GACA1sB,EAAA6I,OAAA+a,aAAAlmB,KAAAivB,GACAjvB,KAAAmuB,aAAA5rB,EAAAgrB,mBACAvtB,KAAA8tB,eAAAnsB,GAAA6sB,mBAAAxuB,MAEAA,KAAAouB,QAAA7rB,EAAA8qB,iBACArtB,KAAA8tB,eAAApqB,oBAKAirB,EAAA5oB,UAAAmpB,QAAA,WACAlvB,KAAAmQ,OAAAzJ,IAAA,iDAAA1G,KAAAK,IAEAL,KAAAouB,QAAA7rB,EAAA8qB,kBACA/qB,EAAA6I,OAAA+a,aAAAlmB,KAAA8uB,GACA9uB,KAAAmuB,aAAA5rB,EAAAgrB,mBACAvtB,KAAA8tB,eAAAnsB,GAAA6sB,mBAAAxuB,QAKA2uB,EAAA5oB,UAAAgpB,QAAA,WACA/uB,KAAAmQ,OAAAzJ,IAAA,iDAAA1G,KAAAK,IACAL,KAAAouB,QAAA7rB,EAAA6qB,iBACAptB,KAAAmuB,aAAA5rB,EAAAgrB,mBACAvtB,KAAA8tB,eAAAnsB,GAAA6sB,mBAAAxuB,MACAA,KAAA8tB,eAAAW,qBAIAE,EAAA5oB,UAAAopB,QAAA,WACAnvB,KAAAmQ,OAAAzJ,IAAA,iDAAA1G,KAAAK,IACAiC,EAAA6I,OAAA+a,aAAAlmB,KAAA8uB,GACA9uB,KAAAmuB,aAAA5rB,EAAAgrB,mBACAvtB,KAAA8tB,eAAAnsB,GAAA6sB,mBAAAxuB,OAGA2uB,EAAA5oB,UAAAqpB,QAAA,SAAA/rB,GACA,GAAAgrB,GAAAruB,IAEAA,MAAAqvB,IAAA,OAAArvB,KAAA+tB,QAAA1D,KAAA,eACArqB,KAAAqvB,KAAA,QAAArvB,KAAA+tB,QAAA7mB,QAAA,IAAA8K,WAAA,OAEAhS,KAAA+tB,QAAA7mB,QAAA,QACAlH,KAAAqvB,KAAA,UAAArvB,KAAA+tB,QAAA7mB,QAAA,MAAA8K,WAAA,QAGAhS,KAAAqvB,KAAA,OAAAhsB,EAAAmlB,UAAA,MAAA,OACAxoB,KAAAqvB,KAAA,SAAArvB,KAAA+tB,QAAA7mB,QAAA,KAAA8K,WAAA,OACAhS,KAAAqvB,KAAA,YAAArvB,KAAA+tB,QAAA7mB,QAAA,WAAA8K,WAAA,OACAhS,KAAAqvB,KAAA,SAAArvB,KAAA+tB,QAAA7mB,QAAA,KAAA8K,WAAA4B,MAAA,KAAA,GACA5T,KAAAqvB,KAAA,eAEArvB,KAAAgvB,EAAA1sB,EAAA6I,OAAAxH,WAAA0qB,EAAAc,QAAArtB,KAAAusB,GAAA/rB,EAAA6I,OAAAkZ,SAEArkB,KAAA0H,UAAAie,KAAA3lB,KAAAqvB,MAGAV,EAAA5oB,UAAA8oB,eAAA,SAAAR,EAAAhI,GACA,GAAA0H,GAAAM,EAAAN,OAEA/tB,MAAA4uB,OAAAtsB,EAAAC,EAAA8b,OAAA,IAAA0P,EAAA1D,KAAA,eACArqB,KAAA4uB,QAAA,QAAAb,EAAA7mB,QAAA,IAAA8K,WAAA,OAEAhS,KAAA+tB,QAAA7mB,QAAA,QACAlH,KAAA4uB,QAAA,UAAAb,EAAA7mB,QAAA,MAAA8K,WAAA,QAGAhS,KAAA4uB,QAAA,OAAAb,EAAA7mB,QAAA,GAAA8K,WAAA,OACAhS,KAAA4uB,QAAA,SAAAb,EAAA7mB,QAAA,KAAA8K,WAAA,OACAhS,KAAA4uB,QAAA,YAAAb,EAAA7mB,QAAA,WAAA8K,WAAA,OACAhS,KAAA4uB,QAAA,SAAAb,EAAA7mB,QAAA,KAAA8K,WAAA4B,MAAA,KAAA,GACA,cAEAyS,IACArmB,KAAA4uB,QAAA,WAAAvI,EAAA,QAGArmB,KAAA4uB,QAAA,4BAGA5uB,KAAAouB,QAAA7rB,EAAA4qB,mBACAntB,KAAA0H,UAAAie,KAAA3lB,KAAA4uB,SAIAD,EAAA5oB,UAAAqiB,gBAAA,SAAA/kB,GACA,GACAgrB,GAAAruB,KACAwD,EAAAH,EAAAG,WAEA,IAAAA,GAAA,KAAA,KAAAA,EACA,OAAAxD,KAAAouB,OACA,IAAA7rB,GAAA6qB,eACAptB,KAAAmuB,aAAA5rB,EAAA4qB,mBACAntB,KAAA8tB,eAAA1F,gBAAA/kB,GACArD,KAAA4uB,QACA5uB,KAAA0H,UAAAie,KAAA3lB,KAAA4uB,OAEA,MACA,KAAArsB,GAAA4qB,kBACAntB,KAAA8tB,eAAA1F,gBAAA/kB,OAGG,IAAAG,GAAA,KAAA,KAAAA,EACH,OAAAxD,KAAAouB,OACA,IAAA7rB,GAAA6qB,eACA,IAAA7qB,GAAA4qB,kBACAntB,KAAAmuB,aAAA5rB,EAAA8qB,iBACArtB,KAAAivB,EAAA3sB,EAAA6I,OAAAxH,WAAA0qB,EAAAa,QAAAptB,KAAAusB,GAAA/rB,EAAA6I,OAAAyZ,SACA5kB,KAAA8tB,eAAA1F,gBAAA/kB,EACA,MACA,KAAAd,GAAA8qB,gBACArtB,KAAA8tB,eAAA1F,gBAAA/kB,OAGG,IAAAG,GAAA,KAAA,KAAAA,EACH,OAAAxD,KAAAouB,OACA,IAAA7rB,GAAA6qB,eACA,IAAA7qB,GAAA4qB,kBACAntB,KAAAmuB,aAAA5rB,EAAA+qB,kBACAttB,KAAAovB,QAAA/rB,GACArD,KAAA8tB,eAAA1F,gBAAA/kB,EACA,MACA,KAAAd,GAAA+qB,iBACAttB,KAAAovB,QAAA/rB,IAcA,IAAAisB,GAAA,SAAAxB,EAAAC,EAAArmB,GACA,GAAA4hB,EAEAtpB,MAAA0H,UAAAA,EACA1H,KAAAK,GAAA,UAAAsS,KAAAwC,MAAA,IAAAxC,KAAAC,UACA5S,KAAA8tB,eAAAA,EACA9tB,KAAA+tB,QAAAA,EAEA/tB,KAAAmQ,OAAA2d,EAAAnsB,GAAA+Y,UAAA,uBAAA1a,KAAAK,IAEAipB,EAAA,YAAAwE,EAAAnsB,GAAAqkB,cAAAgI,WAAA,MAAAtmB,EAAAyd,OAAAmH,QACAhD,GAAA,IAAAwE,EAAAnsB,GAAAqkB,cAAAiI,QAAA,WAA2DjuB,KAAAK,GAE3DL,KAAA+tB,QAAAvE,UAAA,MAAAF,GAEAgG,GAAAvpB,UAAA,GAAAzD,GAAA+C,aAEAiqB,EAAAvpB,UAAA4f,KAAA,WACA3lB,KAAA0H,UAAAie,KAAA3lB,KAAA+tB,UACA/tB,KAAA0D,oBAIA4rB,EAAAvpB,UAAArC,iBAAA,WACA1D,KAAAmQ,OAAAzJ,IAAA,2DAAA1G,KAAAK,IACAL,KAAA8tB,eAAApqB,mBAUA,IAAA6rB,GAAA,SAAAxB,EAAApsB,GACA,GAAAQ,IAAA,eAEAnC,MAAA4M,KAAArK,EAAAmrB,kBACA1tB,KAAAK,GAAA0tB,EAAA5F,WACAnoB,KAAA+tB,QAAAA,EACA/tB,KAAA0H,UAAAqmB,EAAArmB,UACA1H,KAAA2B,GAAAA,EACA3B,KAAAwvB,cAAA,GACAzB,EAAAjC,mBAAA9rB,KAEAA,KAAAmQ,OAAAxO,EAAA+Y,UAAA,uBAAA1a,KAAAK,IAEAL,KAAAouB,MAAA7rB,EAAA2qB,cAEAvrB,EAAAusB,eAAAluB,MAEAA,KAAAob,WAAAjZ,GAEAotB,GAAAxpB,UAAA,GAAAzD,GAAA+C,aAEAkqB,EAAAxpB,UAAAooB,aAAA,SAAAC,GACApuB,KAAAouB,MAAAA,EACApuB,KAAA6C,KAAA,iBAGA0sB,EAAAxpB,UAAA0pB,QAAA,WACAzvB,KAAAmQ,OAAAzJ,IAAA,qDAAA1G,KAAAK,IACAL,KAAAmuB,aAAA5rB,EAAAgrB,mBACAvtB,KAAA2B,GAAA6sB,mBAAAxuB,OAGAuvB,EAAAxpB,UAAArC,iBAAA,WACA1D,KAAA0vB,iBACA1vB,KAAA0vB,gBAAA,EAEA1vB,KAAAmQ,OAAAzJ,IAAA,oEAAA1G,KAAAK,IAEAiC,EAAA6I,OAAA+a,aAAAlmB,KAAA2vB,GACA3vB,KAAAmuB,aAAA5rB,EAAAgrB,mBACAvtB,KAAA2B,GAAA6sB,mBAAAxuB,QAIAuvB,EAAAxpB,UAAAqiB,gBAAA,SAAA5kB,EAAAH,EAAA2oB,EAAAC,GACA,GAAAoC,GAAAruB,IAEA,IAAA,MAAAwD,EAMA,OAAAxD,KAAAouB,OACA,IAAA7rB,GAAA2qB,cACAltB,KAAAmuB,aAAA5rB,EAAA4qB,mBACAntB,KAAA0H,UAAAie,KAAAtiB,IACArD,KAAA0D,kBAEA,MACA,KAAAnB,GAAA4qB,kBACAntB,KAAAwvB,cAAAnsB,EACArD,KAAA0H,UAAAie,KAAAtiB,GAKS2oB,GACTA,KALAhsB,KAAA0D,mBACAuoB,GACAA,SAOG,IAAAzoB,GAAA,KAAA,KAAAA,EACH,OAAAxD,KAAAouB,OACA,IAAA7rB,GAAA2qB,cACA,IAAA3qB,GAAA4qB,kBACAntB,KAAAmuB,aAAA5rB,EAAA+qB,kBACAttB,KAAAwvB,cAAAnsB,EACArD,KAAA2vB,EAAArtB,EAAA6I,OAAAxH,WAAA0qB,EAAAoB,QAAA3tB,KAAAusB,GAAA/rB,EAAA6I,OAAAsZ,SACAzkB,KAAA0H,UAAAie,KAAAtiB,GAKS2oB,GACTA,KALAhsB,KAAA0D,mBACAuoB,GACAA,IAKA,MACA,KAAA1pB,GAAA+qB,mBAYA,IAAAsC,GAAA,SAAA7B,EAAApsB,GACA,GAAAQ,IAAA,eAEAnC,MAAA4M,KAAArK,EAAAqrB,cACA5tB,KAAAK,GAAA0tB,EAAA5F,WACAnoB,KAAA+tB,QAAAA,EACA/tB,KAAA0H,UAAAqmB,EAAArmB,UACA1H,KAAA2B,GAAAA,EACA3B,KAAAwvB,cAAA,GACAzB,EAAAjC,mBAAA9rB,KAEAA,KAAAmQ,OAAAxO,EAAA+Y,UAAA,sBAAA1a,KAAAK,IAEAL,KAAAouB,MAAA7rB,EAAA4qB,kBAEAxrB,EAAAusB,eAAAluB,MAEAA,KAAA6vB,uBAAA,KAEA9B,EAAAhC,MAAA,KAEA/rB,KAAAob,WAAAjZ,GAEAytB,GAAA7pB,UAAA,GAAAzD,GAAA+C,aAEAuqB,EAAA7pB,UAAAooB,aAAA,SAAAC,GACApuB,KAAAouB,MAAAA,EACApuB,KAAA6C,KAAA,iBAGA+sB,EAAA7pB,UAAA+pB,QAAA,WACA9vB,KAAAmQ,OAAAzJ,IAAA,iDAAA1G,KAAAK,IAEAL,KAAAouB,QAAA7rB,EAAA+qB,kBACAttB,KAAAmQ,OAAA7I,KAAA,eAAA,iFAGAtH,KAAAmuB,aAAA5rB,EAAAgrB,mBACAvtB,KAAA2B,GAAA6sB,mBAAAxuB,OAGA4vB,EAAA7pB,UAAAgqB,QAAA,WACA/vB,KAAAmuB,aAAA5rB,EAAAgrB,mBACAvtB,KAAA2B,GAAA6sB,mBAAAxuB,OAIA4vB,EAAA7pB,UAAAiqB,QAAA,WACAhwB,KAAAmQ,OAAAzJ,IAAA,iDAAA1G,KAAAK,IAEAL,KAAAouB,QAAA7rB,EAAA8qB,kBACArtB,KAAAmuB,aAAA5rB,EAAAgrB,mBACAvtB,KAAA2B,GAAA6sB,mBAAAxuB,QAIA4vB,EAAA7pB,UAAArC,iBAAA,WACA1D,KAAA0vB,iBACA1vB,KAAA0vB,gBAAA,EAEA1vB,KAAAmQ,OAAAzJ,IAAA,gEAAA1G,KAAAK,IAEA,OAAAL,KAAA6vB,yBACAvtB,EAAA6I,OAAA8kB,cAAAjwB,KAAA6vB,wBACA7vB,KAAA6vB,uBAAA,MAGAvtB,EAAA6I,OAAA+a,aAAAlmB,KAAAkwB,GACA5tB,EAAA6I,OAAA+a,aAAAlmB,KAAA2W,GACArU,EAAA6I,OAAA+a,aAAAlmB,KAAA4W,GAEA5W,KAAAmuB,aAAA5rB,EAAAgrB,mBACAvtB,KAAA2B,GAAA6sB,mBAAAxuB,QAIA4vB,EAAA7pB,UAAAoqB,mBAAA,WACAnwB,KAAA0H,UAAAie,KAAA3lB,KAAAwvB,gBACAxvB,KAAA0D,oBAKAksB,EAAA7pB,UAAAqiB,gBAAA,SAAA5kB,EAAAH,EAAA2oB,EAAAC,GACA,GAAAoC,GAAAruB,IAEA,IAAAwD,GAAA,KAAA,KAAAA,EACA,OAAAxD,KAAAouB,OACA,IAAA7rB,GAAA4qB,kBACAntB,KAAA0H,UAAAie,KAAAtiB,IACArD,KAAA0D,mBAEA1D,KAAAwvB,cAAAnsB,EAKA,GAAAG,EAAA,KAAA,KAAAA,GAAAxD,KAAAouB,QAAA7rB,EAAA4qB,kBAEA,OAAAntB,KAAA6vB,yBACA7vB,KAAA6vB,uBAAAvtB,EAAA6I,OAAAilB,YAAA/B,EAAA8B,mBAAAruB,KAAAusB,GACA/rB,EAAA6I,OAAA2Z,oCAEG,IAAAthB,GAAA,KAAA,KAAAA,EACH,OAAAxD,KAAAouB,OACA,IAAA7rB,GAAA4qB,kBACAntB,KAAAmuB,aAAA5rB,EAAA8qB,iBACArtB,KAAAwvB,cAAAnsB,EACArD,KAAAkwB,EAAA5tB,EAAA6I,OAAAxH,WAAA0qB,EAAA2B,QAAAluB,KAAAusB,GAAA/rB,EAAA6I,OAAAwZ,SAEA,OAAA3kB,KAAA6vB,yBACAvtB,EAAA6I,OAAA8kB,cAAAjwB,KAAA6vB,wBACA7vB,KAAA6vB,uBAAA,KAGA,KAAAttB,GAAA8qB,gBAEArtB,KAAA0H,UAAAie,KAAAtiB,GAKW2oB,GACXA,KALAhsB,KAAA0D,mBACAuoB,GACAA,SAOG,IAAAzoB,GAAA,KAAA,KAAAA,EACH,OAAAxD,KAAAouB,OACA,IAAA7rB,GAAA4qB,kBACA,OAAAntB,KAAA6vB,yBACAvtB,EAAA6I,OAAA8kB,cAAAjwB,KAAA6vB,wBACA7vB,KAAA6vB,uBAAA,MAGA7vB,KAAA0H,UAAAie,KAAAtiB,IAMArD,KAAAmuB,aAAA5rB,EAAA+qB,kBACAttB,KAAA2W,EAAArU,EAAA6I,OAAAxH,WAAA0qB,EAAAyB,QAAAhuB,KAAAusB,GAAA/rB,EAAA6I,OAAAoZ,SACAyH,GACAA,MARAhsB,KAAA0D,mBACAuoB,GACAA,MAqCA,IAAAoE,GAAA,SAAA1uB,EAAAosB,GACA,GAAAM,EAEA,QAAAN,EAAA/F,QACA,IAAA1lB,GAAAC,EAAAgc,OAEA,GADA8P,EAAA1sB,EAAAsmB,aAAAqI,IAAAvC,EAAA5F,YACA,CACA,OAAAkG,EAAAD,OACA,IAAA7rB,GAAA4qB,kBACAkB,EAAA3mB,UAAAie,KAAA0I,EAAAmB,cACA,MAIA,KAAAjtB,GAAA8qB,iBAGA,OAAA,EAEA,KACA,KAAA/qB,GAAAC,EAAA4b,IAIA,GAHAkQ,EAAA1sB,EAAAsmB,aAAAqI,IAAAvC,EAAA5F,aAGAkG,EAYA,OAAA,CAXA,IAAAA,EAAAD,QAAA7rB,EAAA8qB,gBACA,OAAA,CACS,IAAAgB,EAAAD,QAAA7rB,EAAA+qB,iBAGT,MAFAe,GAAAD,MAAA7rB,EAAAirB,iBACAa,EAAAzX,EAAAtU,EAAA6I,OAAAxH,WAAA0qB,EAAA0B,QAAAjuB,KAAAusB,GAAA/rB,EAAA6I,OAAAqZ,UACA,CAQA,MACA,KAAAliB,GAAAC,EAAA8b,OAEA,MADAgQ,GAAA1sB,EAAAsmB,aAAAqI,IAAAvC,EAAA5F,YACAkG,GACAN,EAAA1B,SAAA,KACAgC,EAAAD,QAAA7rB,EAAA4qB,oBAMAY,EAAA1B,SAAA,MACA,EAGA,SAIA,GADAgC,EAAA1sB,EAAAsmB,aAAAsI,KAAAxC,EAAA5F,YACA,CACA,OAAAkG,EAAAD,OACA,IAAA7rB,GAAA2qB,cACA,KACA,KAAA3qB,GAAA4qB,kBACA,IAAA5qB,GAAA+qB,iBACAe,EAAA3mB,UAAAie,KAAA0I,EAAAmB,eAGA,OAAA,IAMAltB,GAAAkuB,cACAjuB,EAAAA,EACA8tB,iBAAAA,EACAxC,2BAAAA,EACAc,wBAAAA,EACAW,qBAAAA,EACAC,2BAAAA,EACAK,wBAAAA,KjBqzGM,SAAS/vB,EAAQD,GkB/+HvBC,EAAAD,QAAA,SAAA0C,GACA,GAAAmuB,EA0EA,OAxEAA,GAAA,SAAAC,EAAAC,EAAA5C,GAEA/tB,KAAA0wB,OAAAA,EACA1wB,KAAA2wB,UAAAA,EACA3wB,KAAA+tB,QAAAA,EAGA/tB,KAAA4wB,WAAA,EACA5wB,KAAA6wB,eAAA,MAGAJ,EAAA1qB,WACA4f,KAAA,WACA,GAAAlc,GAAAzJ,KACA8tB,EAAA,GAAAxrB,GAAAmuB,cAAAzwB,KAAAA,KAAA0wB,OAAAI,MAAAnvB,GAEAmsB,GAAAnI,OAGA3lB,KAAA+tB,QAAA/F,SAAA1lB,EAAAC,EAAAgc,QAAAuP,EAAAiD,kBAAA3C,QAAA9rB,EAAAkuB,aAAAjuB,EAAAgrB,oBACAvtB,KAAA0wB,OAAAM,mBAAA,EACAlD,EAAAiD,kBAAAlvB,GAAA,eAAA,QAAAssB,KACAnuB,KAAAouB,QAAA9rB,EAAAkuB,aAAAjuB,EAAA8qB,iBACArtB,KAAAouB,QAAA9rB,EAAAkuB,aAAAjuB,EAAA+qB,kBACAttB,KAAAouB,QAAA9rB,EAAAkuB,aAAAjuB,EAAAgrB,oBAEAvtB,KAAA+b,IAAA,eAAAoS,GACA1kB,EAAAinB,OAAAM,mBAAA,EAEAvnB,EAAAinB,OAAAO,qBAAA,GACAxnB,EAAAinB,OAAAI,MAAAI,yBAOAzC,iBAAA,WACAzuB,KAAA2wB,UAAAlC,oBAGA/qB,iBAAA,WACA1D,KAAA2wB,UAAAjtB,oBAGA0kB,gBAAA,SAAA/kB,GACA,GAAAoG,GAAAzJ,IAGA,OAAAqD,EAAAG,aAAA,MAAAH,EAAAG,YACAxD,KAAA2wB,UAAAQ,cAAA9tB,GACKA,EAAA2kB,SAAA1lB,EAAAC,EAAAgc,QAAA,MAAAlb,EAAAG,YACLxD,KAAA4wB,UACA5wB,KAAA2wB,UAAAvI,gBAAA/kB,IAEArD,KAAA+tB,QAAAhE,KAAA9jB,MAAAjG,KAAA0wB,OAAAU,cAAA,EACApxB,KAAA6wB,eAAAvuB,EAAA6I,OAAAxH,WACA,WACA8F,EAAAknB,UAAAG,MAAAjN,SAAAvhB,EAAA+uB,QAAA9uB,EAAAgrB,oBACA9jB,EAAAmnB,WAAA,EACAnnB,EAAAqkB,eAAAnI,SAGA3lB,KAAAsxB,wBAIAtxB,KAAA2wB,UAAAvI,gBAAA/kB,KAKAotB,IlBugIM,SAAS5wB,EAAQD,GmBtlIvBC,EAAAD,QAAA,SAAA0C,EAAAmuB,GAEA,GAAAc,GACAhvB,GAEAivB,aAAA,EACAhE,iBAAA,EAIA+D,GAAA,SAAAT,EAAAnN,EAAA/W,EAAAwhB,GACA,GAAA1sB,EAKA,OAHA1B,MAAAgxB,mBAAA,EACAhxB,KAAAixB,mBAAA,EAEAtN,EAAA2G,UAAA,YAOA8D,EADAzK,YAAArhB,GAAAylB,iBACApE,EAAAngB,YAAA,IAAAjB,EAAAivB,aAAAjvB,EAAAirB,iBAGAY,GAAA7rB,EAAAirB,iBAGA9rB,EAAAiiB,EAAAiF,YAAA,WAGA,QAAAhc,GACA5M,KAAAK,IACAypB,QAAAnG,EAAAmG,QACA2H,UAAA9N,EAAAgG,OACA+H,WAAA/N,EAAA8F,SACAzX,SAAA,WACA,MAAAhS,MAAA8pB,QAAA9pB,KAAAyxB,UAAAzxB,KAAA0xB,aAGA1xB,KAAAouB,MAAAA,EACApuB,KAAA2xB,cAAAhO,EAAAoG,KACA/pB,KAAA4xB,UAAAjO,EAAAiF,YAAA,MAAA3gB,IACAjI,KAAA6xB,WAAAlO,EAAAiF,YAAA,QAAA3gB,IACAjI,KAAA8xB,cAAApwB,EAAAuG,IACAjI,KAAA4qB,UAAAjH,EAAA0F,WAAA,gBACArpB,KAAA+xB,cAAApO,EAAAoG,KACA/pB,KAAAoxB,aAAAzN,EAAAoG,MAGA,QAAAnd,IACA5M,KAAAK,IACAypB,QAAAnG,EAAAmG,QACA2H,UAAA9N,EAAA8F,SACAiI,WAAA/N,EAAAgG,OACA3X,SAAA,WACA,MAAAhS,MAAA8pB,QAAA9pB,KAAAyxB,UAAAzxB,KAAA0xB,aAGA1xB,KAAAouB,MAAAA,EACApuB,KAAA+xB,cAAApO,EAAAoG,KACA/pB,KAAAoxB,aAAAzN,EAAAoG,KACA/pB,KAAA4xB,UAAAjO,EAAAiF,YAAA,QAAA3gB,IACAjI,KAAAgyB,WACAhyB,KAAA6xB,WAAAlO,EAAAiF,YAAA,MAAA3gB,IACAjI,KAAA8xB,cAAApwB,EAAAuG,IACAjI,KAAA4qB,UAAAjH,EAAA0F,WAAA,gBAAA4I,UAGAjyB,KAAAouB,QAAA7rB,EAAAivB,cAAAV,EAAAoB,WACAlyB,KAAAmyB,aAAArB,EAAAsB,oBAAAtB,KAIA9wB,KAAAmQ,OAAA2gB,EAAAnvB,GAAA+Y,UAAA,aAAA1a,KAAAK,GAAA2R,YACAhS,KAAA8wB,MAAAA,EACAA,EAAAnvB,GAAA0wB,QAAAryB,KAAAK,GAAA2R,YAAAhS,SACAA,MAAAmQ,OAAAzJ,IAAA,OAAAkG,EAAA,gCAAA5M,KAAAouB,QAAA7rB,EAAAivB,aAAA,QAAA,gBA5DAnX,MAAA,2DA+DAkX,EAAAxrB,WAKAusB,OAAA,SAAA3O,EAAA/W,GACA5M,KAAAouB,MAAA7rB,EAAAirB,iBAEAxtB,KAAAmQ,OAAAzJ,IAAA,UAAA1G,KAAAK,GAAA2R,WAAA,gCAEA,QAAApF,IAEA5M,KAAA4qB,UAAAjH,EAAA0F,WAAA,gBAAA4I,YAIAM,UAAA,WACAvyB,KAAAmQ,OAAAzJ,IAAA,UAAA1G,KAAAK,GAAA2R,WAAA,YACAhS,KAAAmyB,cAAAnyB,KAAAouB,QAAA7rB,EAAAirB,kBACAxtB,KAAAmyB,aAAAK,eAAApM,cAEApmB,MAAA8wB,MAAAnvB,GAAA0wB,QAAAryB,KAAAK,GAAA2R,aAUAygB,cAAA,SAAAzK,EAAA3gB,EAAAsK,GACA,GAAAoY,GAAAgE,CAsBA,OArBA1mB,IAAAA,OAAAiK,QAEAtR,KAAAoxB,eAA4BpxB,KAAAoxB,aAAAze,KAAAwC,MAAA,IAAAxC,KAAAC,WAE5BmX,EAAA/B,IAAA1lB,EAAAC,EAAA8b,QAAA2J,IAAA1lB,EAAAC,EAAA4b,IAAAne,KAAA+xB,cAAA/xB,KAAAoxB,cAAA,EAEArD,EAAA,GAAAzrB,GAAAioB,gBACAvC,EACAhoB,KAAA8xB,cACA9xB,KAAA8wB,MAAAnvB,IACAooB,KAAAA,EACAD,QAAA9pB,KAAAK,GAAAypB,QACAuB,SAAArrB,KAAA4xB,UACAnI,SAAAzpB,KAAAK,GAAAoxB,UACAxG,OAAAjrB,KAAA6xB,WACAlI,OAAA3pB,KAAAK,GAAAqxB,WACA9G,UAAA5qB,KAAA4qB,WACOvjB,EAAAsK,GAEPoc,EAAA2C,OAAA1wB,KAEA+tB,GASA2E,qBAAA,SAAA3E,GACA,GAAAtkB,GAAAzJ,IAEA,IAAAA,KAAA2xB,cAEK,CAAA,GAAA5D,EAAAhE,KAAA/pB,KAAA2xB,cAKL,MAHA5D,GAAA/F,SAAA1lB,EAAAC,EAAA4b,KACA4P,EAAAhC,MAAA,KAEAgC,EAAAhE,OAAA/pB,KAAA+xB,aAIKhE,GAAAhE,KAAA/pB,KAAA2xB,gBACL3xB,KAAA2xB,cAAA5D,EAAAhE,UAXA/pB,MAAA2xB,cAAA5D,EAAAhE,IAcA,QAAAgE,EAAA/F,QAEA,IAAA1lB,GAAAC,EAAAgc,OACA,GAAAve,KAAAgxB,qBAAA,EACAjD,EAAAhC,MAAA,SACS,CAAA,GAAA/rB,KAAAixB,qBAAA,EAAA,CACT,GAAA0B,IAAA,GAAAhgB,KAAAC,SAAA,GAAA,CAEA,OADAmb,GAAAhC,MAAA,IAAA,MAAA,eAAA4G,KACA,EAEA3yB,KAAAixB,mBAAA,EACAlD,EAAAjC,mBAAAjqB,GAAA,eAAA,QAAAssB,KACAnuB,KAAAouB,QAAA9rB,EAAAkuB,aAAAjuB,EAAA8qB,iBACArtB,KAAAouB,QAAA9rB,EAAAkuB,aAAAjuB,EAAA+qB,kBACAttB,KAAAouB,QAAA9rB,EAAAkuB,aAAAjuB,EAAAgrB,oBAEAvtB,KAAA+b,IAAA,eAAAoS,GACA1kB,EAAAwnB,mBAAA,EAEAxnB,EAAAunB,qBAAA,GACAvnB,EAAAqnB,MAAAI,uBAOAnD,EAAAzD,UAAA,YACAyD,EAAAjC,mBAAAjqB,GAAA,eAAA,WACA7B,KAAAouB,QAAA9rB,EAAAkuB,aAAAjuB,EAAA8qB,kBACA5jB,EAAAqoB,cAAA/D,EAAAnF,YAAA,WAAA3gB,MAIA,MACA,KAAA3F,GAAAC,EAAAkc,OAEAsP,EAAAzD,UAAA,YACAyD,EAAAjC,mBAAAjqB,GAAA,eAAA,WACA7B,KAAAouB,QAAA9rB,EAAAkuB,aAAAjuB,EAAA+qB,mBACA7jB,EAAAqoB,cAAA/D,EAAAnF,YAAA,WAAA3gB,OAOA,OAAA,GAGA2qB,YAAA,SAAAjC,EAAA3I,EAAApnB,GACAA,EAAAA,KAEA,IACAyG,IAAAzG,EAAAyG,kBAAAiK,QACAK,EAAA/Q,EAAA+Q,MAAA,KACAoc,EAAA/tB,KAAAyyB,cAAAzK,EAAA3gB,EAAAsK,GACAmc,EAAA,GAAA2C,GAAAzwB,KAAA2wB,EAAA5C,EAIA,OAFAD,GAAAnI,OAEAoI,GAMAjG,eAAA,SAAAiG,GAEA/tB,KAAA0yB,qBAAA3E,IAIA/tB,KAAA8wB,MAAAhJ,eAAAiG,KAIAwD,EAAAhvB,EAAAA,EACAD,EAAAivB,OAAAA,InB0mIM,SAAS1xB,EAAQD,GoB31IvBC,EAAAD,QAAA,SAAA0C,GACA,GAAAmuB,EAEAA,GAAA,SAAAE,EAAAhvB,GACA3B,KAAAmQ,OAAAxO,EAAA+Y,UAAA,qBACA1a,KAAA2B,GAAAA,EACA3B,KAAA2wB,UAAAA,EACA3wB,KAAAgoB,OAAA2I,EAAA5C,QAAA/F,OACAhoB,KAAA+tB,QAAA4C,EAAA5C,QACA/tB,KAAA6yB,YAAA,KACA7yB,KAAA8yB,YAAA,EACA9yB,KAAA+yB,QAAA,EAGApxB,EAAAkiB,SAAAvhB,EAAAwQ,GAAAvQ,EAAAolB,oBAAA3nB,KAAAgoB,SAAA1lB,EAAAC,EAAA6b,KAAApe,KAAAgoB,SAAA1lB,EAAAC,EAAA4b,KACAne,KAAA0D,oBAOA+sB,EAAA1qB,WACA4f,KAAA,WACA,OAAA3lB,KAAAgoB,QACA,IAAA,SACAhoB,KAAA+wB,kBAAA,GAAAzuB,GAAAkuB,aAAA7B,wBAAA3uB,KAAAA,KAAA+tB,QAAA/tB,KAAA2B,GAAA+F,UACA,MACA,KAAA,MACA1H,KAAA+wB,kBAAA,GAAAzuB,GAAAkuB,aAAAlB,qBAAAtvB,KAAAA,KAAA+tB,QAAA/tB,KAAA2B,GAAA+F,UACA,MACA,SACA1H,KAAA+wB,kBAAA,GAAAzuB,GAAAkuB,aAAA3C,2BAAA7tB,KAAAA,KAAA+tB,QAAA/tB,KAAA2B,GAAA+F,WAIA,MAFA1H,MAAA+wB,kBAAApL,OAEA3lB,KAAA+wB,mBAQAtC,iBAAA,WACAzuB,KAAA2wB,UAAAlC,oBAQA/qB,iBAAA,WACA1D,KAAA2wB,UAAAjtB,oBAQA0kB,gBAAA,SAAA/kB,GACA,GAAA0mB,GAAAiJ,EAAAC,EACAzvB,EAAAH,EAAAG,WAMA,IAAA,MAAAA,GAAA,MAAAA,GAAA,OAAAxD,KAAA2B,GAAAqkB,cAAA9d,SAkDAlI,KAAA2wB,UAAAvI,gBAAA/kB,OAlDA,CAYA,GATA,MAAAA,EAAAG,aACAwvB,EAAA3vB,EAAAulB,YAAA,oBACAqK,EAAA,kBAEAD,EAAA3vB,EAAAulB,YAAA,sBACAqK,EAAA,wBAIAD,EAGA,MAFAhzB,MAAAmQ,OAAA7I,KAAAjE,EAAAG,YAAA,6DACAxD,MAAA2wB,UAAAvI,gBAAA/kB,EAIA,KAAArD,KAAA8yB,aAAA9yB,KAAA+yB,QAAAC,EAAAE,SAAA,EAAA,CAMA,GALAlzB,KAAA6yB,cACA7yB,KAAA6yB,YAAA,GAAAvwB,GAAAqJ,qBAAA3L,KAAA2B,MAIA3B,KAAA6yB,YAAAM,aAAAnzB,KAAA+tB,QAAAiF,GAEA,WADAhzB,MAAA2wB,UAAAvI,gBAAA/kB,EAGArD,MAAA8yB,YAAA,EAEAE,EAAAE,QACAlzB,KAAA+yB,QAAA,GAGA1vB,EAAA2kB,SAAA1lB,EAAAC,EAAAoc,SACAoL,EAAA/pB,KAAA2wB,UAAA5G,MAAA,EACS/pB,KAAA+tB,QAAA2C,OACT3G,EAAA/pB,KAAA+tB,QAAA2C,OAAAU,cAAA,GAEArH,EAAA/pB,KAAA+tB,QAAAhE,KAAA,EACA/pB,KAAA+tB,QAAAhE,KAAAA,GAEA/pB,KAAA+tB,QAAAvE,UAAA,OAAAO,EAAA,IAAA/pB,KAAAgoB,QAEAhoB,KAAA+tB,QAAAvE,UAAAyJ,EAAAjzB,KAAA6yB,YAAA7gB,YACAhS,KAAA2lB,WAEA3lB,MAAA2wB,UAAAvI,gBAAA/kB,MAQAf,EAAAmuB,cAAAA,IpB82IM,SAAS5wB,EAAQD,GqBt/IvBC,EAAAD,QAAA,SAAA0C,GAEA,GAAA8wB,EAEAA,GAAA,SAAAzxB,GACA,GAAA8oB,MACA4I,EAAA,EACAlxB,GACA,aACA,eAGAnC,MAAAszB,UAAA3xB,EAAAqkB,cAAAuN,gBACAvzB,KAAAwzB,QAAA7xB,EAAAqkB,cAAAyN,gBAIAzzB,KAAA0B,QAAAC,EAAAD,QAAAsQ,WAEAqhB,IACArzB,KAAA0B,SAAA,WAAsB2xB,EACtBrzB,KAAA0B,SAAA,6BAAsBC,EAAAqkB,cAAA0N,WAAA,MAItB1zB,KAAA8pB,QAAAxnB,EAAAmJ,MAAA6G,kBAAA,IACAtS,KAAA+pB,KAAA,GAEA/pB,KAAAirB,OAAAtpB,EAAAqkB,cAAA/d,IAEAwiB,EAAAQ,OAAAjrB,KAAAirB,OACAR,EAAAX,QAAA9pB,KAAA8pB,QACAW,EAAAV,KAAA/pB,KAAA+pB,KAGAznB,EAAAmJ,MAAA8D,QAAAvP,KAAAsC,EAAAqxB,eAAAhyB,EAAA,WAAA3B,KAAAszB,WAA+E7I,OAAAA,KAE/EzqB,KAAA4zB,kBAAA,KACA5zB,KAAA6zB,yBAAA,KAGA7zB,KAAA8zB,YAAA,EAEA9zB,KAAAmQ,OAAAxO,EAAA+Y,UAAA,uBACA1a,KAAAqb,eAAAlZ,IAGAixB,EAAArtB,WACAY,SAAA,SAAA/F,GACA,GAAAyG,GAAAoC,EAAAzJ,IAGAY,GAAAA,MACAyG,GAAAzG,EAAAyG,kBAAAiK,QACAjK,EAAAD,KAAA,YAAApH,KAAA0B,QAAA,YAAqD1B,KAAAwzB,SACrDnsB,EAAAD,KAAA,UAAA9E,EAAAmJ,MAAA2J,kBAAApV,KAAA2B,KAEA3B,KAAAooB,gBAAA,SAAA/kB,GACA,GAAA3B,GAAA8xB,EAEAlwB,EADAywB,EAAA1wB,EAAAgmB,WAAA,WAAA3f,MAIA,IAAArG,EAAA0mB,OAAA/pB,KAAA+pB,KAUA,OALA,OAAA/pB,KAAA4zB,oBACAtxB,EAAA6I,OAAA+a,aAAAlmB,KAAA4zB,mBACA5zB,KAAA4zB,kBAAA,OAGA,GACA,IAAA,cAAwBrwB,KAAAF,EAAAG,aACxBxD,KAAA6C,KAAA,WAAAQ,EACA,MACA,KAAA,cAAwBE,KAAAF,EAAAG,aAaxB,GAZAxD,KAAA6C,KAAA,WAAAQ,GAEAA,EAAAinB,UAAA,aACAkJ,EAAAnwB,EAAAmlB,UAAA,YAGA,OAAAxoB,KAAA6zB,2BACAvxB,EAAA6I,OAAA+a,aAAAlmB,KAAA6zB,0BACA7zB,KAAA6zB,yBAAA,OAIAE,EAAA,CACA/zB,KAAAmQ,OAAA7I,KAAA,8DACA,OAGA,KAAAysB,KAAA,CAEA,GADAryB,EAAA2B,EAAAulB,YAAA,UAAAmL,GACAryB,EAAAuG,IAAA8L,OAAA/T,KAAA2B,GAAAD,QAAAuG,IAAA8L,KAAA,CACAyf,EAAA9xB,EAAAgoB,SAAA,UACA,OAEAhoB,EAAA,KAIA,IAAAA,EAAA,CACA1B,KAAAmQ,OAAA7I,KAAA,qDACA,OAGAksB,IACAA,EAAAxzB,KAAAwzB,SAKAxzB,KAAA4zB,kBAAAtxB,EAAA6I,OAAAxH,WAAA,WACA8F,EAAAmqB,kBAAA,KACAnqB,EAAA9C,SAAA/F,IACW,IAAA4yB,EAAA,KACXxzB,KAAA6zB,yBAAAvxB,EAAA6I,OAAAxH,WAAA,WACA8F,EAAA0G,OAAA7I,KAAA,wBACAmC,EAAAqqB,YACArqB,EAAAuqB,aAAA,KAAA1xB,EAAAC,EAAAF,OAAAob,UAEW,IAAA+V,GAGX9xB,EAAA0qB,SAAA,eACApsB,KAAA2B,GAAAD,QAAAiqB,UAAArpB,EAAAqR,IAAAN,MAAA3R,EAAAgoB,SAAA,aAAAzY,QAAA,KAAA,MAEAvP,EAAA0qB,SAAA,cACApsB,KAAA2B,GAAAD,QAAAgqB,SAAAppB,EAAAqR,IAAAN,MAAA3R,EAAAgoB,SAAA,YAAAzY,QAAA,KAAA,MAGAjR,KAAA8zB,YAAA,EACA9zB,KAAA6C,KAAA,aAAAQ,GAAA,KACA,MAEA,KAAA,QAAAE,KAAAF,EAAAG,aACAH,EAAAinB,UAAA,gBAEAtqB,KAAAwzB,QAAAnwB,EAAAmlB,UAAA,eAEAxoB,KAAA2G,SAAA/F,KAEAZ,KAAAmQ,OAAA7I,KAAA,0DACAtH,KAAAi0B,oBAAA5wB,EAAAf,EAAAC,EAAAF,OAAAyS,kBAEA,MACA,SACAxR,EAAAhB,EAAAmJ,MAAAmJ,cAAAvR,EAAAG,aACAxD,KAAAi0B,oBAAA5wB,EAAAC,KAIAtD,KAAAyuB,iBAAA,WACAzuB,KAAAi0B,oBAAA,KAAA3xB,EAAAC,EAAAF,OAAAqa,kBAGA1c,KAAA0D,iBAAA,WACA1D,KAAAi0B,oBAAA,KAAA3xB,EAAAC,EAAAF,OAAAoa,mBAGAzc,KAAA+pB,OACA/pB,KAAA+tB,QAAAhE,KAAA/pB,KAAA+pB,KACA/pB,KAAA+tB,QAAAvE,UAAA,OAAAxpB,KAAA+pB,KAAA;AACA/pB,KAAA+tB,QAAA1mB,aAAAA,EACArH,KAAA2lB,QAGAsO,oBAAA,SAAA5wB,EAAAC,GACAtD,KAAA6C,KAAA,SAAAQ,GAAA,KAAAC,GAAA,OAGA8jB,kBAAA,WACApnB,KAAAk0B,kBAAAl0B,KAAA8zB,WACA,OAAA9zB,KAAA4zB,oBACAtxB,EAAA6I,OAAA+a,aAAAlmB,KAAA4zB,mBACA5zB,KAAA4zB,kBAAA,MAGA,OAAA5zB,KAAA6zB,2BACAvxB,EAAA6I,OAAA+a,aAAAlmB,KAAA6zB,0BACA7zB,KAAA6zB,yBAAA,MAGA7zB,KAAA8zB,YACA9zB,KAAAg0B,aAAA,KAAA1xB,EAAAC,EAAAF,OAAAoa,mBAIAwK,qBAAA,WACAjnB,KAAA2G,YAGAyf,MAAA,WACApmB,KAAAk0B,kBAAAl0B,KAAA8zB,WACA9zB,KAAAuE,cAGAA,WAAA,SAAA3D,GACA,GAAAyG,EAEA,OAAArH,MAAA8zB,YAKAlzB,EAAAA,MACAyG,GAAAzG,EAAAyG,kBAAAiK,QAEAtR,KAAA8zB,YAAA,EAGA,OAAA9zB,KAAA4zB,oBACAtxB,EAAA6I,OAAA+a,aAAAlmB,KAAA4zB,mBACA5zB,KAAA4zB,kBAAA,MAGAhzB,EAAAgJ,KACAvC,EAAAD,KAAA,cACAC,EAAAD,KAAA,eAEAC,EAAAD,KAAA,YAAApH,KAAA0B,QAAA,cAIA1B,KAAAooB,gBAAA,SAAA/kB,GACA,GAAAC,EAEA,SAAA,GACA,IAAA,cAAwBC,KAAAF,EAAAG,aACxBxD,KAAA6C,KAAA,WAAAQ,EACA,MACA,KAAA,cAAwBE,KAAAF,EAAAG,aACxBxD,KAAA6C,KAAA,WAAAQ,GACA,OAAArD,KAAA6zB,2BACAvxB,EAAA6I,OAAA+a,aAAAlmB,KAAA6zB,0BACA7zB,KAAA6zB,yBAAA,MAEA7zB,KAAAg0B,aAAA3wB,EACA,MACA,SACAC,EAAAhB,EAAAmJ,MAAAmJ,cAAAvR,EAAAG,aACAxD,KAAAg0B,aAAA3wB,EAAAC,KAIAtD,KAAAyuB,iBAAA,aAKAzuB,KAAA0D,iBAAA,aAKA1D,KAAA+pB,OACA/pB,KAAA+tB,QAAAhE,KAAA/pB,KAAA+pB,KACA/pB,KAAA+tB,QAAAvE,UAAA,OAAAxpB,KAAA+pB,KAAA,aACA/pB,KAAA+tB,QAAA1mB,aAAAA,MAEArH,MAAA2lB,YA3DA3lB,MAAAmQ,OAAA7I,KAAA,yBA8DA0sB,aAAA,SAAA3wB,EAAAC,GACAtD,KAAA8zB,YAAA,EACA9zB,KAAA6C,KAAA,eAAAQ,GAAA,KAAAC,GAAA,QAMAhB,EAAA8wB,gBAAAA,IrB8/IM,SAASvzB,EAAQD,GsBxwJvBC,EAAAD,QAAA,SAAAyF,GACA,GAAAgG,GAAA,SAAA5H,EAAA7C,GAEA6C,EAAAA,EACA7C,EAAAA,EAmCA,OAhCAyK,GAAAtF,UAAAJ,OAAAC,OAAAP,EAAAU,WACAouB,SAAYluB,MAAA,cAEZmgB,OAAUngB,MAAA,cAOVmuB,gBAAmBnuB,MAAA,SAAA+lB,EAAAC,EAAAoI,GAEnBrI,EAAAA,EACAC,EAAAA,EACAoI,EAAAA,IAUAC,gBAAmBruB,MAAA,SAAAuH,EAAAwe,EAAAC,GAEnBze,EAAAA,EACAwe,EAAAA,EACAC,EAAAA,MAIA5gB,ItByxJM,SAASxL,EAAQD,GuBz0JvBC,EAAAD,QAAA,SAAA0C,GACA,GAAAqxB,EAEAA,GAAA,SAAAhyB,EAAAqmB,EAAAvd,EAAA7J,GACA,GAAA6pB,GAAApjB,EACAktB,EAAA9pB,EACAtI,GACA,WACA,WACA,WACA,SACA,SAGA,IAAApB,SAAA0J,EACA,KAAA,IAAAiR,WAAA,uBAKA,IADAjR,EAAA9I,EAAA4R,gBAAA9I,IACAA,EACA,KAAA,IAAAiR,WAAA,mBAAA6Y,EAGAv0B,MAAA2B,GAAAA,EACA3B,KAAAmQ,OAAAxO,EAAA+Y,UAAA,qBACA1a,KAAAgoB,OAAAA,EAEAyC,EAAA7pB,GAAAA,EAAA6pB,OACApjB,GAAAzG,GAAAA,EAAAyG,kBAAAiK,QAEA1Q,GAAAA,EAAA+Q,OACA3R,KAAA2R,KAAA/Q,EAAA+Q,MAEA/Q,GAAAA,EAAA4zB,cACAx0B,KAAAw0B,YAAA5zB,EAAA4zB,YACAntB,EAAAD,KAAA,iBAAApH,KAAAw0B,cAGAx0B,KAAA+tB,QAAA,GAAAzrB,GAAAioB,gBAAAvqB,KAAAgoB,OAAAvd,EAAAzK,KAAA2B,GAAA8oB,EAAApjB,GAEArH,KAAAy0B,cAAAz0B,KAAA+tB,QAAA9Y,KACAjV,KAAA00B,eAAA10B,KAAA+tB,QAAA7Y,GAEAlV,KAAA2R,OACA3R,KAAA+tB,QAAApc,KAAA3R,KAAA2R,MAGA3R,KAAAsc,QAEAtc,KAAAob,WAAAjZ,IAEAwxB,EAAA5tB,UAAA,GAAAzD,GAAA+C,aAEAsuB,EAAA5tB,UAAA4f,KAAA,WAEA,MADA,IAAArjB,GAAAmuB,cAAAzwB,KAAAA,KAAA2B,IAAAgkB,OACA3lB,MAGA2zB,EAAA5tB,UAAA6oB,OAAA,SAAAhuB,GACAA,EAAAA,KAEA,IAGA+zB,GAFAnxB,EAAA5C,EAAA4C,YACA4mB,EAAAxpB,EAAAwpB,aAGA,IAAA5mB,GAAA,IAAAA,GAAAA,EAAA,IACA,KAAA,IAAAkY,WAAA,wBAAAlY,EACGA,KACH4mB,EAAAA,GAAA9nB,EAAAC,EAAAE,cAAAe,IAAA,GACAmxB,EAAA,cAA0BnxB,EAAA,WAA2B4mB,EAAA,KAErDpqB,KAAA+tB,QAAAa,OAAA+F,GAEA30B,KAAA6C,KAAA,WAGA8wB,EAAA5tB,UAAAqiB,gBAAA,SAAA/kB,GACA,GAAAC,GAAAhB,EAAAC,EAAAE,cAAAY,EAAAG,cAAA,EAEA,SAAA,GACA,IAAA,cAAoBD,KAAAF,EAAAG,aACpBxD,KAAA6C,KAAA,WAAAQ,EAAAC,EACA,MAEA,KAAA,cAAoBC,KAAAF,EAAAG,aACpBxD,KAAA2B,GAAAizB,WAAA50B,aACAA,MAAA2B,GAAAizB,WAAA50B,MAEAA,KAAA6C,KAAA,WAAAQ,EAAAC,EACA,MAEA,SACAtD,KAAA2B,GAAAizB,WAAA50B,aACAA,MAAA2B,GAAAizB,WAAA50B,MAEAA,KAAA6C,KAAA,WAAAQ,EAAAC,GACAtD,KAAA6C,KAAA,SAAAQ,EAAAC,KAMAqwB,EAAA5tB,UAAA0oB,iBAAA,WACAzuB,KAAA6C,KAAA,SAAA,KAAAP,EAAAC,EAAAF,OAAAqa,kBAGAiX,EAAA5tB,UAAArC,iBAAA,WACA1D,KAAA6C,KAAA,SAAA,KAAAP,EAAAC,EAAAF,OAAAoa,mBAGAna,EAAAqxB,cAAAA,IvBi1JM,SAAS9zB,EAAQD,GwBj8JvBC,EAAAD,QAAA,SAAA0C,GACA,GAAAuyB,EAEAA,GAAA,SAAAlzB,EAAAosB,GACA,GAAA5rB,IACA,WACA,WACA,WACA,SAEAnC,MAAA2B,GAAAA,EACA3B,KAAAmQ,OAAAxO,EAAA+Y,UAAA,qBACA1a,KAAA+tB,QAAAA,EACAA,EAAA/F,SAAA1lB,EAAAC,EAAAgc,OACAve,KAAAsnB,YAAA,GAAAhlB,GAAAkuB,aAAAZ,wBAAA7B,EAAApsB,GAEA3B,KAAAsnB,YAAA,GAAAhlB,GAAAkuB,aAAAjB,2BAAAxB,EAAApsB,GAGAosB,EAAApc,OACA3R,KAAA2R,KAAAoc,EAAApc,MAEAoc,EAAAzD,UAAA,kBACAtqB,KAAAw0B,YAAAzG,EAAAvF,UAAA,iBAEAxoB,KAAAgoB,OAAA+F,EAAA/F,OAEAhoB,KAAAsc,QAEAtc,KAAAy0B,cAAA1G,EAAA7Y,GACAlV,KAAA00B,eAAA3G,EAAA9Y,KAEAjV,KAAAob,WAAAjZ,IAGA0yB,EAAA9uB,UAAA,GAAAzD,GAAA+C,aAEAwvB,EAAA9uB,UAAA+uB,SAAA,SAAAl0B,GACAA,EAAAA,KACA,IAKAyC,GAJAqnB,EAAA9pB,EAAA8pB,YAAA,IACAC,EAAA/pB,EAAA+pB,cAAAroB,EAAAC,EAAAE,cAAAioB,GACArjB,GAAAzG,EAAAyG,kBAAAiK,QACAK,EAAA/Q,EAAA+Q,IAGA,IAAA,IAAA+Y,GAAAA,EAAA,IACA,KAAA,IAAAhP,WAAA,uBAAAgP,EAKA,OAHArnB,GAAArD,KAAA+tB,QAAAhC,MAAArB,EAAAC,EAAAtjB,EAAAsK,GACA3R,KAAA6C,KAAA,WAAAQ,EAAAsnB,GAEA3qB,MAGA60B,EAAA9uB,UAAAgvB,OAAA,SAAAn0B,GACAA,EAAAA,KACA,IAKAyC,GAJAqnB,EAAA9pB,EAAA8pB,YAAA,IACAC,EAAA/pB,EAAA+pB,cAAAroB,EAAAC,EAAAE,cAAAioB,GACArjB,GAAAzG,EAAAyG,kBAAAiK,QACAK,EAAA/Q,EAAA+Q,IAGA,IAAA,IAAA+Y,GAAAA,EAAA,IACA,KAAA,IAAAhP,WAAA,uBAAAgP,EAKA,OAHArnB,GAAArD,KAAA+tB,QAAAhC,MAAArB,EAAAC,EAAAtjB,EAAAsK,GACA3R,KAAA6C,KAAA,WAAAQ,EAAAsnB,GAEA3qB,MAGA60B,EAAA9uB,UAAA7B,OAAA,SAAAtD,GACAA,EAAAA,KACA,IAKAyC,GAJAqnB,EAAA9pB,EAAA8pB,YAAA,IACAC,EAAA/pB,EAAA+pB,cAAAroB,EAAAC,EAAAE,cAAAioB,GACArjB,GAAAzG,EAAAyG,kBAAAiK,QACAK,EAAA/Q,EAAA+Q,IAGA,IAAA,IAAA+Y,GAAAA,EAAA,IACA,KAAA,IAAAhP,WAAA,uBAAAgP,EAMA,OAJArnB,GAAArD,KAAA+tB,QAAAhC,MAAArB,EAAAC,EAAAtjB,EAAAsK,GACA3R,KAAA6C,KAAA,WAAAQ,EAAAsnB,GACA3qB,KAAA6C,KAAA,SAAAQ,EAAAsnB,GAEA3qB,MAGA60B,EAAA9uB,UAAAgmB,MAAA,SAAAnrB,GACAA,EAAAA,KACA,IACA8pB,GAAA9pB,EAAA8pB,WACAC,EAAA/pB,EAAA+pB,aACAtjB,GAAAzG,EAAAyG,kBAAAiK,QACAK,EAAA/Q,EAAA+Q,IAIA,OAFA3R,MAAA+tB,QAAAhC,MAAArB,EAAAC,EAAAtjB,EAAAsK,GAEA3R,MAGA60B,EAAA9uB,UAAA0oB,iBAAA,WACAzuB,KAAA6C,KAAA,SAAA,KAAAP,EAAAC,EAAAF,OAAAqa,kBAGAmY,EAAA9uB,UAAArC,iBAAA,WACA1D,KAAA6C,KAAA,SAAA,KAAAP,EAAAC,EAAAF,OAAAoa,mBAGAna,EAAAuyB,cAAAA,IxBy8JM,SAASh1B,EAAQD,GyBljKvBC,EAAAD,QAAA,SAAA0C,GAEA,GAAA0yB,GACAzyB,GACA0yB,aAAA,GACAC,aAAA,IACAC,iBAAA,IACAC,mBAAA,GACAC,uBAAA,IAqKA,OAlKAL,GAAA,SAAAvxB,EAAA6xB,EAAA10B,GACA,GAGA20B,GAAAC,EAHArzB,GACA,YACA,SAGA,IAAApB,SAAAu0B,EACA,KAAA,IAAA5Z,WAAA,uBAYA,IATA1b,KAAAmQ,OAAA1M,EAAA9B,GAAA+Y,UAAA,yBAAAjX,EAAApD,IACAL,KAAA8wB,MAAArtB,EACAzD,KAAAy1B,UAAA,KAEA70B,EAAAA,MACA20B,EAAA30B,EAAA20B,UAAA,KACAC,EAAA50B,EAAA40B,cAAA,KAGA,gBAAAF,GACAA,EAAAA,EAAAjkB,kBACG,CAAA,GAAA,gBAAAikB,GAGH,KAAA,IAAA5Z,WAAA,iBAAA4Z,EAFAA,GAAAA,EAAAtjB,WAMA,IAAAsjB,EAAA3M,MAAA,gBACA,KAAA,IAAAjN,WAAA,iBAAA4Z,EAMA,IAJAt1B,KAAAs1B,KAAAA,EAIAC,IAAAjzB,EAAAmJ,MAAAwG,UAAAsjB,GACA,KAAA,IAAA7Z,WAAA,0BAAA6Z,EAeA,IAdGA,EAEAA,EAAAP,EAAAzyB,EAAA0yB,cACHj1B,KAAAmQ,OAAA7I,KAAA,qEAAA0tB,EAAAzyB,EAAA0yB,aAAA,iBACAM,EAAAP,EAAAzyB,EAAA0yB,cACGM,EAAAP,EAAAzyB,EAAA2yB,cACHl1B,KAAAmQ,OAAA7I,KAAA,uEAAA0tB,EAAAzyB,EAAA2yB,aAAA,iBACAK,EAAAP,EAAAzyB,EAAA2yB,cAEAK,EAAA5iB,KAAA+iB,IAAAH,GARAA,EAAAP,EAAAzyB,EAAA4yB,iBAUAn1B,KAAAu1B,SAAAA,EAGAC,IAAAlzB,EAAAmJ,MAAAwG,UAAAujB,GACA,KAAA,IAAA9Z,WAAA,yBAAA8Z,EACGA,GAEAA,EAAAR,EAAAzyB,EAAA6yB,oBACHp1B,KAAAmQ,OAAA7I,KAAA,yEAAA0tB,EAAAzyB,EAAA6yB,mBAAA,iBACAI,EAAAR,EAAAzyB,EAAA6yB,oBAEAI,EAAA7iB,KAAA+iB,IAAAF,GALAA,EAAAR,EAAAzyB,EAAA8yB,uBAOAr1B,KAAAw1B,aAAAA,EAEAx1B,KAAAob,WAAAjZ,IAEA6yB,EAAAjvB,UAAA,GAAAzD,GAAA+C,aAGA2vB,EAAAjvB,UAAA4f,KAAA,SAAA/kB,GACA,GAAAyG,GAAAsK,CAKA,IAHA3R,KAAAy1B,UAAA,WAGAz1B,KAAA8wB,MAAAjN,SAAAvhB,EAAA+uB,QAAA9uB,EAAAirB,kBACAxtB,KAAA8wB,MAAAjN,SAAAvhB,EAAA+uB,QAAA9uB,EAAAozB,uBACA,KAAA,IAAArzB,GAAA4I,WAAA0Y,kBAAA5jB,KAAA8wB,MAAAjN,OAIAjjB,GAAAA,MACAyG,EAAAzG,EAAAyG,aAAAzG,EAAAyG,aAAAiK,WAEAjK,EAAAD,KAAA,wCAEAuK,EAAA,WAAA3R,KAAAs1B,KAAA,OACA3jB,GAAA,aAAA3R,KAAAu1B,SAEAv1B,KAAA+tB,QAAA/tB,KAAA8wB,MAAAJ,OAAAkC,YAAA5yB,KAAAsC,EAAAC,EAAA+b,MACAjX,aAAAA,EACAsK,KAAAA,IAGA3R,KAAA8wB,MAAAjuB,KAAA,OAAA7C,KAAA+tB,QAAA/tB,OAMAg1B,EAAAjvB,UAAAqiB,gBAAA,SAAA/kB,GACA,GAAAC,EAEA,SAAA,GACA,IAAA,cAAoBC,KAAAF,EAAAG,aAEpB,KAEA,KAAA,cAAoBD,KAAAF,EAAAG,aACpBxD,KAAA6C,KAAA,aACA+yB,WAAA,SACAvyB,SAAAA,GAEA,MAEA,SACAC,EAAAhB,EAAAmJ,MAAAmJ,cAAAvR,EAAAG,aACAxD,KAAA6C,KAAA,SAAAQ,EAAAC,KAQA0xB,EAAAjvB,UAAA0oB,iBAAA,WACAzuB,KAAA6C,KAAA,SAAA,KAAAP,EAAAC,EAAAF,OAAAqa,iBACA1c,KAAA8wB,MAAArC,oBAMAuG,EAAAjvB,UAAArC,iBAAA,WACA1D,KAAA6C,KAAA,SAAA,KAAAP,EAAAC,EAAAF,OAAAoa,kBACAzc,KAAA8wB,MAAAptB,oBAMAsxB,EAAAjvB,UAAAorB,cAAA,SAAA9tB,GACArD,KAAA6C,KAAA,SAAAQ,EAAAf,EAAAC,EAAAF,OAAA+a,cACApd,KAAA8wB,MAAAK,cAAA9tB,IAMA2xB,EAAAjvB,UAAA8vB,cAAA,SAAA9H,GACA/tB,KAAAy1B,UAAA,WACAz1B,KAAA+tB,QAAAA,EAEAA,EAAAhC,MAAA,KAEA/rB,KAAAs1B,MAAAt1B,KAAAu1B,SAGAv1B,KAAA8wB,MAAAjuB,KAAA,OAAAkrB,EAAA/tB,MAFAA,KAAAmQ,OAAA7I,KAAA,0CAMA0tB,EAAAzyB,EAAAA,EACAyyB,IzBkkKM,SAASn1B,EAAQD,G0BvvKvBC,EAAAD,QAAA,SAAA0C,EAAA8B,EAAA4wB,GAEA,GAAA3D,GAAAyE,EAAAC,EACAxzB,GAEAyzB,YAAA,EACAC,mBAAA,EACAC,oBAAA,EACAC,uBAAA,EACAC,0BAAA,EACAC,gBAAA,EACAC,yBAAA,EACAX,uBAAA,EACAY,gBAAA,EACAhJ,kBAAA,EACAiJ,kCAAA,GACAC,mBAAA,GACAjJ,iBAAA,GAOA6D,GAAA,SAAAe,GACA,GAAAjwB,IACA,aACA,aACA,OACA,SACA,SACA,QACA,MACA,OACA,SACA,QACA,UAGAnC,MAAA6jB,OAAAthB,EAAAyzB,YACAh2B,KAAA0wB,OAAA,KACA1wB,KAAA02B,gBACA12B,KAAAoyB,oBAAAA,GAAA9vB,EAAAuD,OAAAwF,aAAAsrB,eAEA32B,KAAAkyB,UAAA,EACAlyB,KAAA42B,WAAA,EAGA52B,KAAAmkB,QACA0S,SAAA,KACAC,aAAA,KACAC,eAAA,KACAC,kBAAA,KACAC,YAAA,KACAC,WAAA,MAIAl3B,KAAAm3B,UAAA,KACAn3B,KAAAo3B,QAAA,KACAp3B,KAAAq3B,MAAA,KAGAr3B,KAAAs3B,YAAA,EACAt3B,KAAAu3B,aAAA,EAEAv3B,KAAAw3B,iBACAC,WAEA/tB,OAAA,WACA,MAAA1J,MAAAy3B,QAAA/tB,QAGAguB,UAAA,SAAA5sB,GACA,GACA8E,GAAA,EACAlG,EAAA1J,KAAAy3B,QAAA/tB,MAEA,KAAAkG,EAAelG,EAAAkG,EAAYA,IAC3B,GAAA5P,KAAAy3B,QAAA7nB,GAAA9E,OAAAA,EACA,OAAA,CAGA,QAAA,GAGA6sB,MAAA,WACA,MAAA33B,MAAAy3B,QAAAE,SAGAvwB,KAAA,SAAA0D,GACA9K,KAAAy3B,QAAArwB,MACA0D,KAAAA,KAIA8sB,IAAA,SAAA9sB,GACA,GACA8E,GAAA,EACAlG,EAAA1J,KAAAy3B,QAAA/tB,MAEA,KAAAkG,EAAelG,EAAAkG,EAAYA,IAC3B5P,KAAAy3B,QAAA7nB,GAAA9E,OAAAA,IACA9K,KAAAy3B,QAAAzb,OAAApM,EAAA,GACAlG,IACAkG,OAMA5P,KAAA63B,UAAA,KACA73B,KAAA4rB,OAAAtpB,EAAAC,EAAAwb,UAAAC,YAEAhe,KAAAqb,eAAAlZ,IAGAkvB,EAAAtrB,WACA+xB,KAAA,SAAAT,EAAAz2B,GACA,GAAA00B,GAAAyC,KACAtuB,EAAAzJ,IAIA,IAFAY,EAAAA,MAEAG,SAAAs2B,EACA,KAAA,IAAA3b,WAAA,uBAIA,IAAA1b,KAAA6jB,SAAAthB,EAAAirB,kBAAAxtB,KAAA6jB,SAAAthB,EAAAozB,uBACA,KAAA,IAAArzB,GAAA4I,WAAA0Y,kBAAA5jB,KAAA6jB,OAIA,KAAAwT,GAAA,gBAAAA,IAAA,gBAAAA,KAAAA,EAAArlB,WAAA2W,MAAA,mBACA,KAAA,IAAAjN,WAAA,kBAAA2b,EAKA,KAFAA,EAAAA,EAAArlB,WAAA4B,MAAA,IAEAyjB,EAAA3tB,OAAA,GAA8BquB,EAAA3wB,KAAA,GAAA4tB,GAAAh1B,KAAAq3B,EAAAM,QAAA/2B,GAE9B,IAAAZ,KAAAq3B,MAGA,MADAr3B,MAAAq3B,MAAAr3B,KAAAq3B,MAAAW,OAAAD,GACA/3B,IAGA,IAAAiK,GAAA,WACA,GAAA6tB,GAAAG,CAEA,OAAAxuB,GAAAoa,SAAAthB,EAAAgrB,mBAAA9jB,EAAA4tB,OAAA,IAAA5tB,EAAA4tB,MAAA3tB,QAMAouB,EAAAruB,EAAA4tB,MAAAM,QAEA,MAAArC,EACA2C,EAAA,KAEAH,EAAAj2B,GAAA,SAAA,WAAqC4H,EAAA4tB,MAAA,OACrCS,EAAAnS,KAAA/kB,GACAq3B,EAAAH,EAAAvC,SAAAuC,EAAAtC,kBAIAlzB,GAAA6I,OAAAxH,WAAAsG,EAAAguB,KAfAxuB,EAAA4tB,MAAA,KACAr3B,MAmBA,OAFAA,MAAAq3B,MAAAU,EACA9tB,IACAjK,MAGAk4B,IAAA,SAAAt3B,GACAA,EAAAA,KACA,IAAA8pB,GAAA9pB,EAAA8pB,UAGA,IAAA1qB,KAAA6jB,SAAAthB,EAAAgrB,kBAEA,MADAvtB,MAAAmQ,OAAAkK,MAAA,yDACAra,IAKA,IAFAA,KAAAmQ,OAAAzJ,IAAA,uBAEAgkB,IAAA,IAAAA,GAAAA,GAAA,KACA,KAAA,IAAAhP,WAAA,uBAAAgP,EAKA,OAFA9pB,GAAAwnB,gBAAA,aAEApoB,KACA4yB,YAAAtwB,EAAAC,EAAA6b,IAAAxd,GACAu3B,cAGAC,MAAA,SAAA3tB,EAAA7J,GACAA,EAAAA,KACA,IAAAyG,IAAAzG,EAAAyG,kBAAAiK,QACAijB,EAAA9pB,CAEA,IAAA1J,SAAA0J,EACA,KAAA,IAAAiR,WAAA,uBACK,IAAAjR,YAAAnI,GAAAwzB,qBAAArrB,YAAAnI,GAAAyzB,oBAGL1uB,EAAAD,KAAA,YAAApH,KAAA0B,SACA2F,EAAAD,KAAA,UAAA9E,EAAAmJ,MAAA2J,kBAAApV,KAAA2B,KACA0F,EAAAD,KAAA,cAAAqD,EAAAimB,OAAAoB,cAAA9f,WAAA,aAAAvH,EAAAimB,OAAArwB,GAAAypB,QAAA,eAAArf,EAAAimB,OAAArwB,GAAAqxB,WAAA,iBAAAjnB,EAAAimB,OAAArwB,GAAAoxB,UAAA,SACK,CAIL,GAAAzxB,KAAA6jB,SAAAthB,EAAAirB,iBACA,KAAA,IAAAlrB,GAAA4I,WAAA0Y,kBAAA5jB,KAAA6jB,OAKA,KACApZ,EAAAnI,EAAAsJ,QAAAyH,MAAA5I,EAAA,YAAAxC,KAAAwC,EACO,MAAA3G,GACP9D,KAAAmQ,OAAAgK,MAAA,sCAAA1P,GACAzK,KAAAmQ,OAAAgK,MAAA,2CAKA,GADA1P,EAAAzK,KAAA2B,GAAA4R,gBAAA9I,IACAA,EACA,KAAA,IAAAiR,WAAA,mBAAA6Y,EAGAltB,GAAAD,KAAA,YAAApH,KAAA0B,SACA2F,EAAAD,KAAA,UAAA9E,EAAAmJ,MAAA2J,kBAAApV,KAAA2B,KACA0F,EAAAD,KAAA,aAAAqD,GAaA,MATAzK,MAAA4yB,YAAAtwB,EAAAC,EAAAuc,OACAzX,aAAAA,EACAsK,KAAA/Q,EAAA+Q,KACAyW,gBAAA,eAGA3d,EAAA6hB,OAAA3D,MAAA,YACA3oB,KAAAuyB,YAEAvyB,MAGAq4B,YAAA,SAAAC,GACA,MAAA,UAAAA,EAAAvK,GAEA,GAAAtjB,GAAAsjB,EAAAnF,YAAA,YAAA3gB,GACA,KAAAwC,EAAA6hB,OAAA3D,MAAA,WAAA,CACA,GAAA4P,GAAA9tB,EAAAuH,UAMA,aALA,mBAAA5N,IAAA,kBAAAA,GAAAo0B,KACAp0B,EAAAo0B,KAAAD,GAEAv4B,KAAAmQ,OAAA7I,KAAA,6DAAAixB,IAKAj2B,EAAAoJ,MAAA+sB,OAAAC,qBAAA14B,KAMA,IAAA24B,GAAA34B,KAAA2B,GAAAi3B,OAAA7K,EAAAnF,YAAA,YAAA3gB,KACAsI,MAAAvQ,KAAAq0B,WAGAiE,GAAA/3B,KAAAP,KAAA+tB,EAAA4K,GAEA34B,KAAAuyB,aACKzwB,KAAA9B,KAAAs4B,IAGL1F,YAAA,SAAA5K,EAAApnB,GACAA,EAAAA,KACA,IAAA6I,GAAAzJ,KAEA+tB,EAAA,GAAAzrB,GAAAioB,gBACAvC,EACAhoB,KAAA0wB,OAAAoB,cACA9xB,KAAA2B,IAEAooB,KAAAnpB,EAAAmpB,OAAA/pB,KAAA0wB,OAAAU,cAAA,GACAtH,QAAA9pB,KAAA0wB,OAAArwB,GAAAypB,QACAuB,SAAArrB,KAAA0wB,OAAAkB,UACAnI,SAAAzpB,KAAA0wB,OAAArwB,GAAAoxB,UACAxG,OAAAjrB,KAAA0wB,OAAAmB,WACAlI,OAAA3pB,KAAA0wB,OAAArwB,GAAAqxB,WACA9G,UAAA5qB,KAAA0wB,OAAA9F,UACAF,WAAA9pB,EAAA8pB,WACAC,aAAA/pB,EAAA+pB,cAEA/pB,EAAAyG,iBACAzG,EAAA+Q,KAqBA,OAlBA,IAAArP,GAAAmuB,eACA1C,QAAAA,EACAU,iBAAA,WACAhlB,EAAAglB,oBAEA/qB,iBAAA,WACA+F,EAAA/F,oBAEA0kB,gBAAAxnB,EAAAwnB,iBAAA,SAAA/kB,GACAoG,EAAAovB,yBAAAx1B,KAEKrD,KAAA2B,IAAAgkB,OAGL3lB,KAAAub,WAAAyM,EAAArgB,gBACA3H,KAAA6C,KAAAmlB,EAAArgB,cAAAomB,GAGA/tB,MAGAomB,MAAA,WACA,GAAAxW,EAEA,IAAA5P,KAAA6jB,SAAAthB,EAAAgrB,kBACA,MAAAvtB,KAGAA,MAAAmQ,OAAAzJ,IAAA,0BAAA1G,KAAAK,IAGAL,KAAAmyB,cACAnyB,KAAAmyB,aAAA/L,OAMA,KAAAxW,IAAA5P,MAAAmkB,OACA7hB,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAAvU,GAMA5P,MAAA0wB,SACA1wB,KAAA0wB,OAAA6B,kBACAvyB,MAAA0wB,OAIA,KAAA9gB,IAAA5P,MAAA02B,aACA12B,KAAA02B,aAAA9mB,GAAA2iB,kBACAvyB,MAAA02B,aAAA9mB,EAMA,OAHA5P,MAAA6jB,OAAAthB,EAAAgrB,wBAEAvtB,MAAA2B,GAAAm3B,SAAA94B,KAAAK,IACAL,MAGA+4B,aAAA,SAAApV,EAAA/W,EAAAosB,GACA,GAAAtI,GAAAuI,EACAxH,EAAA9N,EAAA,QAAA/W,EAAA,SAAA,YACA8kB,EAAA/N,EAAA,QAAA/W,EAAA,WAAA,UACAvM,EAAAsjB,EAAAmG,QAAA2H,EAAAC,CAKA,IAHAuH,EAAAj5B,KAAA02B,aAAAr2B,GAGA24B,EACA,MAAAC,IACA,GAEAA,EAAA,GAAA32B,GAAAivB,OAAAvxB,KAAA2jB,EAAA/W,EAAAtK,EAAAivB,OAAAhvB,EAAAivB,cAGAyH,EAAA5e,OACAra,KAAAmQ,OAAAkK,MAAA4e,EAAA5e,OACAra,KAAAk5B,OAAAvV,EAAArhB,EAAAC,EAAAF,OAAAsa,iBACA,IAEA3c,KAAA02B,aAAAr2B,GAAA44B,GACA,GAOA,IAAAA,EAAA,CACAA,EAAA3G,OAAA3O,EAAA/W,GACA5M,KAAA0wB,OAAAuI,QACAj5B,MAAA02B,aAAAr2B,EACA,KAAA,GAAA84B,KAAAn5B,MAAA02B,aACA12B,KAAA02B,aAAAyC,GAAA5G,kBACAvyB,MAAA02B,aAAAyC,EAEA,QAAA,EAMA,MAFAzI,GAAA,GAAApuB,GAAAivB,OAAAvxB,KAAA2jB,EAAA/W,GAEA8jB,EAAArW,OACAra,KAAAmQ,OAAAkK,MAAAqW,EAAArW,OACAra,KAAAk5B,OAAAvV,EAAArhB,EAAAC,EAAAF,OAAAsa,iBACA,IAEA3c,KAAA2pB,OAAAhG,EAAAgG,OACA3pB,KAAA0wB,OAAAA,GACA,IAUA0I,kBAAA,WACA,MAAAp5B,MAAAmyB,aAAAgC,YACAn0B,KAAA0wB,OAAAM,oBACAhxB,KAAA0wB,OAAAO,mBAMA5mB,KAAA,SAAAzJ,GACA,GAAAy4B,GAAAr5B,KAAAmyB,aAAA9nB,KAAAzJ,EACAy4B,IACAr5B,KAAAs5B,OAAAD,IAOA9uB,OAAA,SAAA3J,GACA,GAAAy4B,GAAAr5B,KAAAmyB,aAAA5nB,OAAA3J,EACAy4B,IACAr5B,KAAAu5B,SAAAF,IAOAnvB,KAAA,WAEA,GAAAlK,KAAA6jB,SAAAthB,EAAAozB,wBAAA31B,KAAA6jB,SAAAthB,EAAAirB,iBACA,KAAA,IAAAlrB,GAAA4I,WAAA0Y,kBAAA5jB,KAAA6jB,OAMA,OAHA7jB,MAAAmyB,aAAAjoB,OAGAlK,KAAAo5B,yBAWKp5B,KAAAs3B,cAAA,IAILt3B,KAAAw5B,OAAA,SAEAx5B,KAAAy5B,cACAC,OAAA,SAAA/nB,GAWA,MAPA,0CAAApO,KAAAoO,IAGAA,EAAAA,EAAAV,QAAA,kBAAA,kBACAU,EAAAA,EAAAV,QAAA,kBAAA,mBAHAU,EAAAA,EAAAV,QAAA,kBAAA,oBAMAU,YAxBA3R,KAAAw3B,gBAAAE,UAAA,UACA13B,KAAAw3B,gBAAAI,IAAA,UACO53B,KAAAw3B,gBAAAE,UAAA,SACP13B,KAAAw3B,gBAAApwB,KAAA,UA6BA+C,OAAA,WAEA,GAAAnK,KAAA6jB,SAAAthB,EAAAozB,wBAAA31B,KAAA6jB,SAAAthB,EAAAirB,iBACA,KAAA,IAAAlrB,GAAA4I,WAAA0Y,kBAAA5jB,KAAA6jB,OAKA,OAFA7jB,MAAAmyB,aAAAhoB,SAEAnK,KAAAo5B,yBAWKp5B,KAAAs3B,cAAA,IAILt3B,KAAA25B,SAAA,SAEA35B,KAAAy5B,sBAZAz5B,KAAAw3B,gBAAAE,UAAA,QACA13B,KAAAw3B,gBAAAI,IAAA,QACO53B,KAAAw3B,gBAAAE,UAAA,WACP13B,KAAAw3B,gBAAApwB,KAAA,YAeApE,SAAA,WACA,OACA42B,MAAA55B,KAAAs3B,WACAzmB,OAAA7Q,KAAAu3B,cAQAsC,gBAAA,SAAA9L,GACA,GAAAtkB,GAAAzJ,KACAw0B,EAAAzG,EAAAvF,UAAA,gBACAte,GAAA,CAEA,IAAA6jB,EAAApc,KAAA,CACA,GAAA,oBAAA6iB,EAGA,MAFAx0B,MAAAmQ,OAAA7I,KAAA,4BACAymB,GAAAhC,MAAA,IAKA7hB,GAAA,wBAAA3G,KAAAwqB,EAAApc,MAEA3R,KAAAmyB,aAAAmC,eACAvG,EAAApc,KAKA,WACAlI,EAAA0oB,aAAAiC,eACA,SAAAziB,GACAoc,EAAAhC,MAAA,IAAA,MAAA,YAAAtiB,EAAA/H,SAAAiQ,EACA,WACAlI,EAAAoa,OAAAthB,EAAAozB,uBACAlsB,EAAAqwB,kBAAA/L,EAAApc,GACAlI,EAAAswB,cAEAtwB,EAAA8tB,cAAArtB,EACAT,EAAAkwB,SAAA,WACmBlwB,EAAA8tB,aAAArtB,GACnBT,EAAA+vB,OAAA,aAIA,WACAzL,EAAAhC,MAAA,MAEAtiB,EAAA4qB,YAOA,SAAAvwB,GACA2F,EAAA0G,OAAAkK,MAAAvW,GACAiqB,EAAAhC,MAAA,SAMA0N,aAAA,SAAA74B,GACAA,EAAAA,KAEA,IACA6I,GAAAzJ,KACAqH,GAAAzG,EAAAyG,kBAAAiK,QACA0oB,EAAAp5B,EAAAo5B,kBACAN,EAAA94B,EAAA84B,QAAA,IAEAM,GAAAC,UACAj6B,KAAAk6B,kBAAAF,EAAAC,UAEAj6B,KAAAk6B,kBAAA,WACA53B,EAAA6I,OAAA+a,aAAAzc,EAAA0a,OAAA0S,UACAv0B,EAAA6I,OAAA+a,aAAAzc,EAAA0a,OAAA4S,gBACAttB,EAAAoa,OAAAthB,EAAAirB,kBAGAwM,EAAAd,OACAl5B,KAAAm6B,eAAAH,EAAAd,OAEAl5B,KAAAm6B,eAAA,aAGA9yB,EAAAD,KAAA,YAAApH,KAAA0B,SACA2F,EAAAD,KAAA,UAAA9E,EAAAmJ,MAAA2J,kBAAApV,KAAA2B,KACA0F,EAAAD,KAAA,iCAEApH,KAAAooB,gBAAApoB,KAAAo6B,wBAEAp6B,KAAAmyB,aAAAiC,eACA,SAAAziB,GACA+nB,IACA/nB,EAAA+nB,EAAA/nB,IAGAlI,EAAAinB,OAAAkC,YAAAnpB,EAAAnH,EAAAC,EAAAgc,QACAlX,aAAAA,EACAsK,KAAAA,KAGA,WACAlI,EAAA2vB,qBACA3vB,EAAAynB,oBAEAznB,EAAA0wB,kBAEA1wB,EAAA4qB,YAIAvM,eAAA,SAAAiG,GACA,OAAAA,EAAA/F,QACA,IAAA1lB,GAAAC,EAAA6b,IACA2P,EAAAhC,MAAA,KACA/rB,KAAA6jB,SAAAthB,EAAAirB,mBACAxtB,KAAA6C,KAAA,MAAAkrB,GACA/tB,KAAAm4B,WAAApK,EAAAzrB,EAAAC,EAAAF,OAAA+b,KAEA,MACA,KAAA9b,GAAAC,EAAAgc,OACAve,KAAA6jB,SAAAthB,EAAAirB,mBACAxtB,KAAAmQ,OAAAzJ,IAAA,sBAGAqnB,EAAAhC,MAAA,IAAA,MAAA,yDAEA,MACA,KAAAzpB,GAAAC,EAAA+b,KACA,GAAAte,KAAA6jB,SAAAthB,EAAAirB,kBAAAxtB,KAAA6jB,SAAAthB,EAAAozB,uBAAA,CACA,GAAAhkB,GAAA2jB,EAAAC,EACAf,EAAAzG,EAAAvF,UAAA,gBACA6R,EAAA,2CACAC,EAAA,uCAEA9F,KACAA,EAAA7L,MAAA,8BACAoF,EAAApc,OACAA,EAAAoc,EAAApc,KAAAiC,MAAA,OAAA,GACA,IAAAjC,EAAAjI,SACA2wB,EAAA92B,KAAAoO,EAAA,MACA2jB,EAAA3jB,EAAA,GAAAV,QAAAopB,EAAA,OAEAC,EAAA/2B,KAAAoO,EAAA,MACA4jB,EAAAljB,SAAAV,EAAA,GAAAV,QAAAqpB,EAAA,MAAA,OAKA,GAAAtF,GAAAh1B,KAAAs1B,GAAoCC,SAAAA,IAAmBM,cAAA9H,IAEvDA,EAAAhC,MAAA,IAAA,MAAA,oCAIA,KACA,KAAAzpB,GAAAC,EAAAuc,MACA,GAAA9e,KAAA6jB,SAAAthB,EAAAirB,iBAAA,CACAxtB,KAAAmQ,OAAAzJ,IAAA,kBACAqnB,EAAAhC,MAAA,IAAA,WACA,IACAwO,GAAAv6B,KAAAyV,cAAA,SACA+kB,EAAAD,EACA,qBAEA,sBAGAv6B,MAAA4yB,YAAAtwB,EAAAC,EAAAkc,QACApX,cACA,eACA,iCACA,iCAEAsK,KAAA6oB,EACApS,gBAAA,eAGAmS,GACAv6B,KAAA6C,KAAA,QAAAkrB,MAWAqM,wBAAA,SAAA/2B,GACA,GAAAoG,GAAAzJ,KACAw0B,EAAAnxB,EAAAmlB,UAAA,eAEA,IAAAxoB,KAAA6jB,SAAAthB,EAAAgrB,kBAIA,QAAA,GACA,IAAA,cAAsBhqB,KAAAF,EAAAG,aACtB,KACA,KAAA,cAAsBD,KAAAF,EAAAG,aAKtB,GAJAxD,KAAA6jB,OAAAthB,EAAAirB,iBAEAxtB,KAAA4yB,YAAAtwB,EAAAC,EAAA4b,KAAoC4L,KAAA1mB,EAAA0mB,QAEpC1mB,EAAAsO,KAAA,CACA3R,KAAAm6B,gBACA,OACS,GAAA,oBAAA3F,EAAA,CACTx0B,KAAAm6B,gBACA,OAIAn6B,KAAAmyB,aAAAmC,eACAjxB,EAAAsO,KAKA,WACAlI,EAAAywB,qBAMA,WACAzwB,EAAA0wB,kBAGA,MACA,SACAn6B,KAAAm6B,mBAIAM,mBAAA,SAAAp3B,EAAAG,EAAA4mB,GACA,GAAA/iB,KAeA,OAbA7D,KACA4mB,EAAAA,GAAA9nB,EAAAC,EAAAE,cAAAe,IAAA,GACA6D,EAAAD,KAAA,sBAAsC5D,EAAA,WAA0B4mB,EAAA,OAIhEpqB,KAAA0wB,QAAA1wB,KAAA+4B,aAAA11B,EAAA,UACArD,KAAA4yB,YAAAtwB,EAAAC,EAAA4b,KAAkC4L,KAAA1mB,EAAA0mB,OAClC/pB,KAAA4yB,YAAAtwB,EAAAC,EAAA6b,KACA/W,aAAAA,KAIArH,MAQA85B,kBAAA,SAAA/L,EAAApc,GACA,GAAAlI,GAAAzJ,KACAi4B,EAAA31B,EAAA6I,OAAA6Y,EAEAhkB,MAAAmkB,OAAA4S,eAAAz0B,EAAA6I,OAAAxH,WAAA,QAAA+2B,KACAjxB,EAAAoa,SAAAthB,EAAAozB,yBAIAlsB,EAAA0G,OAAAzJ,IAAA,gDAEAqnB,EAAAhC,MAAA,IAAA,MAAA,YAAAtiB,EAAA/H,SAAAiQ,GAEAsmB,EAAAtlB,KAAAgoB,IAAA,EAAA1C,EAAA31B,EAAA6I,OAAA8Y,IAEAxa,EAAA0a,OAAA4S,eAAAz0B,EAAA6I,OAAAxH,WAAA+2B,EAAAzC,KACKA,IAQL8B,YAAA,WACA,GAAAtwB,GAAAzJ,IAEAA,MAAAmkB,OAAA0S,SAAAv0B,EAAA6I,OAAAxH,WAAA,WACA8F,EAAAoa,SAAAthB,EAAAozB,yBACAlsB,EAAA0G,OAAAzJ,IAAA,wEACApE,EAAA6I,OAAA+a,aAAAzc,EAAA0a,OAAA4S,gBACAttB,EAAAmpB,YAAAtwB,EAAAC,EAAA6b,KACA3U,EAAA0uB,WAAA,KAAA71B,EAAAC,EAAAF,OAAAqb,UAEKpb,EAAA6I,OAAAoZ,UAML2M,kBAAA,WACA,GAAA0J,GAAA56B,KAAAw3B,gBAAAG,OAEAiD,IAAA56B,KAAA46B,EAAA9vB,OAIA9K,KAAA46B,EAAA9vB,SAGApH,iBAAA,WACA1D,KAAA6jB,SAAAthB,EAAAirB,iBACAxtB,KAAAm4B,WAAA,KAAA71B,EAAAC,EAAAF,OAAAoa,kBACKzc,KAAA6jB,SAAAthB,EAAAgrB,mBACLvtB,KAAAk5B,OAAA,KAAA52B,EAAAC,EAAAF,OAAAoa,mBAIAgS,iBAAA,WACAzuB,KAAA6jB,SAAAthB,EAAAirB,iBACAxtB,KAAAm4B,WAAA,KAAA71B,EAAAC,EAAAF,OAAAqa,iBACK1c,KAAA6jB,SAAAthB,EAAAgrB,mBACLvtB,KAAAk5B,OAAA,KAAA52B,EAAAC,EAAAF,OAAAqa,kBAIAyU,cAAA,SAAA9tB,GACArD,KAAA6jB,SAAAthB,EAAAirB,iBACAxtB,KAAAm4B,WAAA90B,EAAAf,EAAAC,EAAAF,OAAA+a,cACKpd,KAAA6jB,SAAAthB,EAAAgrB,mBACLvtB,KAAAk5B,OAAA71B,EAAAf,EAAAC,EAAAF,OAAA+a,eAOAoc,OAAA,SAAA5D,GACA51B,KAAA,UAAA41B,EAAA,aAAA,gBAAA,EACA51B,KAAA6C,KAAA,QAAuB+yB,WAAAA,KAMvB+D,SAAA,SAAA/D,GACA51B,KAAA,UAAA41B,EAAA,aAAA,gBAAA,EACA51B,KAAA6C,KAAA,UAAyB+yB,WAAAA,KAMzB0D,OAAA,SAAA14B,GACAZ,KAAA6C,KAAA,SACA4N,MAAA7P,EAAA6P,MACAC,MAAA9P,EAAA8P,SAOA6oB,SAAA,SAAA34B,GACAZ,KAAA6C,KAAA,WACA4N,MAAA7P,EAAA6P,MACAC,MAAA9P,EAAA8P,SAIAwoB,OAAA,SAAA71B,EAAAC,GAEA,MADAtD,MAAAomB,QACApmB,KAAA6C,KAAA,SAAAQ,EAAAC,IAGAu3B,SAAA,SAAAx3B,EAAAC,GAEA,MADAtD,MAAAomB,QACApmB,KAAA6C,KAAA,WACAQ,GAAA,KACAC,IAIAw3B,SAAA,WAEA,MADA96B,MAAAomB,QACApmB,KAAA6C,KAAA,WAGAk4B,SAAA,SAAA13B,EAAAC,GAKA,MAJAA,GAAAA,GAAAD,GAAAf,EAAAC,EAAAE,cAAAY,EAAAG,cAAA,GAEAxD,KAAAm3B,UAAA,GAAAlc,MAEAjb,KAAA6C,KAAA,WAAAQ,EAAAC,IAGA60B,WAAA,SAAAxU,EAAArgB,GAIA,MAHAtD,MAAAo3B,QAAA,GAAAnc,MAEAjb,KAAAomB,QACApmB,KAAA6C,KAAA,cACA8gB,QAAAA,GAAA,KACArgB,MAAAA,GAAA,QAIA03B,WAAA,SAAAjN,GACA,MAAA/tB,MAAA6C,KAAA,cAAoCkrB,QAAAA,MAIpCsD,EAAA9uB,EAAAA,EACAD,EAAA+uB,QAAAA,EAGAyE,EAAA,SAAAn0B,EAAAosB,GA0CA,QAAAkN,GAAAC,EAAAz6B,GACAstB,EAAAzD,UAAA4Q,IAAAnN,EAAAvF,UAAA0S,GAAAvzB,cAAAiK,QAAA,WAAA,IACAnI,EAAAmiB,OAAAnrB,GA2BA,QAAA06B,KACA,GAAAv6B,IAAmByG,cAAA,YAAAoC,EAAA/H,SAEnB+H,GAAAmiB,SAAAtpB,EAAAC,EAAAwb,UAAAG,UACAzU,EAAAqrB,SAAAl0B,GAEA6I,EAAAoa,OAAAthB,EAAA6zB,0BAGA3sB,EAAA0a,OAAA6S,kBAAA10B,EAAA6I,OAAAxH,WAAA,WACAoqB,EAAAhC,MAAA,KACAtiB,EAAAyvB,OAAAnL,EAAAzrB,EAAAC,EAAAF,OAAAmb,YACK/T,EAAA9H,GAAAqkB,cAAAoV,iBAKL5H,IACA/pB,EAAA0a,OAAA2S,aAAAx0B,EAAA6I,OAAAxH,WAAA,WACA8F,EAAAoa,SAAAthB,EAAA6zB,4BACArI,EAAAhC,MAAA,KACAtiB,EAAAyvB,OAAAnL,EAAAzrB,EAAAC,EAAAF,OAAAob,WAEO+V,IAGP/pB,EAAA5G,KAAA,SAAAkrB,GAhGA,GAAAyF,GACA/pB,EAAAzJ,KACAw0B,EAAAzG,EAAAvF,UAAA,gBACA6S,EAAAtN,EAAAnF,YAAA,sBAGA,KAAAyS,GAAA,oBAAA7G,GAAA6G,GAAA,WAAAA,EAAAzuB,KACA5M,KAAAs7B,WAAAvN,EAAApc,KACA3R,KAAAu7B,WAAA/G,MACG,IAAA,oBAAAA,GAAA6G,GAAA,YAAAA,EAAAzuB,KAGH,WAFAmhB,GAAAhC,MAAA,IA6CA,OAvCAzpB,GAAAoJ,MAAA8vB,QAAAC,4BAAA1N,GACAzrB,EAAAoJ,MAAAgwB,YAAAC,SAAA5N,GAEAzrB,EAAAmJ,MAAA8D,QAAAvP,KAAAsC,EAAAuyB,eAAAlzB,EAAAosB,IACAzrB,EAAAmJ,MAAA8D,QAAAvP,KAAAsC,EAAA+uB,SAAA1vB,EAAAqkB,cAAAoM,sBAEApyB,KAAA6jB,OAAAthB,EAAA4zB,uBACAn2B,KAAAypB,SAAAsE,EAAAtE,SACAzpB,KAAAK,GAAA0tB,EAAAjE,QAAA9pB,KAAAypB,SACAzpB,KAAA+tB,QAAAA,EACA/tB,KAAA0B,QAAA1B,KAAA2B,GAAAD,QAAAsQ,WAEAhS,KAAA64B,yBAAA,aAEA74B,KAAAmQ,OAAAxO,EAAA+Y,UAAA,0BAAA1a,KAAAK,IAGAL,KAAA2B,GAAAm3B,SAAA94B,KAAAK,IAAAL,KAGA+tB,EAAAzD,UAAA,aACAkJ,EAAA,IAAAzF,EAAAvF,UAAA,YASAyS,EAAA,UAAA34B,EAAAC,EAAAwb,UAAAG,UACA+c,EAAA,YAAA34B,EAAAC,EAAAwb,UAAAE,WAKA8P,EAAApE,OAAArnB,EAAAmJ,MAAAoH,SAGA7S,KAAA+4B,aAAAhL,EAAA,OAAA,IAMA/tB,KAAAmyB,aAAAnyB,KAAAoyB,oBAAApyB,MACA47B,gBAAqBC,WAAcC,qBAAA,YAGnC97B,KAAAmyB,cAAAnyB,KAAAmyB,aAAA4J,mBACA/7B,KAAA+7B,iBAAA/7B,KAAAmyB,aAAA4J,iBAAAj6B,KAAA9B,KAAAmyB,cACAnyB,KAAAg8B,gBAAAh8B,KAAAmyB,aAAA6J,gBAAAl6B,KAAA9B,KAAAmyB,qBAgCApE,EAAApc,MAAA3R,KAAAs7B,WACAh5B,EAAA6I,OAAAxH,WAAAw3B,EAAA,IAEAn7B,KAAAkyB,UAAA,EACAlyB,KAAAmyB,aAAAmC,eACAvG,EAAApc,KAKAwpB,EAKA,SAAAr3B,GACA2F,EAAA0G,OAAA7I,KAAA,eACAmC,EAAA0G,OAAA7I,KAAAxD,GACAiqB,EAAAhC,MAAA,cA7DAgC,GAAAhC,MAAA,IAAA,iCAmEA+J,EAAA/vB,WACA7B,OAAA,SAAAtD,GAEA,GAAAZ,KAAA6jB,SAAAthB,EAAAgrB,kBACA,KAAA,IAAAjrB,GAAA4I,WAAA0Y,kBAAA5jB,KAAA6jB,OAMA,OAHA7jB,MAAAmQ,OAAAzJ,IAAA,wBAEApE,EAAAuyB,cAAA9uB,UAAA7B,OAAA4L,MAAA9P,MAAAY,IACAZ,KAAAm4B,cAGA5F,UAAA,SAAA3xB,GACAA,EAAAA,KAEA,IAGA8vB,GAFArpB,GAAAzG,EAAAyG,kBAAAiK,QACAK,EAAA/Q,EAAA+Q,KAEAlI,EAAAzJ,IAqEA,OAnEAA,MAAA6jB,SAAAthB,EAAAozB,wBACA31B,KAAA+tB,QAAAjC,mBAAAsC,QAAA9rB,EAAAkuB,aAAAjuB,EAAAgrB,mBACAmD,EAAA1wB,KAAA0wB,OAEA1wB,KAAA8nB,eAAA,SAAAiG,GACAA,EAAA/F,SAAA1lB,EAAAC,EAAA4b,MACAne,KAAA+tB,QAAAzrB,EAAAC,EAAA6b,KACA/W,aAAAA,EACAsK,KAAAA,IAEA+e,EAAA6B,cAIAvyB,KAAA+tB,QAAAjC,mBAAAjqB,GAAA,eAAA,WACA7B,KAAAouB,QAAA9rB,EAAAkuB,aAAAjuB,EAAAgrB,oBACAvtB,KAAA+tB,QAAA,GAAAzrB,GAAAioB,gBACAjoB,EAAAC,EAAA6b,IACApe,KAAA0wB,OAAAoB,cACA9xB,KAAA2B,IAEAooB,KAAA/pB,KAAA0wB,OAAAU,cAAA,EACAtH,QAAA9pB,KAAA0wB,OAAArwB,GAAAypB,QACAuB,SAAArrB,KAAA0wB,OAAAkB,UACAnI,SAAAzpB,KAAA0wB,OAAArwB,GAAAoxB,UACAxG,OAAAjrB,KAAA0wB,OAAAmB,WACAlI,OAAA3pB,KAAA0wB,OAAArwB,GAAAqxB,WACA9G,UAAA5qB,KAAA0wB,OAAA9F,WAEAvjB,EACAsK,GAGA,GAAArP,GAAAmuB,eAEA1C,QAAA/tB,KAAA+tB,QACAU,iBAAA,WACAhlB,EAAAglB,oBAEA/qB,iBAAA,WACA+F,EAAA/F,oBAEA0kB,gBAAA,cAIApoB,KAAA2B,IACAgkB,OACA+K,EAAA6B,eAIAvyB,KAAA6C,KAAA,MAAA7C,KAAA+tB,SACA/tB,KAAAm4B,aAGAn4B,KAAA0wB,OAAAA,EAGA1wB,KAAA2B,GAAA0wB,QAAA3B,EAAArwB,GAAA2R,YAAA0e,GAEK1wB,KAAA6jB,SAAAthB,EAAAirB,iBACLxtB,KAAAk4B,IAAAt3B,GAEAZ,KAAAkE,OAAAtD,GAGAZ,MAMA80B,SAAA,SAAAl0B,GAiBA,QAAAq7B,KACAvR,EAAA9pB,EAAA8pB,YAAA,IAGA1qB,KAAA6jB,OAAAthB,EAAA+zB,yBACAjvB,EAAAD,KAAA,YAAApH,KAAA0B,SACA2F,EAAAD,KAAA,mBACAC,EAAAD,KAAA,SAAAuL,KAAAwC,MAAA,IAAAxC,KAAAC,WAGA5S,KAAAq0B,UAAAzzB,EAAA2P,MAGAvQ,KAAAmyB,aAAAiC,eAEA,SAAAziB,GACA,IAAA3R,KAAAk8B,YAAAl8B,KAAA6jB,SAAAthB,EAAAgrB,kBAAA,CAIAvtB,KAAA63B,UAAAlmB,EACA3R,KAAAA,KAAAkyB,SAAA,YAAA,aAAA,CAGA,IAAA+F,GAAA31B,EAAA6I,OAAA6Y,EACAhkB,MAAAmkB,OAAA8S,YAAA30B,EAAA6I,OAAAxH,WAAA,QAAAw4B,KACAn8B,KAAA+tB,QAAAhC,MAAArB,EAAA,KAAArjB,EAAAsK,GACAsmB,GAAA,EACAj4B,KAAAmkB,OAAA8S,YAAA30B,EAAA6I,OAAAxH,WAAAw4B,EAAAr6B,KAAA9B,MAAAi4B,IACWn2B,KAAA9B,MAAAi4B,GAGXj4B,KAAAmkB,OAAA+S,WAAA50B,EAAA6I,OAAAxH,WAAA,WACA3D,KAAA6jB,SAAAthB,EAAA+zB,2BAIAt2B,KAAAmQ,OAAAzJ,IAAA,yCACApE,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAA8S,aACAj3B,KAAA+tB,QAAAhC,MAAA,KACA/rB,KAAAm4B,WAAA,KAAA71B,EAAAC,EAAAF,OAAAsb,YACW7b,KAAA9B,MAAA,GAAAsC,EAAA6I,OAAA6Y,IAGX3gB,EAAArD,KAAA+tB,QAAAhC,MAAArB,EAAAC,EAAAtjB,EAAAsK,GACA3R,KAAA6C,KAAA,WAAAQ,EAAAsnB,KACS7oB,KAAA9B,MAGT,WACAA,KAAAk5B,OAAA,KAAA52B,EAAAC,EAAAF,OAAAib,eACSxb,KAAA9B,MAGTY,EAAA2P,OAGA,QAAA6rB,KACA/4B,EAAArD,KAAA+tB,QAAAhC,MAAArB,EAAAC,EAAAtjB,EAAAsK,GACA3R,KAAA6C,KAAA,WAAAQ,EAAAsnB,GA3EA/pB,EAAAA,KACA,IAKAyC,GAJAqnB,EAAA9pB,EAAA8pB,YAAA,IACAC,EAAA/pB,EAAA+pB,aACAtjB,GAAAzG,EAAAyG,kBAAAiK,QACAK,EAAA/Q,EAAA+Q,IAGA,IAAA,IAAA+Y,GAAAA,EAAA,IACA,KAAA,IAAAhP,WAAA,uBAAAgP,EAGA,OAAA1qB,MAAAk8B,YAAAl8B,KAAA6jB,SAAAthB,EAAAgrB,kBACAvtB,MAiEA,MAAAY,EAAA8pB,aACA1qB,KAAA4rB,SAAAtpB,EAAAC,EAAAwb,UAAAG,UACAle,KAAA4rB,SAAAtpB,EAAAC,EAAAwb,UAAAE,WAAArd,EAAAgrB,QACA5rB,KAAA4rB,SAAAtpB,EAAAC,EAAAwb,UAAAE,WAAAje,KAAA2B,GAAAqkB,cAAA4F,SAAAtpB,EAAAC,EAAAwb,UAAAG,UACA+d,EAAAnsB,MAAA9P,MAEAo8B,EAAAtsB,MAAA9P,MAEAA,OAMA+0B,OAAA,SAAAn0B,GACAA,EAAAA,MACAA,EAAA0B,EAAAmJ,MAAA4E,sBAAAzP,GACA0B,EAAAmJ,MAAAsE,gBAAAnP,EAAA,QAAA,oBAAA,EAAAZ,KAAAmQ,OAAAnQ,KAAA2B,GAAAqkB,cAAAzV,OACAvQ,KAAAq0B,UAAAzzB,EAAA2P,KAGA,IAEA9G,GAAAzJ,KACA+tB,EAAA/tB,KAAA+tB,QACA1mB,GAAAzG,EAAAyG,kBAAAiK,QAEA+qB,EAAA,SAAA1qB,GACA,GACAtO,GAEAi5B,EAAA,WACA7yB,EAAAoa,OAAAthB,EAAAozB,uBAEAlsB,EAAAqwB,kBAAA/L,EAAApc,GACAlI,EAAAswB,eAIAwC,EAAA,WACA9yB,EAAAyvB,OAAA,KAAA52B,EAAAC,EAAAF,OAAAoa,kBASAhT,GAAA0oB,aAAAvhB,SAEAvJ,EAAAD,KAAA,YAAAqC,EAAA/H,SAEA+H,EAAAyoB,SAGAzoB,EAAAmtB,WAAA,EAFAntB,EAAAyoB,UAAA,EAIA7uB,EAAA0qB,EAAAhC,MAAA,IAAA,KAAA1kB,EACAsK,EACA2qB,EACAC,GAEA9yB,EAAAoa,SAAAthB,EAAAgrB,mBACA9jB,EAAAsxB,SAAA13B,EAAAf,EAAAC,EAAAE,cAAA,OAIA+5B,EAAA,WACA/yB,EAAAoa,SAAAthB,EAAAgrB,mBAMA9jB,EAAAyvB,OAAA,KAAA52B,EAAAC,EAAAF,OAAAib,cAIA,IAAAtd,KAAA6jB,SAAAthB,EAAA+zB,yBAEA,MADAt2B,MAAA6jB,OAAAthB,EAAAi0B,kCACAx2B,IACK,IAAAA,KAAA6jB,SAAAthB,EAAA6zB,0BACLp2B,KAAA6jB,OAAAthB,EAAA8zB,oBACK,IAAAr2B,KAAA6jB,SAAAthB,EAAAk0B,mBACL,KAAA,IAAAn0B,GAAA4I,WAAA0Y,kBAAA5jB,KAAA6jB,OAIA,OAAA7jB,MAAA+4B,aAAAhL,EAAA,QAKAzrB,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAA6S,mBAoCAh3B,KAAA6jB,SAAAthB,EAAAk0B,mBACA4F,IAEAr8B,KAAAmyB,aAAAiC,eACAiI,EACAG,EACA/yB,EAAA4qB,WAIAr0B,OAlDA+tB,EAAAhC,MAAA,IAAA,gCACA/rB,OAoDA8nB,eAAA,SAAAiG,GAIA,QAAA0O,KACA,GAAAjI,EAEAlyB,GAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAA0S,UACAv0B,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAA4S,gBACA/2B,KAAA6jB,OAAAthB,EAAAirB,iBACAxtB,KAAAuK,SAGAiqB,EAAAzG,EAAAvF,UAAA,gBACA,oBAAAgM,IACAx0B,KAAAs7B,WAAAvN,EAAApc,KACA3R,KAAAu7B,WAAA/G,GAIA,OAAAzG,EAAA/F,QACA,IAAA1lB,GAAAC,EAAA8b,OAYAre,KAAA6jB,SAAAthB,EAAA6zB,2BACAp2B,KAAA6jB,SAAAthB,EAAA+zB,0BACAt2B,KAAA6jB,SAAAthB,EAAAi0B,mCACAx2B,KAAA6jB,SAAAthB,EAAAk0B,oBACAz2B,KAAA6jB,SAAAthB,EAAA8zB,kBAEAr2B,KAAA6jB,OAAAthB,EAAAg0B,gBACAv2B,KAAA+tB,QAAAhC,MAAA,KACA/rB,KAAA86B,SAAA/M,GACA/tB,KAAA66B,SAAA9M,EAAAzrB,EAAAC,EAAAF,OAAAkb,UACAvd,KAAAk5B,OAAAnL,EAAAzrB,EAAAC,EAAAF,OAAAkb,UAEA,MACA,KAAAjb,GAAAC,EAAA4b,IACAne,KAAA6jB,SAAAthB,EAAAozB,yBACA31B,KAAA42B,UAkCA6F,EAAA3sB,MAAA9P,MAjCA+tB,EAAApc,MAAA,oBAAAoc,EAAAvF,UAAA,iBAEAlmB,EAAAoJ,MAAA8vB,QAAAC,4BAAA1N,GACAzrB,EAAAoJ,MAAAgwB,YAAAC,SAAA5N,GAEA/tB,KAAA42B,WAAA,EACA52B,KAAAmyB,aAAAmC,eACAvG,EAAApc,KAKA8qB,EAAA36B,KAAA9B,MAKA,SAAA8D,GACA9D,KAAAmQ,OAAA7I,KAAAxD,GACA9D,KAAAuyB,WACA7H,WAAA,MACAC,aAAA,0BAEA3qB,KAAAk5B,OAAAnL,EAAAzrB,EAAAC,EAAAF,OAAAwb,wBACe/b,KAAA9B,QAEJA,KAAA63B,UACX4E,EAAA3sB,MAAA9P,MAGAA,KAAAk5B,OAAAnL,EAAAzrB,EAAAC,EAAAF,OAAAwb,uBAMA,MACA,KAAAvb,GAAAC,EAAAwc,MACA/e,KAAA6jB,SAAAthB,EAAA+zB,0BAAAt2B,KAAA6jB,SAAAthB,EAAAi0B,kCAEAx2B,KAAA42B,WAuCAt0B,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAA8S,aACA30B,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAA+S,YACAnJ,EAAAhC,MAAA,KAEA/rB,KAAA6jB,SAAAthB,EAAAi0B,oCACAx2B,KAAA6jB,OAAAthB,EAAAk0B,mBACAz2B,KAAA+0B,UAEA/0B,KAAA6jB,OAAAthB,EAAAk0B,mBAEAz2B,KAAAqK,QAhDA0jB,EAAApc,MAAA,oBAAAoc,EAAAvF,UAAA,iBACAxoB,KAAA42B,WAAA,EACA52B,KAAAmyB,aAAAmC,eACAvG,EAAApc,KAKA,WACArP,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAA8S,aACA30B,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAA+S,YACAnJ,EAAAhC,MAAA,KACA/rB,KAAA6jB,SAAAthB,EAAAi0B,oCACAx2B,KAAA6jB,OAAAthB,EAAAk0B,mBACAz2B,KAAA+0B,UAEA/0B,KAAA6jB,OAAAthB,EAAAk0B,mBAEAz2B,KAAAqK,QACevI,KAAA9B,MACf,SAAA8D,GAEA9D,KAAAmQ,OAAA7I,KAAAxD,GACA9D,KAAAuyB,WACA7H,WAAA,MACAC,aAAA,0BAEA3qB,KAAAk5B,OAAAnL,EAAAzrB,EAAAC,EAAAF,OAAAwb,wBACe/b,KAAA9B,SAGfA,KAAAuyB,WACA7H,WAAA,MACAC,aAAA,0BAEA3qB,KAAAk5B,OAAAnL,EAAAzrB,EAAAC,EAAAF,OAAAwb,wBAeO7d,KAAA6jB,SAAAthB,EAAAk0B,oBACP1I,EAAAhC,MAAA,IAEA,MACA,SACAsF,EAAAtrB,UAAA+hB,eAAAhY,MAAA9P,MAAA+tB,OAMAzrB,EAAAwzB,oBAAAA,EAEAC,EAAA,SAAAp0B,EAAA8I,EAAA7J,GACAA,EAAAA,KACA,IAAA87B,GAAAC,EACAt1B,GAAAzG,EAAAyG,kBAAAiK,QACAhJ,EAAA1H,EAAA0H,aAAA,KACAC,EAAA3H,EAAA2H,aAAA,KACAq0B,EAAAj7B,EAAAqkB,cAAAoM,oBAAAyK,WAGA,IAAAD,IAAAA,IACA,KAAA,IAAAt6B,GAAA4I,WAAA4Y,kBAAA,sBAkDA,IA/CA9jB,KAAA47B,eAAAh7B,EAAAg7B,mBACA57B,KAAA88B,iBAAAl8B,EAAAk8B,mBAAA,EAGA98B,KAAA+8B,UAAAn8B,EAAAm8B,YAAA,EAGA/8B,KAAAs7B,WAAA16B,EAAA06B,YAAA,KACAt7B,KAAAu7B,WAAA36B,EAAA26B,YAAA,aAEAmB,GAAmBjT,SAAAzpB,KAAAypB,UAKnBzpB,KAAA0B,QAAAC,EAAAD,QAAAsQ,UACA+qB,UAAA/8B,KAAA+8B,UACAC,SAAAh9B,KAAA+8B,WAAAp7B,EAAAD,QAAAiqB,WAAAhqB,EAAAD,QAAAgqB,WAGA1rB,KAAA+8B,YACAL,EAAAvR,iBAAA,YACAuR,EAAArR,SAAA,kCAEAhkB,EAAAD,KAAA,yBAAAzF,EAAAqkB,cAAA/d,IAAA+J,YACA3K,EAAAD,KAAA,gBAEAC,EAAAD,KAAA,YAAApH,KAAA0B,SACA2F,EAAAD,KAAA,UAAA9E,EAAAmJ,MAAA2J,kBAAAzT,IACA3B,KAAA88B,iBAEG98B,KAAAs7B,aACHj0B,EAAAD,KAAA,iBAAApH,KAAAu7B,YACAl0B,EAAAD,KAAA,kDAHAC,EAAAD,KAAA,iCAMAzF,EAAAqkB,cAAA4F,SAAAtpB,EAAAC,EAAAwb,UAAAG,UACA7W,EAAAD,KAAA,mBAGAxG,EAAAyG,aAAAA,EACAzG,EAAA6pB,OAAAiS,EAEAp6B,EAAAmJ,MAAA8D,QAAAvP,KAAAsC,EAAAqxB,eAAAhyB,EAAAW,EAAAC,EAAAgc,OAAA9T,EAAA7J,IACA0B,EAAAmJ,MAAA8D,QAAAvP,KAAAsC,EAAA+uB,SAAA1vB,EAAAqkB,cAAAoM,sBAGApyB,KAAA6jB,SAAAthB,EAAAyzB,YACA,KAAA,IAAA1zB,GAAA4I,WAAA0Y,kBAAA5jB,KAAA6jB,OAiBA,IAbA7jB,KAAAypB,SAAAnnB,EAAAmJ,MAAAoH,SAGA7S,KAAAk8B,YAAA,EACAl8B,KAAAi9B,cAAA,EAEAj9B,KAAAgoB,OAAA1lB,EAAAC,EAAAgc,OAEAve,KAAA64B,yBAAA74B,KAAAooB,gBACApoB,KAAAooB,gBAAApoB,KAAAk9B,sBAEAl9B,KAAAmQ,OAAAxO,EAAA+Y,UAAA,2BAEApS,EAAA,CAEA,GADAq0B,EAAAr6B,EAAAwQ,GAAAqqB,oBAAAtB,SAAA,YAAAvzB,IACAq0B,EACA,KAAA,IAAAjhB,WAAA,wBAAApT,EAEAtI,MAAAsI,YAAAq0B,EAIA,GAAAp0B,EAAA,CAEA,GADAo0B,EAAAr6B,EAAAwQ,GAAAqqB,oBAAAtB,SAAA,YAAAtzB,IACAo0B,EACA,KAAA,IAAAjhB,WAAA,wBAAAnT,EAEAvI,MAAAuI,YAAAo0B,EAIAh7B,EAAAizB,WAAA50B,MAAAA,KAEAA,KAAAK,GAAAL,KAAA+tB,QAAAjE,QAAA9pB,KAAAypB,SAGAzpB,KAAAmyB,aAAAnyB,KAAAoyB,oBAAApyB,MACA47B,eAAA57B,KAAA47B,eACAtzB,YAAAtI,KAAAsI,YACAC,YAAAvI,KAAAuI,cAGAvI,KAAAmyB,cAAAnyB,KAAAmyB,aAAA4J,mBACA/7B,KAAA+7B,iBAAA/7B,KAAAmyB,aAAA4J,iBAAAj6B,KAAA9B,KAAAmyB,cACAnyB,KAAAg8B,gBAAAh8B,KAAAmyB,aAAA6J,gBAAAl6B,KAAA9B,KAAAmyB,gBAIA4D,EAAAhwB,WAIA6yB,OAAA,SAAAh4B,GACA,GAAA6I,GAAAzJ,IAyCA,OAxCAY,GAAAA,MAEA0B,EAAAmJ,MAAAsE,gBAAAnP,EAAA,QAAA,oBAAA,EAAAZ,KAAAmQ,OAAAnQ,KAAA2B,GAAAqkB,cAAAzV;AACAvQ,KAAAq0B,UAAAzzB,EAAA2P,MAIAvQ,KAAA2B,GAAAm3B,SAAA94B,KAAAK,IAAAL,KAIAA,KAAA88B,kBAEA98B,KAAA+tB,QAAApc,KAAAlI,EAAA6xB,WACAt7B,KAAA6jB,OAAAthB,EAAA0zB,mBACAj2B,KAAA2lB,QAEA3lB,KAAAmyB,aAAAiC,eACA,SAAAgJ,GACA3zB,EAAAyyB,YAAAzyB,EAAAoa,SAAAthB,EAAAgrB,oBAGA9jB,EAAAyoB,UAAA,EACAzoB,EAAAskB,QAAApc,KAAAyrB,EACA3zB,EAAAoa,OAAAthB,EAAA0zB,mBACAxsB,EAAAkc,SAEA,WACAlc,EAAAoa,SAAAthB,EAAAgrB,mBAMA9jB,EAAAyvB,OAAA,KAAA52B,EAAAC,EAAAF,OAAAib,eAEA7T,EAAA4qB,WAIAr0B,MAGAk9B,sBAAA,SAAA75B,GACA,GAAAC,GACAG,EAAAzD,KACAK,EAAAgD,EAAAymB,QAAAzmB,EAAAomB,SAAApmB,EAAAsmB,OACAtiB,KACAzG,IAEA,IAAAZ,KAAA6jB,SAAAthB,EAAAgrB,mBAAAlqB,EAAA2kB,SAAA1lB,EAAAC,EAAAgc,OAAA,CAIA,GAAAve,KAAA0wB,QAAArtB,EAAAG,aAAA,KAAAH,EAAAG,aAAA,IAAA,CACA,GAAAnD,IAAAL,KAAA0wB,OAAArwB,GAAA2R,WAAA,CACA,IAAAhS,KAAA+4B,aAAA11B,EAAA,OAAA,GACA,MAeA,OAbArD,MAAA02B,aAAAr2B,GAAAuyB,YAAA5yB,KAAAsC,EAAAC,EAAA4b,KAEAxM,KAAArP,EAAAmJ,MAAAiG,gBAAArO,EAAAsO,QAEA3R,KAAA02B,aAAAr2B,GAAAuyB,YAAA5yB,KAAAsC,EAAAC,EAAA6b,UAMApe,KAAA6jB,SAAAthB,EAAAirB,kBACAxtB,KAAAk5B,OAAA71B,EAAAf,EAAAC,EAAAF,OAAAib,eAGO,GAAAtd,KAAA6jB,SAAAthB,EAAAirB,iBAEP,WADAxtB,MAAA4yB,YAAAtwB,EAAAC,EAAA4b,KAAoC4L,KAAA1mB,EAAA0mB,MAE7B,KAAA/pB,KAAA42B,UAGP,OAIA,GAAA52B,KAAA0wB,QAAArtB,EAAAG,YAAA,IAAA,CAKA,IAAAxD,KAAA02B,aAAAr2B,KAAAL,KAAA+4B,aAAA11B,EAAA,OAAA,GACA,MAUA,OAPAgE,GAAAD,KAAA,SAAA/D,EAAAmlB,UAAA,QAAA,IAAAnlB,EAAAmlB,UAAA,SACAxoB,KAAA02B,aAAAr2B,GAAA2xB,QAAA5qB,KAAA/D,EAAAmlB,UAAA,aAEAxoB,MAAA02B,aAAAr2B,GAAAuyB,YAAA5yB,KAAAsC,EAAAC,EAAAwc,OACA1X,aAAAA,EACAsK,KAAArP,EAAAmJ,MAAAiG,gBAAArO,EAAAsO,QAMA,GAAA3R,KAAAk8B,WAQA,YAPA74B,EAAAG,aAAA,KAAAH,EAAAG,YAAA,KACAxD,KAAA+tB,QAAAa,OAAA5uB,KAAAq9B,cACAr9B,KAAA86B,SAAA,OACOz3B,EAAAG,aAAA,KAAAH,EAAAG,YAAA,MACPxD,KAAAy6B,mBAAAp3B,GACArD,KAAA6C,KAAA,MAAA7C,KAAA+tB,UAKA,SAAA,GACA,IAAA,QAAAxqB,KAAAF,EAAAG,aACAxD,KAAAi9B,cAAA,CACA,MACA,KAAA,cAAuB15B,KAAAF,EAAAG,aAEvB,IAAAH,EAAAsmB,OAAA,CACA3pB,KAAAmQ,OAAA7I,KAAA,uCACA,OAIA,GAAAjE,EAAAinB,UAAA,aAEAtqB,KAAA+4B,aAAA11B,EAAA,OAAA,GACA,KAMA,IAFArD,KAAA6jB,OAAAthB,EAAA2zB,oBAEA7yB,EAAAinB,UAAA,YACA,KAAAjnB,EAAAmlB,UAAA,WAAA5W,QAAA,UAAA,CAGA,GAAA5R,KAAA0wB,SAAA1wB,KAAA02B,aAAAr2B,GACA,KAGA,IAAA,KAAAL,KAAA02B,aAAAr2B,GAAA2xB,QAAApgB,QAAAvO,EAAAmlB,UAAA,UACAxoB,KAAA02B,aAAAr2B,GAAA2xB,QAAAhyB,KAAA02B,aAAAr2B,GAAA2xB,QAAAtoB,OAAA,IAAArG,EAAAmlB,UAAA,SAAAxoB,KAAA02B,aAAAr2B,GAAA2xB,QAAAtoB,OAAA,EACA,MAMA,IAHApH,EAAAoJ,MAAA8vB,QAAAC,4BAAAp4B,GACAf,EAAAoJ,MAAAgwB,YAAAC,SAAAt4B,GAEAA,EAAAsO,KAQW,GAAA3R,KAAAkyB,SAAA,CACX,IAAAlyB,KAAA+4B,aAAA11B,EAAA,OACA,KAEArD,MAAA42B,WAAA,EACA52B,KAAAmyB,aAAAmC,eACAjxB,EAAAsO,KAKA,WACAtK,EAAAD,KAAA,SAAA/D,EAAAmlB,UAAA,QAAA,IAAAnlB,EAAAmlB,UAAA,SACA/kB,EAAAitB,OAAAsB,QAAA5qB,KAAA/D,EAAAmlB,UAAA,SAEA/kB,EAAAmvB,YAAAtwB,EAAAC,EAAAwc,OACA1X,aAAAA,EACA+gB,gBAAA,eAEA3kB,EAAAogB,OAAAthB,EAAAk0B,mBACAhzB,EAAA4G,OACA5G,EAAAZ,KAAA,WAAAQ,IAgBA,SAAAS,GACAL,EAAA0M,OAAA7I,KAAAxD,GACAL,EAAAg3B,mBAAAp3B,EAAA,IAAA,uBACAI,EAAAy1B,OAAA71B,EAAAf,EAAAC,EAAAF,OAAAwb,6BAIA7d,MAAA02B,aAAAr2B,GAAA2xB,QAAA5qB,KAAA/D,EAAAmlB,UAAA,SACAxoB,KAAA02B,aAAAr2B,GAAA8xB,aAAAmC,eACAjxB,EAAAsO,KACA,WACAlO,EAAAizB,aAAAr2B,GAAA8xB,aAAAiC,eACA,SAAAkJ,GACAj2B,EAAAD,KAAA,iCACAC,EAAAD,KAAA,SAAA/D,EAAAmlB,UAAA,QAAA,IAAAnlB,EAAAmlB,UAAA,SACA/kB,EAAAizB,aAAAr2B,GAAAuyB,YAAAnvB,EAAAnB,EAAAC,EAAAwc,OACA1X,aAAAA,EACAsK,KAAA2rB,IAEA75B,EAAAogB,OAAAthB,EAAAk0B,mBACAhzB,EAAAZ,KAAA,WAAAQ,IAEA,WACAI,EAAAizB,aAAAr2B,GAAA2xB,QAAA5qB,KAAA/D,EAAAmlB,UAAA,SACA/kB,EAAAogB,SAAAthB,EAAAgrB,mBAKA9pB,EAAAy1B,OAAA,KAAA52B,EAAAC,EAAAF,OAAAib,eAEA7Z,EAAA4wB,YAGA,SAAAvwB,GACAL,EAAAizB,aAAAr2B,GAAA2xB,QAAAhW,OAAAvY,EAAAizB,aAAAr2B,GAAA2xB,QAAApgB,QAAAvO,EAAAmlB,UAAA,SAAA,GAEA/kB,EAAA0M,OAAA7I,KAAA,eACA7D,EAAA0M,OAAA7I,KAAAxD,SAlFAuD,GAAAD,KAAA,SAAA/D,EAAAmlB,UAAA,QAAA,IAAAnlB,EAAAmlB,UAAA,SACAxoB,KAAA02B,aAAAr2B,GAAA2xB,QAAA5qB,KAAA/D,EAAAmlB,UAAA,SACAxoB,KAAA02B,aAAAr2B,GAAAuyB,YAAA5yB,KAAAsC,EAAAC,EAAAwc,OACA1X,aAAAA,IAEArH,KAAA6C,KAAA,WAAAQ,OAkFArD,MAAA6C,KAAA,WAAAQ,EAEA,MACA,KAAA,cAAsBE,KAAAF,EAAAG,aACtB,GAAAumB,GAAA/pB,KAAA+tB,QAAAhE,KAAA,IAAA/pB,KAAA+tB,QAAA/F,MACA,IAAA+B,IAAA1mB,EAAAmlB,UAAA,QACA,KAGA,IAAAxoB,KAAA6jB,SAAAthB,EAAAk0B,oBAAAz2B,KAAA0wB,OAAA,CACA1wB,KAAA6jB,OAAAthB,EAAAirB,iBACAxtB,KAAAuK,SAQA3J,KACAZ,KAAAs7B,aACAj0B,EAAAD,KAAA,iBAAApH,KAAAu7B,YACA36B,EAAAyG,aAAAA,EACAzG,EAAA+Q,KAAA3R,KAAAs7B,YAEA16B,EAAAmpB,KAAA1mB,EAAA0mB,KACA/pB,KAAA4yB,YAAAtwB,EAAAC,EAAA4b,IAAAvd,GACAZ,KAAA+6B,SAAA13B,EACA,OAGA,GAAArD,KAAA0wB,OACA,KAOA,IAJApuB,EAAAoJ,MAAA8vB,QAAAC,4BAAAp4B,GACAf,EAAAoJ,MAAAgwB,YAAAC,SAAAt4B,GAGArD,KAAAkyB,SA4ES,GAAAlyB,KAAA42B,UACT52B,KAAAs7B,aACAj0B,EAAAD,KAAA,iBAAA3D,EAAA83B,YACA36B,EAAAyG,aAAAA,EACAzG,EAAA+Q,KAAA3R,KAAAs7B,YAEAt7B,KAAA4yB,YAAAtwB,EAAAC,EAAA4b,IAAAvd,OACS,CACT,IAAAyC,EAAAsO,KAAA,CACA3R,KAAAy6B,mBAAAp3B,EAAA,IAAA,+BACArD,KAAAk5B,OAAA71B,EAAAf,EAAAC,EAAAF,OAAAwb,sBACA,OAEA,IAAA7d,KAAA+4B,aAAA11B,EAAA,OACA,KAEArD,MAAA42B,WAAA,EACA52B,KAAAmyB,aAAAmC,eACAjxB,EAAAsO,KAKA,WACA,GAAA/Q,KACA6C,GAAAogB,OAAAthB,EAAAirB,iBACA/pB,EAAA8G,SAQA9G,EAAA63B,aACAj0B,EAAAD,KAAA,iBAAA3D,EAAA83B,YACA36B,EAAAyG,aAAAA,EACAzG,EAAA+Q,KAAAlO,EAAA63B,YAEA16B,EAAAmpB,KAAA1mB,EAAA0mB,KACAtmB,EAAAmvB,YAAAtwB,EAAAC,EAAA4b,IAAAvd,GACA6C,EAAAs3B,SAAA13B,IAMA,SAAAS,GACAL,EAAA0M,OAAA7I,KAAAxD,GACAL,EAAAg3B,mBAAAp3B,EAAA,IAAA,uBACAI,EAAAy1B,OAAA71B,EAAAf,EAAAC,EAAAF,OAAAwb,6BA7HA,IAAA7d,KAAA02B,aAAAr2B,IAAAL,KAAA02B,aAAAr2B,GAAA8xB,aAAAoL,WAAA,CAKA,GAHAv9B,KAAAkyB,UAAA,EACAlyB,KAAA42B,WAAA,EACA52B,KAAAmyB,aAAAnyB,KAAA02B,aAAAr2B,GAAA8xB,cACAnyB,KAAA+4B,aAAA11B,EAAA,OACA,KAEArD,MAAA6jB,OAAAthB,EAAAirB,iBACAxtB,KAAA4yB,YAAAtwB,EAAAC,EAAA4b,KAAyC4L,KAAA1mB,EAAA0mB,OAEzC/pB,KAAAuK,SASAvK,KAAA+6B,SAAA13B,OACW,CACX,IAAAA,EAAAsO,KAAA,CACA3R,KAAAy6B,mBAAAp3B,EAAA,IAAA,+BACArD,KAAAk5B,OAAA71B,EAAAf,EAAAC,EAAAF,OAAAwb,sBACA,OAEA,IAAA7d,KAAA+4B,aAAA11B,EAAA,OACA,KAEArD,MAAAkyB,UAAA,EACAlyB,KAAAmyB,aAAAmC,eACAjxB,EAAAsO,KACA,WACAlO,EAAA0uB,aAAAiC,eACA,SAAAkJ,GAEA75B,EAAAy4B,YAAAz4B,EAAAogB,SAAAthB,EAAAgrB,oBAIA+P,EAAAh7B,EAAAoJ,MAAA8vB,QAAAgC,qBAAAF,GAEA75B,EAAAogB,OAAAthB,EAAAirB,iBACA/pB,EAAAmzB,WAAA,EAEAnzB,EAAA8G,SAQA9G,EAAAmvB,YAAAtwB,EAAAC,EAAA4b,KACAxM,KAAA2rB,EACAj2B,cAAA,iCACA0iB,KAAA1mB,EAAA0mB,OAEAtmB,EAAAs3B,SAAA13B,KAEA,WAEAI,EAAA0M,OAAA7I,KAAA,wBAEA7D,EAAA4wB,YAGA,SAAAvwB,GACAL,EAAA0M,OAAA7I,KAAA,eACA7D,EAAA0M,OAAA7I,KAAAxD,GACAT,EAAA0oB,MAAA,OA0DA,KACA,SACAzoB,EAAAhB,EAAAmJ,MAAAmJ,cAAAvR,EAAAG,aACAxD,KAAAk5B,OAAA71B,EAAAC,GACAtD,KAAA66B,SAAAx3B,EAAAC,MAIAsrB,OAAA,SAAAhuB,GACAA,EAAAA,KAEA,IAGA+zB,GAFAjK,EAAA9pB,EAAA4C,YACAmnB,EAAA/pB,EAAA+pB,YAIA,IAAA3qB,KAAA6jB,SAAAthB,EAAAgrB,kBACA,KAAA,IAAAjrB,GAAA4I,WAAA0Y,kBAAA5jB,KAAA6jB,OAKA,IAFA7jB,KAAAmQ,OAAAzJ,IAAA,wBAEAgkB,IAAA,IAAAA,GAAAA,GAAA,KACA,KAAA,IAAAhP,WAAA,wBAAAgP,EAiBA,OAhBKA,KACLC,EAAAA,GAAAroB,EAAAC,EAAAE,cAAAioB,IAAA,GACAiK,EAAA,cAA4BjK,EAAA,WAA0BC,EAAA,KAItD3qB,KAAA6jB,SAAAthB,EAAAyzB,aACAh2B,KAAA6jB,SAAAthB,EAAA0zB,qBAAAj2B,KAAAi9B,cACAj9B,KAAAk8B,YAAA,EACAl8B,KAAAq9B,aAAA1I,GACK30B,KAAA6jB,SAAAthB,EAAA0zB,oBACLj2B,KAAA6jB,SAAAthB,EAAA2zB,qBACAl2B,KAAA6jB,SAAAthB,EAAAk0B,oBACAz2B,KAAA+tB,QAAAa,OAAA+F,GAGA30B,KAAA86B,YAGAvI,UAAA,SAAA3xB,GACA,MAAAZ,MAAA6jB,SAAAthB,EAAAgrB,kBACAvtB,MAGAA,KAAA6jB,SAAAthB,EAAAozB,wBAAA31B,KAAA6jB,SAAAthB,EAAAirB,iBACAxtB,KAAAk4B,IAAAt3B,GAEAZ,KAAA4uB,OAAAhuB,GAGAZ,KAAAm4B,eAGArQ,eAAA,SAAAiG,GAiBA,MAbAA,GAAA/F,SAAA1lB,EAAAC,EAAA8b,OAIA0P,EAAA/F,SAAA1lB,EAAAC,EAAA4b,KAAAne,KAAA6jB,SAAAthB,EAAAozB,yBACArzB,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAA0S,UACAv0B,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAA4S,gBACA/2B,KAAA6jB,OAAAthB,EAAAirB,iBACAxtB,KAAAuK,SAEAvK,KAAA+6B,YAGA1J,EAAAtrB,UAAA+hB,eAAAhY,MAAA9P,MAAA+tB,MAIAzrB,EAAAyzB,oBAAAA,I1BgwKM,SAASl2B,EAAQD,G2Bp2OvBC,EAAAD,QAAA,SAAA0C,GACAA,EAAAm7B,aAAA,SAAA97B,EAAA8I,EAAA4K,EAAAzU,GACA,GAAAuB,EASA,IAPAvB,EAAAA,MACAA,EAAAyG,cAAAzG,EAAAyG,kBAAAiK,QAEAnP,GAAA,UACAnC,KAAAK,GAAA,KACAL,KAAAouB,MAAA,QAEA/Y,EACA,KAAA,IAAAqG,WAAA,4CAIA1b,MAAAqV,MAAAA,EAGA,gBAAAzU,GAAA4yB,SACA7xB,EAAAwO,OAAA7I,KAAA,oDACAtH,KAAAwzB,QAAA,MAEAxzB,KAAAwzB,QAAA5yB,EAAA4yB,QAGA5yB,EAAAyG,aAAAD,KAAA,UAAApH,KAAAqV,OACAzU,EAAAyG,aAAAD,KAAA,YAAApH,KAAAwzB,SAEA5yB,EAAA+Q,OACA3R,KAAA2R,KAAA/Q,EAAA+Q,MAGA3R,KAAA0B,QAAAC,EAAAD,QAAAsQ,WAEApR,EAAAyG,aAAAD,KAAA,YAAApH,KAAA0B,SACAd,EAAAyG,aAAAD,KAAA,UAAA9E,EAAAmJ,MAAA2J,kBAAAzT,IAEAW,EAAAmJ,MAAA8D,QAAAvP,KAAAsC,EAAAqxB,eAAAhyB,EAAAW,EAAAC,EAAAsc,UAAApU,EAAA7J,IAEAZ,KAAAmQ,OAAAxO,EAAA+Y,UAAA,oBAEA1a,KAAA0wB,OAAA,KACA1wB,KAAAmkB,QAAiBuZ,EAAA,KAAAC,aAAA,MACjB39B,KAAA49B,YAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KAEA59B,KAAAqb,eAAAlZ,IAGAG,EAAAm7B,aAAA13B,WACA83B,UAAA,WACA,GAAAC,GAAA99B,IAUA,OARAsC,GAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAAwZ,cACAr7B,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAAuZ,GACA19B,KAAAmkB,OAAAuZ,EAAAp7B,EAAA6I,OAAAxH,WAAAm6B,EAAAC,WAAAj8B,KAAAg8B,GAAAx7B,EAAA6I,OAAA0Z,SAEA7kB,KAAA2lB,OAEA3lB,KAAAouB,MAAA,cAEApuB,MAGAooB,gBAAA,SAAA/kB,GACA,GAAAmwB,GAAAsK,EAAA99B,KACAsD,EAAAhB,EAAAC,EAAAE,cAAAY,EAAAG,cAAA,EAEA,MAAAxD,KAAA49B,WAAAhsB,QAAAvO,EAAAG,aACAxD,KAAAk5B,OAAA71B,EAAA,MACK,cAAqBE,KAAAF,EAAAG,eAC1BgwB,EAAAnwB,EAAAmlB,UAAA,WACAlmB,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAAuZ,GAEA19B,KAAAg+B,sBAAA36B,EAAA,SACArD,KAAAK,GAAAL,KAAA0wB,OAAArwB,GAAA2R,WACAhS,KAAA2B,GAAAs8B,cAAAj+B,KAAAK,IAAAL,KACAA,KAAA6C,KAAA,WAAAQ,EAAAC,IAIAkwB,GAAAA,GAAAxzB,KAAAwzB,QACAxzB,KAAAmkB,OAAAwZ,aAAAr7B,EAAA6I,OAAAxH,WAAAm6B,EAAAD,UAAA/7B,KAAAg8B,GAAA,IAAAtK,GAEAA,GAIAxzB,KAAAmQ,OAAA7I,KAAA,uGACAtH,KAAAk5B,OAAA71B,EAAAf,EAAAC,EAAA27B,0BAJAl+B,KAAAmQ,OAAA7I,KAAA,+DACAtH,KAAAk5B,OAAA71B,EAAAf,EAAAC,EAAA47B,2BASAC,YAAA,WACA,GAAA/2B,MAAAy2B,EAAA99B,IAEAA,MAAAouB,MAAA,aAEA/mB,EAAAD,KAAA,UAAApH,KAAAqV,OACAhO,EAAAD,KAAA,cAEAC,EAAAD,KAAA,YAAApH,KAAA0B,SACA2F,EAAAD,KAAA,UAAA9E,EAAAmJ,MAAA2J,kBAAApV,KAAA2B,KAEA3B,KAAA+tB,QAAA,GAAAzrB,GAAAioB,gBAAAvqB,KAAAgoB,OAAAhoB,KAAA+tB,QAAA7Y,GAAAjN,IAAA+J,WAAAhS,KAAA2B,GAAA,KAAA0F,GAGArH,KAAAooB,gBAAA,aAEA9lB,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAAwZ,cACAr7B,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAAuZ,GACA19B,KAAAmkB,OAAAuZ,EAAAp7B,EAAA6I,OAAAxH,WAAAm6B,EAAAC,WAAAj8B,KAAAg8B,GAAAx7B,EAAA6I,OAAA0Z,SAEA7kB,KAAA2lB,QAMAoY,WAAA,WACA,eAAA/9B,KAAAouB,MACApuB,KAAAomB,QACK,YAAApmB,KAAAouB,OAAA,gBAAApuB,KAAAouB,OACLpuB,KAAAouB,MAAA,aACApuB,KAAAomB,SAEApmB,KAAA69B,aAOAzX,MAAA,WACA,eAAApmB,KAAAouB,OACApuB,KAAAo+B,cAGAp+B,KAAAq+B,kBACA/7B,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAAuZ,GACAp7B,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAAwZ,oBAEA39B,MAAA2B,GAAAs8B,cAAAj+B,KAAAK,KAMA29B,sBAAA,SAAAra,EAAA/W,GACA,GAAA8jB,EAKA,OAHA1wB,MAAAq+B,kBACA3N,EAAA,GAAApuB,GAAAivB,OAAAvxB,KAAA2jB,EAAA/W,GAEA8jB,EAAArW,OAMA,GALAra,KAAA0wB,OAAAA,GACA,IAWA2N,gBAAA,WACAr+B,KAAA0wB,eACA1wB,MAAA2B,GAAAs8B,cAAAj+B,KAAAK,IACAL,KAAA0wB,OAAA6B,kBACAvyB,MAAA0wB,SAOA5I,eAAA,SAAAiG,GAGA,QAAAuQ,KACAC,EAAA/K,UACA+K,EAAA/K,QAAA7gB,KAAAgoB,IAAAmD,EAAAtK,QACA7gB,KAAA6rB,IAAAD,EAAA/K,QAAA,IACAsK,EAAA3Z,OAAAwZ,aAAAr7B,EAAA6I,OAAAxH,WAAAm6B,EAAAD,UAAA/7B,KAAAg8B,GACA,IAAAS,EAAA/K,UAPA,GAAA+K,GAAAT,EAAA99B,IAWA,KAAAA,KAAAy+B,WAAA1Q,GAEA,WADAA,GAAAhC,MAAA,IAaA,QATAwS,EAAAxQ,EAAAnF,YAAA,sBAEAmF,EAAAhC,MAAA,IAAAzpB,EAAAC,EAAAm8B,YAEAp8B,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAAuZ,GACAp7B,EAAA6I,OAAA+a,aAAAlmB,KAAAmkB,OAAAwZ,cAEA39B,KAAA6C,KAAA,UAAyBkrB,QAAAA,IAEzBwQ,EAAAnQ,OACA,IAAA,SACApuB,KAAAouB,MAAA,SACAkQ,GACA,MACA,KAAA,UACA,gBAAAt+B,KAAAouB,OACAkQ,IAEAt+B,KAAAouB,MAAA,SACA,MACA,KAAA,aACA,GAAAmQ,EAAAlY,OAEA,OADArmB,KAAAmQ,OAAAzJ,IAAA,wCAAA63B,EAAAlY,QACAkY,EAAAlY,QACA,IAAA,cACA,IAAA,UAEA,WADArmB,MAAA69B,WAEA,KAAA,YACA,IAAA,SAMA,YALAU,EAAA9T,QAAA8T,EAAA9T,OAAA,eACAzqB,KAAAmkB,OAAAwZ,aAAAr7B,EAAA6I,OAAAxH,WAAAm6B,EAAAD,UAAA/7B,KAAAg8B,GAAAS,EAAA9T,OAAA,gBAEAzqB,KAAA69B,YAGA,KAAA,WACA,IAAA,aACA,IAAA,aAIA79B,KAAAomB,UAKA8S,OAAA,SAAA71B,EAAAC,GAEA,MADAtD,MAAAomB,QACApmB,KAAA6C,KAAA,SAAAQ,EAAAC,IAMAm7B,WAAA,SAAA1Q,GACA,GAAA1Y,EAGA,OAAA0Y,GAAAzD,UAAA,SAKAyD,EAAAzD,UAAA,uBAMAjV,EAAA0Y,EAAAnF,YAAA,SAAAvT,MAEArV,KAAAqV,QAAAA,GACArV,KAAAmQ,OAAA7I,KAAA,sBACAymB,EAAAhC,MAAA,IAAA,uBACA,IAEA,IAZA/rB,KAAAmQ,OAAA7I,KAAA,sCACA,IANAtH,KAAAmQ,OAAA7I,KAAA,yBACA,O3Bw4OM,SAASzH,EAAQD,G4BvoPvBC,EAAAD,QAAA,SAAA0C,GAEA,GAAA+I,GAAA,SAAA5H,EAAA7C,GAyHA,QAAA+9B,GAAAC,EAAAvpB,GACAupB,EAAAC,mBAAAh9B,IACA+8B,EAAAC,mBAAAtjB,YACAqjB,EAAAC,mBAAAtjB,WAAAlG,IACAupB,EAAAC,mBAAAh9B,GAAAwT,EAAA,WACAupB,EAAA/7B,KAAAiN,MAAA8uB,GAAAvpB,GAAA2iB,OAAAjwB,MAAAhC,UAAAuL,MAAA/Q,KAAAub,eA7HA,GAAA3Z,IACA,mBACA,YACA,kBACA,eACA,eACA,cACA,YACA,iBACA,iBACA,cACA,YAEAvB,GAAAA,MAEAZ,KAAAmQ,OAAA1M,EAAA9B,GAAA+Y,UAAA,iCAAAjX,EAAApD,IACAL,KAAAyD,QAAAA,EACAzD,KAAAu9B,WAAA,KACAv9B,KAAA8+B,OAAA,EACA9+B,KAAA6+B,mBAAAj+B,EAAAi+B,oBAAA,GAAAv8B,GAAAuD,OAAAC,mBAAA9F,KAAAmQ,QACAnQ,KAAA++B,YAAA,EACA/+B,KAAAg/B,YAAA,CAGA,IAAApvB,GAAAlG,EAAAyb,EACA1b,EAAAzJ,KACAi/B,KACA32B,EAAA1H,EAAA0H,aAAA,KACAC,EAAA3H,EAAA2H,aAAA,KACA22B,EAAAl/B,KAAAyD,QAAA9B,GAAAqkB,aAmBA,KAlBAhmB,KAAA47B,eAAAh7B,EAAAg7B,mBAEAtzB,IACAA,EAAA42B,EAAA52B,aAGAC,IACAA,EAAA22B,EAAA32B,gBAMAyvB,OAAA1vB,GAAA/B,QAAA,SAAA4e,GACA8Z,EAAA73B,MAAkBiG,IAAA8X,MAGlBzb,EAAAnB,EAAAmB,OACAkG,EAAA,EAAelG,EAAAkG,EAAcA,IAC7BuV,EAAA5c,EAAAqH,GACAqvB,EAAA73B,MACAiG,IAAA8X,EAAAga,KACAp9B,SAAAojB,EAAApjB,SACAq9B,WAAAja,EAAAjd,UAIAlI,MAAAwyB,eAAA,GAAAlwB,GAAAuD,OAAAw5B,mBAA0D1C,WAAAsC,GAAsBj/B,KAAA47B,gBAEhF57B,KAAAwyB,eAAA8M,YAAA,SAAAx7B,GACA2F,EAAA0G,OAAAzJ,IAAA,iBAAA5C,EAAAoC,OAAA7F,IACAoJ,EAAAmH,SACAnH,EAAA5G,KAAA,YAAAiB,IAGA9D,KAAAwyB,eAAA+M,eAAA,SAAAz7B,GACA2F,EAAA0G,OAAAzJ,IAAA,mBAAA5C,EAAAoC,OAAA7F,KAGAL,KAAAwyB,eAAAgN,eAAA,SAAA17B,GACA2F,EAAA5G,KAAA,eAAAiB,GACAA,EAAA27B,UACAh2B,EAAA0G,OAAAzJ,IAAA,4BAAA,OAAA5C,EAAA27B,UAAAA,UAAA,KAAA37B,EAAA27B,UAAAA,UAAAvW,SACKnoB,SAAA0I,EAAAi2B,eACLj2B,EAAAi2B,eAAA1/B,MAEAyJ,EAAAk2B,oBAAA,GAIA3/B,KAAAwyB,eAAAoN,0BAAA,WACAn2B,EAAA0G,OAAAzJ,IAAA,iCAAA1G,KAAA6/B,mBACA,cAAA7/B,KAAA6/B,mBACAp2B,EAAA5G,KAAA,eAAA7C,MAEA,aAAAA,KAAA6/B,oBACA9+B,SAAA0I,EAAAi2B,eACAj2B,EAAAi2B,eAAA1/B,MAEAyJ,EAAAk2B,oBAAA,IAKA3/B,KAAAwyB,eAAAsN,2BAAA,WACAr2B,EAAA0G,OAAAzJ,IAAA,oCAAA1G,KAAA+/B,mBAAA,KAEA,WAAA//B,KAAA+/B,oBACAt2B,EAAA5G,KAAA,YAAA7C,OAgBAA,KAAAwyB,eAAAwN,cAAA,WACAv2B,EAAA0G,OAAAzJ,IAAA,oCAAA1G,KAAA6lB,WAAA,MAGA7lB,KAAAob,WAAAjZ,GAYAw8B,EAAA3+B,KAAA,oBACA2+B,EAAA3+B,KAAA,aACA2+B,EAAA3+B,KAAA,mBAqWA,OAlWAqL,GAAAsrB,eAAA,SAAAlzB,EAAA7C,GACA,MAAA,IAAAyK,GAAA5H,EAAA7C,IAEAyK,EAAAsrB,eAAAkG,YAAA,WACA,MAAAv6B,GAAAuD,OAAAg3B,eAGAxxB,EAAAtF,UAAAJ,OAAAC,OAAAtD,EAAA+I,aAAAtF,WAEAouB,SAAY8L,UAAA,EAAAh6B,MAAA,WACZ,MAAAjG,MAAA8+B,QAGA1Y,OAAU6Z,UAAA,EAAAh6B,MAAA,WACVjG,KAAAmQ,OAAAzJ,IAAA,0BAGA1G,KAAAwyB,gBAAA,WAAAxyB,KAAAwyB,eAAA0N,iBACAlgC,KAAAwyB,eAAApM,QAEApmB,KAAAu9B,YACAv9B,KAAA6+B,mBAAA74B,QAAAhG,KAAAu9B,eAWAnJ,gBAAmB6L,UAAA,EAAAh6B,MAAA,SAAA+lB,EAAAC,EAAAoI,GAgBnB,QAAA8L,KACA12B,EAAAyoB,SAAA,UACAzoB,EAAA+oB,eAAA4N,cAAA,SAAA5Y,GACA/d,EAAA42B,YAAA7Y,EAAA8Y,QACA72B,EAAA5G,KAAA,cAAA4G,EAAA42B,cAEOhM,EAAAgM,aACP52B,EAAA+oB,eAAA+N,oBACA92B,EAAA42B,YAAA52B,EAAA+oB,eAAA+N,kBACA,QACAlM,EAAAgM,aAEA52B,EAAA5G,KAAA,cAAA4G,EAAA42B,cAGA52B,EAAAmH,SACAnH,EAAA+2B,oBAAAxU,EAAAC,EAAAxiB,EAAAmyB,gBAGA,QAAA6E,GAAAv6B,GACAuD,EAAA0G,OAAAzJ,IAAA,+BACA+C,EAAA8zB,WAAAr3B,EACAuD,EAAAhG,QAAAu3B,aACAvxB,EAAAi3B,UACAx6B,EACAi6B,EACAlU,GAzCA,GAAAxiB,GAAAzJ,IA6CA,OA5CAq0B,GAAAA,MACAA,EAAAgM,eAAA,IACAhM,EAAAgM,gBAEArgC,KAAAq0B,UAAAA,EAwCA5qB,EAAA8zB,YACA9zB,EAAA0G,OAAAzJ,IAAA,gCACAy5B,OAIA12B,EAAA0G,OAAAzJ,IAAA,6BACA+C,GAAAo1B,mBAAA8B,QACAF,EACA,SAAAtkB,GACA1S,EAAA0G,OAAAkK,MAAA,4BACA5Q,EAAA0G,OAAAkK,MAAA8B,GACA1S,EAAAhG,QAAAu3B,aACA/O,EAAA9P,IAEAkY,MAWAC,gBAAmB2L,UAAA,EAAAh6B,MAAA,SAAAq3B,EAAAtR,EAAAC,GACnB,GAAA2U,IACAh0B,KAAA5M,KAAAkyB,SAAA,SAAA,SAAA,QACAoL,IAAAA,EAGAt9B,MAAA6C,KAAA,iBAAA+9B,EAEA,IAAApzB,GAAA,GAAAlL,GAAAuD,OAAAg7B,sBAAAD,EACA5gC,MAAAwyB,eAAAsO,qBAAAtzB,EAAAwe,EAAAC,KAIA8U,SAAYd,UAAA,EAAAh6B,MAAA,WACZ,OACAwK,MAAAzQ,KAAA++B,WACAruB,MAAA1Q,KAAAg/B,cAIA30B,MAAS41B,UAAA,EAAAh6B,MAAA,SAAArF,GACT,GAAA,IAAAZ,KAAAg8B,kBAAAtyB,OAAA,CAIA9I,EAAAA,IACA6P,MAAAzQ,KAAAg8B,kBAAA,GAAAgF,iBAAAt3B,OAAA,EACAgH,MAAA1Q,KAAAg8B,kBAAA,GAAAiF,iBAAAv3B,OAAA,EAGA,IAAAq1B,IAAA,EACAC,GAAA,CAeA,OAbAp+B,GAAA6P,QAAAzQ,KAAA++B,aACAA,GAAA,EACA/+B,KAAA++B,YAAA,EACA/+B,KAAAkhC,iBAAA,IAGAtgC,EAAA8P,QAAA1Q,KAAAg/B,aACAA,GAAA,EACAh/B,KAAAg/B,YAAA,EACAh/B,KAAAmhC,iBAAA,IAIApC,GAAAC,GAEAvuB,MAAAsuB,EACAruB,MAAAsuB,GAHA,UAYAz0B,QAAW01B,UAAA,EAAAh6B,MAAA,SAAArF,GACX,GAAA,IAAAZ,KAAAg8B,kBAAAtyB,OAAA,CAIA9I,EAAAA,IACA6P,MAAAzQ,KAAAg8B,kBAAA,GAAAgF,iBAAAt3B,OAAA,EACAgH,MAAA1Q,KAAAg8B,kBAAA,GAAAiF,iBAAAv3B,OAAA,EAGA,IAAA03B,IAAA,EACAC,GAAA,CAeA,OAbAzgC,GAAA6P,OAAAzQ,KAAA++B,aACAqC,GAAA,EACAphC,KAAA++B,YAAA,EACA/+B,KAAAkhC,iBAAA,IAGAtgC,EAAA8P,OAAA1Q,KAAAg/B,aACAqC,GAAA,EACArhC,KAAAg/B,YAAA,EACAh/B,KAAAmhC,iBAAA,IAIAC,GAAAC,GAEA5wB,MAAA2wB,EACA1wB,MAAA2wB,GAHA,UAYAn3B,MAAS+1B,UAAA,EAAAh6B,MAAA,WACTjG,KAAAkhC,iBAAA,GACAlhC,KAAAmhC,iBAAA,KAGAh3B,QAAW81B,UAAA,EAAAh6B,MAAA,WACXjG,KAAA++B,YACA/+B,KAAAkhC,iBAAA,GAGAlhC,KAAAg/B,YACAh/B,KAAAmhC,iBAAA,KAKAnF,iBAAoBiE,UAAA,EAAAh6B,MAAA,WACpB,GAAAq7B,GAAAthC,KAAAwyB,cACA,OAAA8O,IAAA,WAAAA,EAAApB,gBACAlgC,KAAAmQ,OAAA7I,KAAA,8DAGAg6B,EAAAtF,iBAAAsF,EAAAtF,mBACAsF,EAAAC,mBAGAxF,kBAAqBkE,UAAA,EAAAh6B,MAAA,WACrB,GAAAq7B,GAAAthC,KAAAwyB,cACA,OAAA8O,IAAA,WAAAA,EAAApB,gBACAlgC,KAAAmQ,OAAA7I,KAAA,+DAGAg6B,EAAAvF,kBAAAuF,EAAAvF,oBACAuF,EAAAE,oBAGA5wB,QAAWqvB,UAAA,EAAAh6B,MAAA,SAAAw7B,GAEX,GADAA,EAAAA,GAAAzhC,KAAAq0B,WAAAr0B,KAAAq0B,UAAAzjB,QACA6wB,EACA,OAAA,CAEA,IAAAC,IACA9H,MAAA,kBACA/oB,OAAA,mBAEAlL,QAAAg8B,KAAAD,GAAAn7B,QAAA,SAAAq7B,GACA,GAAAC,GAAAH,EAAAE,GACAE,EAAA9hC,KAAA6hC,IACAC,GAAAp4B,QACApH,EAAAuD,OAAAC,mBAAA8K,OAAAkxB,EAAA,GAAAL,EAAAG,KAEK9/B,KAAA9B,SAILkyB,UAAa+N,UAAA,EAAAh6B,MAAA,SAAA87B,GACb,GAAAC,GAAA,QAAAD,EAAA,QACA,OAAA/hC,MAAAwyB,eAAA0N,iBAAA8B,IAIAxB,qBAAwBP,UAAA,EAAAh6B,MAAA,SAAA+lB,EAAAC,EAAAzb,GAIxB,QAAAyxB,KACA,GAAA3E,GAAA7zB,EAAA+oB,eAAA0P,iBAAA5E,GAEAA,GAAAh7B,EAAAoJ,MAAA+sB,OAAA0J,2BAAA7E,GACAA,EAAAh7B,EAAAoJ,MAAAgwB,YAAA0G,WAAA9E,GACAA,EAAAh7B,EAAAoJ,MAAA8vB,QAAA6G,yCAAA/E,EAEA,IAAAgF,IACA11B,KAAA,gBAAA21B,EAAA,QAAA,SACAjF,IAAAA,EAGA7zB,GAAA5G,KAAA,iBAAAy/B,GAEA74B,EAAAq1B,OAAA,EACA9S,EAAAsW,EAAAhF,KAGA,QAAAkF,KACA,aAAA/4B,EAAA+oB,eAAAqN,mBAAA,cAAAp2B,EAAA+oB,eAAAuN,oBAAA,cAAAt2B,EAAA+oB,eAAAuN,oBAGAt2B,EAAAi2B,eAAA,SAAA4B,GACA73B,EAAA0G,OAAAzJ,IAAA,2BACA+C,EAAAi2B,eAAA3+B,OACA0I,EAAA5G,KAAA,cAAAy+B,GACAW,KAEAx4B,EAAAk2B,oBACAl2B,EAAAi2B,kBATAuC,IAcA,QAAAQ,GAAAF,EAAAz+B,GACA2F,EAAA0G,OAAAkK,MAAA,kBAAAkoB,EAAA,WACA94B,EAAA0G,OAAAkK,MAAAvW,GACA2F,EAAAq1B,OAAA,EACA7S,EAAAnoB,GAzCA,GACAy+B,GADA94B,EAAAzJ,IA4CAyJ,GAAAq1B,OAAA,EAEAyD,EAAA94B,EAAAyoB,SAAA,UAAA,eAAA,cAEAzoB,EAAA+oB,eAAA+P,GACA,SAAAG,GACAj5B,EAAA+oB,eAAAmQ,oBACAD,EACAF,EACAC,EAAA3gC,KAAA,KAAA,yBAGA2gC,EAAA3gC,KAAA,KAAAygC,GACA/xB,KAIAkwB,WAAcT,UAAA,EAAAh6B,MAAA,SAAAC,EAAA8lB,EAAAC,GACd,IACAjsB,KAAAwyB,eAAAkO,UAAAx6B,GACK,MAAApC,GAIL,MAHA9D,MAAAmQ,OAAAkK,MAAA,uBACAra,KAAAmQ,OAAAkK,MAAAvW,OACAmoB,GAAAnoB,GAIAkoB,MAGA4W,kBAAqB3C,UAAA,EAAAh6B,MAAA,SAAA48B,EAAAx4B,GACrBrK,KAAAg8B,kBAAAz1B,QAAA,SAAAL,GACAA,EAAA28B,KAAAt8B,QAAA,SAAAC,GACAA,EAAAs8B,SAAAz4B,QAKA62B,iBAAoBjB,UAAA,EAAAh6B,MAAA,SAAAoE,GACpBrK,KAAA4iC,iBAAA,iBAAAv4B,KAGA82B,iBAAoBlB,UAAA,EAAAh6B,MAAA,SAAAoE,GACpBrK,KAAA4iC,iBAAA,iBAAAv4B,OAKAgB,I5B2pPM,SAASxL,EAAQD,G6B3oQvBC,EAAAD,QAAA,SAAA0C,GAGA,GAAAwD,GAAA,SAAAqK,EAAA4yB,GACA,IAAAzgC,EAAAuD,OAAAg3B,cACA,KAAA,IAAAv6B,GAAA4I,WAAA4Y,kBAAA,sBAGA,IAAA3hB,IACA,mBACA,YACA,kBAEAnC,MAAAq0B,UAAA0O,IACAvyB,aAAkBC,OAAA,EAAAC,OAAA,IAGlB1Q,KAAAmQ,OAAAA,EACAnQ,KAAAob,WAAAjZ,GAKAnC,KAAAoG,gBA8GA,OA5GAN,GAAAK,SAAA,SAAAD,GACA,MAAAA,GAAA86B,iBAAAhJ,OAAA9xB,EAAA+6B,kBACA+B,IAAA,SAAAx8B,GACA,MAAAA,GAAAnG,KAEAwT,KAAA,KAGA/N,EAAA8K,OAAA,SAAA1K,EAAA+8B,GAKA,QAAAC,GAAAC,EAAAj9B,IACA9B,OAAAg/B,mBAAAA,GAAAD,EAAAj9B,GACAm9B,EAAAF,GAGA,QAAAC,GAAAD,EAAAj9B,GACA,GAAA,mBAAAi9B,GAAAG,IACAC,IAAAC,gBAAAL,EAAAG,KACAH,EAAAG,IAAAC,IAAAE,gBAAAv9B,OACK,CAAA,GAAA,oBAAAi9B,EAAAO,WAAAP,EAAAQ,cAGL,OAAA,CAFAR,GAAAO,UAAAP,EAAAQ,aAAAz9B,EAKA,OAAA,EAGA,QAAAm9B,GAAAO,GACA,GAAAC,GAAA,GACAD,GAAAE,wBAAAxhC,EAAA6I,OAAAilB,YAAA,WACAwT,EAAAG,OACAH,EAAAI,OAGA1hC,EAAA6I,OAAA8kB,cAAA2T,EAAAE,0BAEKD,GA/BL,MAAAZ,IAkCAA,EAAAvyB,QACAuyB,EAAAxyB,QACAwyB,EAAAvyB,MAAAuzB,OAAA,GAEAf,EAAAD,EAAAvyB,MAAAxK,SAEA+8B,EAAAxyB,OACAyyB,EAAAD,EAAAxyB,MAAAvK,MAxCA,GA4CAJ,EAAAC,UAAAJ,OAAAC,OAAAtD,EAAA+C,aAAAU,WACA46B,SAAc16B,MAAA,SAAA+lB,EAAAC,EAAAoI,GACdA,EAAA1uB,OAAAg8B,KAAAtN,OAA2C3qB,OAAA2qB,EAAAr0B,KAAAq0B,SAE3C,IAAA6P,GAAA,SAAAlY,EAAA9lB,EAAAi+B,GACA,GAAAh+B,GAAAL,EAAAK,SAAAD,EACAlG,MAAAoG,aAAAD,KAAAg+B,EACAnY,EAAA9lB,IACKpE,KAAA9B,KAAAgsB,EAEL,IAAAqI,EAAAnuB,OACAg+B,EAAA7P,EAAAnuB,QAAA,OACK,CAEL,GAAAsK,GAAA6jB,EAAA7jB,aACAxQ,KAAAq0B,WAAAr0B,KAAAq0B,UAAA7jB,cACSC,OAAA,EAAAC,OAAA,EAMTpO,GAAA6I,OAAAxH,WAAA,WACA3D,KAAA6C,KAAA,mBAAA2N,EAEA,IAAA4zB,GAAA,SAAAC,EAAA/L,GACA,GAAAgM,GAAAv8B,MAAAhC,UAAAuL,MAAA/Q,KAAAub,UAAA,GAEAyoB,GAAAF,GAAArM,OAAAsM,EAEAtkC,MAAA6C,KAAAiN,MAAA9P,KAAAukC,GAEAjM,EAAAxoB,MAAA,KAAAw0B,IACSxiC,KAAA9B,KAETsC,GAAAuD,OAAA2+B,aACAh0B,EACA4zB,EAAAtiC,KAAA9B,KAAA,YAAAkkC,GACAE,EAAAtiC,KAAA9B,KAAA,kBAAAisB,KAEOnqB,KAAA9B,MAAA,MAIPgG,SAAcC,MAAA,SAAAC,GACd,GAAAC,GAAAL,EAAAK,SAAAD,EACAlG,MAAAoG,aAAAD,MAAA,GACAD,EAAAG,aAEArG,MAAAoG,aAAAD,OAKAL,I7B2pQM,SAASjG,EAAQD,G8BpyQvBC,EAAAD,QAAA,SAAA6L,EAAArH,EAAAiH,EAAAvF,GACA,GAAAD,EAEAA,MAEAA,EAAAwF,aAAAA,EACAxF,EAAAC,mBAAAA,CAEA,IAAA2+B,EAsBA,OApBA5+B,GAAAg3B,YAAA,WACA,MAAA97B,UAAA0jC,EACAA,GAGA5+B,EAAA6+B,YAAAj5B,EAAAyF,oBAAA9M,EAAA,eACAyB,EAAA2+B,aAAA/4B,EAAAyF,oBAAA9M,EAAAugC,UAAA,gBACA9+B,EAAAw5B,kBAAA5zB,EAAAyF,oBAAA9M,EAAA,qBACAyB,EAAAg7B,sBAAAp1B,EAAAyF,oBAAA9M,EAAA,yBAEAyB,EAAA2+B,cAAA3+B,EAAAw5B,mBAAAx5B,EAAAg7B,uBACAh7B,EAAA2+B,aAAA3+B,EAAA2+B,aAAA1iC,KAAAsC,EAAAugC,WACAF,GAAA,GAGAA,GAAA,EAEAA,IAGA5+B,I9BgzQM,SAAShG,EAAQD,EAASM,I+Bl1QhC,SAAAwK,GASA7K,EAAAD,QAAA,SAAA0C,GACA,GAAAwQ,GACAvQ,GAEAqiC,YAAA,EACA5f,aAAA,EACA2C,mBAAA,EACAkd,iBAAA,EAGAC,oBAAA,EACAC,cAAA,EAMAvvB,eACAojB,OAAA,SACAjV,QAAA,WAGApO,iBACA,MACA,SACA,MACA,UACA,OACA,UAGAyvB,qBACA,kBACA,0BAGAja,aAAA,GACAhY,WAAA,GAGAD,GAAA,SAAAkT,GAiBA,QAAA2Y,GAAA/xB,GAEA,MAAAnD,GAAA5G,KAAAf,KAAA2H,EAAAmD,GAlBA,GAaA4E,GAAAyzB,EAbAx7B,EAAAzJ,KACAmC,GACA,aACA,YACA,eACA,iBACA,uBACA,aACA,eACA,qBACA,SACA,aACA,UASA,KAAAqP,EAAA,EAAAyzB,EAAA1iC,EAAAgT,gBAAA7L,OAA6Cu7B,EAAAzzB,EAASA,IACtDrP,EAAAiF,KAAA7E,EAAAgT,gBAAA/D,GAAA7J,cAIApF,GAAAyiC,oBAAAziC,EAAAyiC,oBAAAhzB,WAEAhS,KAAA0G,IAAA,GAAApE,GAAA2I,cACAjL,KAAAmQ,OAAAnQ,KAAA0a,UAAA,UAEA1a,KAAAklC,OACArS,gBAGA7yB,KAAAgmB,iBACAhmB,KAAAqyB,WAGAryB,KAAA40B,cAEA50B,KAAAsc,QACAtc,KAAA84B,YACA94B,KAAAi+B,iBACAj+B,KAAA0H,UAAA,KACA1H,KAAA0B,QAAA,KACA1B,KAAA6jB,OAAAthB,EAAAqiC,YACA5kC,KAAAqa,MAAA,KACAra,KAAAioB,cACAsI,QACAlI,QACAiI,OACApI,QAGAloB,KAAAmlC,yBAAA,EACAnlC,KAAAolC,uBAAA,KAEAz/B,OAAAiF,iBAAA5K,MACAqlC,mBACAx6B,IAAA,WACA,GAAA+B,GACAqb,GAAA,OAAA,OAAA,MAAA,OACAqd,EAAA,CAEA,KAAA14B,IAAAqb,GACAqd,GAAA3/B,OAAAg8B,KAAA3hC,KAAAioB,aAAAA,EAAArb,KAAAlD,MAGA,OAAA47B,KAIAC,uBACA16B,IAAA,WACA,MAAAlF,QAAAg8B,KAAA3hC,KAAAioB,aAAA,MAAAve,SAIA87B,uBACA36B,IAAA,WACA,MAAAlF,QAAAg8B,KAAA3hC,KAAAioB,aAAA,MAAAve,SAIA+7B,sBACA56B,IAAA,WACA,MAAAlF,QAAAg8B,KAAA3hC,KAAAioB,aAAA,KAAAve,SAIAg8B,sBACA76B,IAAA,WACA,MAAAlF,QAAAg8B,KAAA3hC,KAAAioB,aAAA,KAAAve,WAYA3I,SAAAilB,EACAA,MACG,gBAAAA,IAAAA,YAAAvN,WACHuN,GACA/d,IAAA+d,IAKAA,EAAAtf,MACAsf,EAAAtf,IAAAoU,eAAA,oBACA9a,KAAA0G,IAAA6T,eAAAyL,EAAAtf,IAAA6T,gBAGAyL,EAAAtf,IAAAoU,eAAA,WACA9a,KAAA0G,IAAA8B,MAAAwd,EAAAtf,IAAA8B,OAGAwd,EAAAtf,IAAAoU,eAAA,eACA9a,KAAA0G,IAAA8T,UAAAwL,EAAAtf,IAAA8T,WAIA,KACAxa,KAAA2lC,WAAA3f,GACAhmB,KAAAob,WAAAjZ,GACG,MAAA2B,GAGH,KAFA9D,MAAA6jB,OAAAthB,EAAAsiC,iBACA7kC,KAAAqa,MAAA9X,EAAAuiC,oBACAhhC,EAIA9D,KAAA4lC,gBAAA,GAAAtjC,GAAA8wB,gBAAApzB,MACAA,KAAA4lC,gBAAA/jC,GAAA,SAAA88B,EAAA,uBACA3+B,KAAA4lC,gBAAA/jC,GAAA,aAAA88B,EAAA,eACA3+B,KAAA4lC,gBAAA/jC,GAAA,eAAA88B,EAAA,iBAEA3+B,KAAAgmB,cAAAvd,WACAzI,KAAA4I,QAGA,kBAAA8B,GAAArG,kBACAqG,EAAArG,iBAAA,SAAArE,KAAAqG,KAAAvE,KAAA9B,QAGA8S,EAAA/M,UAAA,GAAAzD,GAAA+C,aAMAyN,EAAA/M,UAAAY,SAAA,SAAA/F,GAIA,MAHAZ,MAAAgmB,cAAArf,UAAA,EACA3G,KAAA4lC,gBAAAj/B,SAAA/F,GAEAZ,MASA8S,EAAA/M,UAAAxB,WAAA,SAAA3D,GAIA,MAHAZ,MAAAgmB,cAAArf,UAAA,EACA3G,KAAA4lC,gBAAArhC,WAAA3D,GAEAZ,MAGA8S,EAAA/M,UAAA/D,aAAA,WACA,MAAAhC,MAAA4lC,gBAAA9R,YAOAhhB,EAAA/M,UAAA8/B,YAAA,WACA,MAAA7lC,MAAA0H,UAAA1H,KAAA0H,UAAA6d,WAAA,GAaAzS,EAAA/M,UAAA6yB,OAAA,SAAAnuB,EAAA7J,GACAA,EAAAA,MACAA,EAAA0B,EAAAmJ,MAAA4E,sBAAAzP,GACA0B,EAAAmJ,MAAAsE,gBAAAnP,EAAA,QAAA,oBAAA,EAAAZ,KAAAmQ,OAEA,IAAA21B,GAAA,GAAAxjC,GAAAyzB,oBAAA/1B,KAAAyK,EAAA7J,EASA,OAPAZ,MAAA6lC,cACAC,EAAAlN,QAAoBroB,MAAA3P,EAAA2P,QAEpBvQ,KAAA4b,KAAA,YAAA,WACAkqB,EAAAlN,QAAsBroB,MAAA3P,EAAA2P,UAGtBu1B,GAGAhzB,EAAA/M,UAAA83B,UAAA,SAAApzB,EAAA4K,EAAAzU,GACA,GAAAk9B,GAAA,GAAAx7B,GAAAm7B,aAAAz9B,KAAAyK,EAAA4K,EAAAzU,EASA,OAPAZ,MAAA6lC,cACA/H,EAAAD,YAEA79B,KAAA4b,KAAA,YAAA,WACAkiB,EAAAD,cAGAC,GAaAhrB,EAAA/M,UAAA4d,QAAA,SAAAlZ,EAAAkH,EAAA/Q,GACA,GAAAG,SAAA4Q,EACA,KAAA,IAAA+J,WAAA,uBAGA9a,GAAAA,MACAA,EAAA4zB,YAAA5zB,EAAA4zB,aAAA,aACA5zB,EAAA+Q,KAAAA,CAEA,IAAAo0B,GAAA,GAAAzjC,GAAAqxB,cAAA3zB,KAAAsC,EAAAC,EAAAic,QAAA/T,EAAA7J,EAUA,OARAZ,MAAA6lC,cACAE,EAAApgB,OAEA3lB,KAAA4b,KAAA,YAAA,WACAmqB,EAAApgB,SAIAogB,GAGAjzB,EAAA/M,UAAAgoB,QAAA,SAAA/F,EAAAvd,EAAA7J,GACA,GAAAolC,GAAA,GAAA1jC,GAAAqxB,cAAA3zB,KAAAgoB,EAAAvd,EAAA7J,EAUA,OARAZ,MAAA6lC,cACAG,EAAArgB,OAEA3lB,KAAA4b,KAAA,YAAA,WACAoqB,EAAArgB,SAIAqgB,GAOAlzB,EAAA/M,UAAAM,KAAA,WAIA,QAAA4/B,KACA,IAAAtkC,EAAA6jC,uBAAA,IAAA7jC,EAAA4jC,wBACA5jC,EAAAoa,IAAA,uBAAAkqB,GACAtkC,EAAA+F,UAAAue,cANA,GAAAxiB,GAAAyiC,EAAAvV,EACAhvB,EAAA3B,IAWA,IAFAA,KAAAmQ,OAAAzJ,IAAA,6BAEA1G,KAAA6jB,SAAAthB,EAAAolB,mBAEA,MADA3nB,MAAAmQ,OAAA7I,KAAA,qBACAtH,IAIAsC,GAAA6I,OAAA+a,aAAAlmB,KAAAolC,wBAGAplC,KAAAmQ,OAAAzJ,IAAA,2BACA1G,KAAA4lC,gBAAAxf,OAGA,KAAA3iB,IAAAzD,MAAA84B,SACA94B,KAAAmQ,OAAAzJ,IAAA,mBAAAjD,GACAzD,KAAA84B,SAAAr1B,GAAA8uB,WAIA,KAAA2T,IAAAlmC,MAAAi+B,cACAj+B,KAAAmQ,OAAAzJ,IAAA,mCAAAw/B,GACAlmC,KAAAi+B,cAAAiI,GAAA9f,OAIA,KAAAuK,IAAA3wB,MAAA40B,WACA50B,KAAA40B,WAAAjE,GAAAvK,OAmBA,OAhBApmB,MAAA6jB,OAAAthB,EAAAolB,mBAUA,IAAA3nB,KAAAwlC,uBAAA,IAAAxlC,KAAAulC,sBACAvlC,KAAA0H,UAAAue,aAEAjmB,KAAA6B,GAAA,uBAAAokC,GAGAjmC,MAQA8S,EAAA/M,UAAA6C,MAAA,WACA,GAAAuc,EAgBA,OAdAnlB,MAAAmQ,OAAAzJ,IAAA,6BACA1G,KAAA6jB,SAAAthB,EAAAqiC,aACAzf,EAAAnlB,KAAAmmC,kBACA,GAAA7jC,GAAAyiB,UAAA/kB,KAAAmlB,IACGnlB,KAAA6jB,SAAAthB,EAAAolB,oBACH3nB,KAAAmQ,OAAAzJ,IAAA,YACA1G,KAAA6jB,OAAAthB,EAAAyiB,aACAhlB,KAAA0H,UAAAge,WACG1lB,KAAA6jB,SAAAthB,EAAAyiB,aACHhlB,KAAAmQ,OAAAzJ,IAAA,uCAEA1G,KAAAmQ,OAAAkK,MAAA,iEAGAra,MAUA8S,EAAA/M,UAAAwN,gBAAA,SAAA9I,GACA,MAAAnI,GAAAmJ,MAAA8H,gBAAA9I,EAAAzK,KAAAgmB,cAAAogB,iBAQAtzB,EAAA/M,UAAAsgC,gBAAA,SAAAxT,GAIA,MAHA7yB,MAAAklC,MAAArS,YAAAA,EAAAyT,OAAAtmC,KAAAklC,MAAArS,YAAAA,EAAAyT,WACAtmC,KAAAklC,MAAArS,YAAAA,EAAAyT,OAAAzT,EAAA5qB,KAAA4qB,EAEA7yB,MAGA8S,EAAA/M,UAAAwgC,eAAA,SAAAxY,GACA,GAAAuY,GAAAzT,CASA,OAPAyT,GAAAvY,EAAA1D,KAAAjX,KAEApT,KAAAklC,MAAArS,YAAAyT,IAAAtmC,KAAAklC,MAAArS,YAAAyT,GAAAvY,EAAA1D,QACAwI,EAAA7yB,KAAAklC,MAAArS,YAAAyT,GAAAvY,EAAA1D,MACAwI,EAAA7K,OAAA+F,EAAA/F,QAGA6K,GAGA/f,EAAA/M,UAAA2U,UAAA,SAAAT,EAAAC,GACA,MAAAla,MAAA0G,IAAAgU,UAAAT,EAAAC,IAcApH,EAAA/M,UAAAqhB,kBAAA,SAAA1f,GAEA,GAAAkF,GAAAgD,EAAAlG,EACA88B,GAAA,OAAA,MAAA,OAAA,MAMA,KAJA9+B,EAAAyd,OAAAtB,OAAAvhB,EAAAyiB,UAAAxiB,EAAA0iB,oBACAjlB,KAAAmQ,OAAAzJ,IAAA,2BAAApE,EAAAyiB,UAAAxiB,EAAA0iB,qBAEAvb,EAAA88B,EAAA98B,OACAkD,EAAA,EAAgBlD,EAAAkD,EAAeA,IAC/B,IAAAgD,IAAA5P,MAAAioB,aAAAue,EAAA55B,IACA5M,KAAAioB,aAAAue,EAAA55B,IAAAgD,GAAAlM,kBAKA1D,MAAA0B,QAAAgqB,UACA1rB,KAAAymC,iCAYA3zB,EAAA/M,UAAArC,iBAAA,SAAAgE,GACA,GAAAyd,EAEAnlB,MAAAmQ,OAAAzJ,IAAA,aAAAgB,EAAAyd,OAAAgB,OAAA,qCAAA7jB,EAAAyiB,UAAAxiB,EAAA2iB,cAIAxd,EAAAyd,OAAAtB,OAAAvhB,EAAAyiB,UAAAxiB,EAAA2iB,aAEAllB,KAAA6C,KAAA,gBACA6E,UAAAA,IAIA1H,KAAA6jB,SAAAthB,EAAAolB,qBAIAxC,EAAAnlB,KAAAmmC,kBAEAhhB,EACA,GAAA7iB,GAAAyiB,UAAA/kB,KAAAmlB,IAEAnlB,KAAAymC,gCACAzmC,KAAAqa,OAAAra,KAAAqa,QAAA9X,EAAAwiC,gBACA/kC,KAAA6jB,OAAAthB,EAAAsiC,iBACA7kC,KAAAqa,MAAA9X,EAAAwiC,eAGA/kC,KAAA0mC,sBAUA5zB,EAAA/M,UAAAkhB,qBAAA,SAAAvf,GACA1H,KAAA0H,UAAAA,EAGA1H,KAAAmlC,yBAAA,EAEAz9B,EAAAyd,OAAAtB,OAAAvhB,EAAAyiB,UAAAxiB,EAAAyiB,aACAhlB,KAAAmQ,OAAAzJ,IAAA,2BAAApE,EAAAyiB,UAAAxiB,EAAAyiB,cAEAhlB,KAAA6jB,SAAAthB,EAAAolB,qBAIA3nB,KAAA6jB,OAAAthB,EAAAyiB,aACAhlB,KAAAqa,MAAA,KAEAra,KAAAgmB,cAAArf,UACA3G,KAAA4lC,gBAAA3e,uBAGAjnB,KAAA6C,KAAA,aACA6E,UAAAA,MAWAoL,EAAA/M,UAAAwgB,sBAAA,SAAA7e,EAAAi/B,GACA3mC,KAAA6C,KAAA,cACA6E,UAAAA,EACAi/B,SAAAA,KAUA7zB,EAAA/M,UAAAmoB,eAAA,SAAA5G,GACAtnB,KAAAioB,aAAAX,EAAA1a,MAAA0a,EAAAjnB,IAAAinB,EACAtnB,KAAA6C,KAAA,kBAA+BykB,YAAAA,KAS/BxU,EAAA/M,UAAAyoB,mBAAA,SAAAlH,SACAtnB,MAAAioB,aAAAX,EAAA1a,MAAA0a,EAAAjnB,IACAL,KAAA6C,KAAA,wBACAykB,YAAAA,KAcAxU,EAAA/M,UAAA+hB,eAAA,SAAAiG,GAOA,QAAA6Y,GAAA3+B,GACA,MAAAA,IAAAA,EAAA8L,OAAAga,EAAA1D,KAAAtW,KAPA,GAAA2c,GAAAjtB,EAAAkgB,EAEA2D,EADAU,EAAA+F,EAAA/F,OAEA6e,EAAA9Y,EAAA/F,OAAArgB,cACA8B,EAAAzJ,IAOA,MAAA4mC,EAAA5mC,KAAAgmB,cAAA/d,MACA2+B,EAAA5mC,KAAA0B,QAAAuG,MACA2+B,EAAA5mC,KAAA0B,QAAAgqB,WACAkb,EAAA5mC,KAAA0B,QAAAiqB,YAKA,MAJA3rB,MAAAmQ,OAAA7I,KAAA,yCACAymB,EAAA/F,SAAA1lB,EAAAC,EAAA4b,KACA4P,EAAA1B,SAAA,KAMA,IAAA0B,EAAA1D,KAAAiC,SAAAhqB,EAAAC,EAAAia,KAEA,WADAuR,GAAA1B,SAAA,IAKA,KAAA/pB,EAAAkuB,aAAAH,iBAAArwB,KAAA+tB,GAAA,CASA,GAAA/F,IAAA1lB,EAAAC,EAAAmc,QACA,GAAApc,GAAAkuB,aAAAjB,2BAAAxB,EAAA/tB,MACA+tB,EAAAhC,MAAA,IAAA,MACA,UAAAzpB,EAAAmJ,MAAA2J,kBAAApV,MACA,WAAAuC,EAAAyiC,0BAEG,IAAAhd,IAAA1lB,EAAAC,EAAAic,QAAA,CACH,IAAAxe,KAAAyV,cAAAoxB,GAIA,MAFA,IAAAvkC,GAAAkuB,aAAAjB,2BAAAxB,EAAA/tB,UACA+tB,GAAAhC,MAAA,IAAA,MAAA,UAAAzpB,EAAAmJ,MAAA2J,kBAAApV,OAGA2jB,GAAA,GAAArhB,GAAAuyB,cAAA70B,KAAA+tB,GACApK,EAAAhS,KAAAoc,EAAApc,KACAgS,EAAAmjB,aAAA/Y,EAAAvF,UAAA,iBAAA,aAEAuF,EAAAhC,MAAA,IAAA,MACA/rB,KAAA6C,KAAA,UAAA8gB,OACGqE,KAAA1lB,EAAAC,EAAAgc,QACHyJ,IAAA1lB,EAAAC,EAAA4b,MAEAmJ,EAAA,GAAAhlB,GAAAuyB,cAAA70B,KAAA+tB,GAIA,IAAAA,EAAApE,OAuCA+G,EAAA1wB,KAAA+mC,WAAAhZ,GAEA2C,GACA1I,IAAA1lB,EAAAC,EAAAgc,QACA,GAAAjc,GAAAkuB,aAAAZ,wBAAA7B,EAAA/tB,MAEA0wB,EAAA5I,eAAAiG,IACK/F,IAAA1lB,EAAAC,EAAAkc,QACLhb,EAAAzD,KAAAgnC,YAAAjZ,GACAtqB,EACAA,EAAAqkB,eAAAiG,IAEA/tB,KAAAmQ,OAAA7I,KAAA,sDACAymB,EAAAhC,MAAA,IAAA,iCASA/D,IAAA1lB,EAAAC,EAAA4b,KACA4P,EAAAhC,MAAA,SA7DA,QAAA/D,GACA,IAAA1lB,GAAAC,EAAAgc,OACA,GAAAqe,GAAA58B,KAAAgmB,cAAAoM,oBAAAyK,aACAD,GAAAA,IACAn5B,EAAA,GAAAnB,GAAAwzB,oBAAA91B,KAAA+tB,GACAlsB,GAAA,SAAA,WACA4H,EAAA5G,KAAA,SAAA7C,SAGAA,KAAAmQ,OAAA7I,KAAA,+CACAymB,EAAAhC,MAAA,KAEA,MACA,KAAAzpB,GAAAC,EAAA6b,IAEA2P,EAAAhC,MAAA,IACA,MACA,KAAAzpB,GAAAC,EAAA8b,OACA5a,EAAAzD,KAAAgnC,YAAAjZ,GACAtqB,EACAA,EAAAqkB,eAAAiG,GAEA/tB,KAAAmQ,OAAA7I,KAAA,qDAEA,MACA,KAAAhF,GAAAC,EAAA4b,IAKA,KACA,SACA4P,EAAAhC,MAAA,QA6CAjZ,EAAA/M,UAAAihC,YAAA,SAAAjZ,GACA,MAAA/tB,MAAA84B,SAAA/K,EAAAjE,QAAAiE,EAAAtE,WACAzpB,KAAA84B,SAAA/K,EAAAjE,QAAAiE,EAAApE,SACA,MASA7W,EAAA/M,UAAAghC,WAAA,SAAAhZ,GACA,MAAA/tB,MAAAqyB,QAAAtE,EAAAjE,QAAAiE,EAAAtE,SAAAsE,EAAApE,SACA3pB,KAAAqyB,QAAAtE,EAAAjE,QAAAiE,EAAApE,OAAAoE,EAAAtE,WACA,MAQA3W,EAAA/M,UAAAogC,gBAAA,WAEA,GAAAv2B,GAAAlG,EAAAu9B,EACAC,IAGA,KADAx9B,EAAA1J,KAAAgmB,cAAAxe,UAAAkC,OACAkG,EAAA,EAAelG,EAAAkG,EAAcA,IAC7Bq3B,EAAAjnC,KAAAgmB,cAAAxe,UAAAoI,GAEAq3B,EAAApjB,SAAAvhB,EAAAyiB,UAAAxiB,EAAA2iB,eAEK,IAAAgiB,EAAAx9B,OACLw9B,EAAA9/B,KAAA6/B,GACKA,EAAAE,OAAAD,EAAA,GAAAC,OACLD,GAAAD,GACKA,EAAAE,SAAAD,EAAA,GAAAC,QACLD,EAAA9/B,KAAA6/B,GAMA,OAFAr3B,GAAA+C,KAAAwC,MAAAxC,KAAAC,SAAAs0B,EAAAx9B,QAEAw9B,EAAAt3B,IAOAkD,EAAA/M,UAAA0gC,8BAAA,WACA,GAAA72B,EAGA,KAAAA,IAAA5P,MAAA84B,SACA94B,KAAA84B,SAAAlpB,GAAAlM,kBAGA1D,MAAA4lC,gBAAAxe,qBAGAtU,EAAA/M,UAAA2gC,iBAAA,SAAA/kC,GACA,GAAAiO,GAAAlG,EAAAiP,EAAAyuB,EAAA9B,EAAAngB,CAMA,KAJAxjB,EAAAA,GAAA3B,KACAslC,EAAA3jC,EAAAwjC,yBAEAz7B,EAAA/H,EAAAqkB,cAAAxe,UAAAkC,OACAkG,EAAA,EAAelG,EAAAkG,EAAcA,IAC7BjO,EAAAqkB,cAAAxe,UAAAoI,GAAAiU,OAAA,CAGAsB,GAAAxjB,EAAAwkC,kBAEAxtB,EAAAhG,KAAAwC,MAAAxC,KAAAC,SAAAD,KAAA00B,IAAA,EAAA/B,GAAA,GACA8B,EAAAzuB,EAAAhX,EAAAqkB,cAAAshB,8BAEAF,EAAAzlC,EAAAqkB,cAAAuhB,gCACAvnC,KAAAmQ,OAAAzJ,IAAA,6FACA0gC,EAAAzlC,EAAAqkB,cAAAshB,8BACAhC,EAAA,GAGAtlC,KAAAmQ,OAAAzJ,IAAA,8BAAA0gC,EAAA,YAEApnC,KAAAolC,uBAAA9iC,EAAA6I,OAAAxH,WACA,WACAhC,EAAAwjC,yBAAAG,EAAA,EACA,GAAAhjC,GAAAyiB,UAAApjB,EAAAwjB,IACK,IAAAiiB,IAQLt0B,EAAA/M,UAAA4/B,WAAA,SAAA3f,GA6DA,QAAAwhB,GAAA/jB,EAAAtT,GACA,GAAAs3B,GAAAhkB,EAAAxS,QAAA,gBAAA,SAAAzQ,GACA,MAAAA,GAAA,GAAA,IAAAA,EAAA,GAAAmH,eAGA,IAAA8b,IAAAgkB,EAAA,CAIA,GAAAC,GAAA1hB,EAAAlL,eAAA2I,EACAuC,GAAAlL,eAAA2sB,KACAt3B,EAAA7I,KAAAmgC,EAAA,8BAAAhkB,GACAikB,GACAv3B,EAAA7I,KAAAmc,EAAA,eAAAgkB,IAIAzhB,EAAAvC,GAAAikB,EAAA1hB,EAAAvC,GAAAuC,EAAAyhB,IA5EA,GAAAhkB,GAAAxd,EAAA0hC,EAAAvB,EAAA7S,EACAqU,GAIA3Z,QAAA3rB,EAAAmJ,MAAA6G,kBAAA,IAAA;AAEArK,IAAA,GAAA3F,GAAAqR,IAAA,MAAA,aAAArR,EAAAmJ,MAAA6G,kBAAA,GAAA,oBAAA,KAAA,MACA9K,YACA8kB,OAAA,MACAxB,QAAA,2CACAjH,OAAA,EACAsjB,OAAA,EACAhhB,OAAA,6BAIAje,SAAA,KAGAurB,gBAAA,IACA9sB,UAAA,EACA4sB,gBAAA,KAGAjL,wBAAA,EACAC,4BAAA,EAEA+e,8BAAA,EACAC,8BAAA,GAEA1c,mBAAA,EAGAgB,gBAAAvpB,EAAAC,EAAAga,WAGA6e,gBAAA,GACA9yB,aAAA,gCACAC,eAGAF,UAAA,EAGA2lB,YAAA,EACA6Z,iBAAA,EACAC,oBAAA,EAGAr/B,WAAA,EAGAmjB,OAAAtpB,EAAAC,EAAAwb,UAAAC,YAEAoU,oBAAA9vB,EAAAuD,OAAAwF,aAAAsrB,eAyBA,KAAAlT,IAAA3Q,GAAAqqB,oBAAA4K,UAAA,CAEA,GADAP,EAAA/jB,EAAAzjB,KAAAmQ,SACA6V,EAAAlL,eAAA2I,GACA,KAAA,IAAAnhB,GAAA4I,WAAAqY,mBAAAE,EAIA,IAFAxd,EAAA+f,EAAAvC,GACAkkB,EAAA70B,EAAAqqB,oBAAA4K,UAAAtkB,GAAAxd,GACAlF,SAAA4mC,EAGA,KAAA,IAAArlC,GAAA4I,WAAAqY,mBAAAE,EAAAxd,EAFA2hC,GAAAnkB,GAAAkkB,EAOArlC,EAAAmJ,MAAAsE,gBAAAiW,EAAA,SAAA,YAAA,EAAAhmB,KAAAmQ,OAAA7N,EAAAC,EAAAwb,UAAAC,YAEA,IAAAgqB,IAAA,cAAA,cAGA,KAAAvkB,IAAA3Q,GAAAqqB,oBAAAtB,SAEA,GADA2L,EAAA/jB,EAAAzjB,KAAAmQ,QACA6V,EAAAlL,eAAA2I,GAAA,CAIA,GAHAxd,EAAA+f,EAAAvC,GAGAxd,YAAA8B,QAAA,IAAA9B,EAAAyD,QAAAs+B,EAAAp2B,QAAA6R,GAAA,EAAsG,QAGtG,IAAA,OAAAxd,GAAA,KAAAA,GAAAlF,SAAAkF,EAAiE,QAGjE,IAAA,gBAAA,IAAAkM,MAAAlM,GAA2D,QAG3D,IADA0hC,EAAA70B,EAAAqqB,oBAAAtB,SAAApY,GAAAxd,GACAlF,SAAA4mC,EAGA,KAAA,IAAArlC,GAAA4I,WAAAqY,mBAAAE,EAAAxd,EAFA2hC,GAAAnkB,GAAAkkB,EAUA,GAAAC,EAAAL,8BAAAK,EAAAN,8BACA,KAAA,IAAAhlC,GAAA4I,WAAAqY,mBAAA,gCAAAqkB,EAAAL,8BAMA,KAAAK,EAAAxc,cACAwc,EAAAxc,YAAA,KAIAwc,EAAAlU,aACAkU,EAAAlU,WAAApxB,EAAAmJ,MAAAuH,WAIA40B,EAAAtc,QAAAhpB,EAAAmJ,MAAA6G,kBAAA,GAGA8zB,EAAAwB,EAAA3/B,IAAA+kB,QACAoZ,EAAAryB,KAAA,KACA6zB,EAAAxB,eAAAA,EAAAp0B,WAAAf,QAAA,SAAA,IAKA22B,EAAAz/B,oBACAy/B,EAAAz/B,kBAAAy/B,EAAA3/B,IAAA8L,MAIA6zB,EAAArU,kBACAA,EAAAqU,EAAA3/B,IAAA+kB,QACAuG,EAAAxf,KAAA,KACA6zB,EAAArU,gBAAAA,GAIAqU,EAAAxM,gBAAA,IAAAwM,EAAAxM,gBAGAwM,EAAAC,kBACAD,EAAA3Z,QAAA3rB,EAAAmJ,MAAAsJ,sBAGA/U,KAAA0B,SACAgqB,SAAA,KACAC,UAAA,KACA1jB,IAAA,GAAA3F,GAAAqR,IAAA,MAAArR,EAAAmJ,MAAA6G,kBAAA,GAAAs1B,EAAA3Z,QAAA,MAAqFvmB,UAAAkgC,EAAA,mBAAA,MAAA,OACrF51B,SAAA,SAAApR,GACAA,EAAAA,KAEA,IACAm8B,GAAAn8B,EAAAm8B,WAAA,KACAC,EAAAp8B,EAAAo8B,UAAA,KACAt7B,EAAA,GAcA,OAXAA,IADAq7B,GACA/8B,KAAA2rB,WAAwE,OAAA3Z,YAExEhS,KAAA0rB,UAAA1rB,KAAAiI,KAAA+J,WAGAgrB,IACAt7B,GAAA,OAGAA,GAAA,MAOAY,EAAAmJ,MAAAsE,gBAAA63B,EAAA,QAAA,oBAAA,EAAA5nC,KAAAmQ,OAGA,KAAAsT,IAAAmkB,GACA90B,EAAAm1B,uBAAAxkB,GAAAxd,MAAA2hC,EAAAnkB,EAGA9d,QAAAiF,iBAAA5K,KAAAgmB,cAAAlT,EAAAm1B,uBAGA,KAAAxkB,IAAAmkB,GACA90B,EAAAm1B,uBAAAxkB,GAAAxd,MAAA,EAGAjG,MAAAmQ,OAAAzJ,IAAA,6CACA,KAAA+c,IAAAmkB,GACA,OAAAnkB,GACA,IAAA,MACA,IAAA,kBACA,IAAA,sBACAzjB,KAAAmQ,OAAAzJ,IAAA,KAAA+c,EAAA,KAAAmkB,EAAAnkB,GACA,MACA,KAAA,WACAzjB,KAAAmQ,OAAAzJ,IAAA,KAAA+c,EAAA,cACA,MACA,SACAzjB,KAAAmQ,OAAAzJ,IAAA,KAAA+c,EAAA,KAAA7I,KAAAC,UAAA+sB,EAAAnkB,OAWA3Q,EAAAm1B,uBAAA,WACA,GAAAr4B,GAAA6T,EACAykB,KACA1b,GAEA,UACA,iBAGA,MACA,YACA,oBACA,gCACA,gCACA,cACA,aACA,kBACA,qBACA,aACA,kBACA,WACA,kBACA,kBACA,WACA,SACA,kBACA,YACA,cACA,WACA,cACA,oBACA,0BACA,8BACA,sBACA,QACA,mBAGA,iBACA,UAGA,KAAA5c,IAAA4c,GACA/I,EAAA+I,EAAA5c,GACAs4B,EAAAzkB,IACAxd,MAAA,GACAg6B,UAAA,EACAkI,cAAA,EAUA,OANAD,GAAA,UACAjiC,MAAA,GACAg6B,UAAA,EACAkI,cAAA,GAGAD,KAQAp1B,EAAAqqB,qBACA4K,aAGAlM,UAEA5zB,IAAA,SAAAA,GACA,GAAA8gB,EAOA,OALA,SAAAxlB,KAAA0E,KACAA,EAAA3F,EAAAC,EAAAD,IAAA,IAAA2F,GAEA8gB,EAAAzmB,EAAAqR,IAAAN,MAAApL,GAEA8gB,GAEOA,EAAAhV,KAGPgV,EAJA,QASAvhB,UAAA,SAAAA,GACA,GAAAoI,GAAAlG,EAAA2D,CAQA,IAAA,gBAAA7F,GACAA,IAAsB2e,OAAA3e,QACf,CAAA,KAAAA,YAAAO,QAQP,MANA,KADA2B,EAAAlC,EAAAkC,OACAkG,EAAA,EAAqBlG,EAAAkG,EAAcA,IACnC,gBAAApI,GAAAoI,KACApI,EAAAoI,IAA8BuW,OAAA3e,EAAAoI,KAO9B,GAAA,IAAApI,EAAAkC,OACA,OAAA,CAIA,KADAA,EAAAlC,EAAAkC,OACAkG,EAAA,EAAmBlG,EAAAkG,EAAcA,IAAA,CACjC,IAAApI,EAAAoI,GAAAuW,OACA,MAEA,IAAA3e,EAAAoI,GAAAu3B,SAAAiB,OAAA5gC,EAAAoI,GAAAu3B,QACA,MAKA,IAFA95B,EAAA/K,EAAAsJ,QAAAyH,MAAA7L,EAAAoI,GAAAuW,OAAA,eAEA,KAAA9Y,EACA,MACS,IAAA,QAAAA,EAAAif,QAAA,OAAAjf,EAAAif,OACT,MAEA9kB,GAAAoI,GAAAkb,QAAA,QAAAzd,EAAA+F,MAAA/F,EAAAkf,KAAA,IAAAlf,EAAAkf,KAAA,IAAA,oBAEA/kB,EAAAoI,GAAAu3B,SACA3/B,EAAAoI,GAAAu3B,OAAA,GAGA3/B,EAAAoI,GAAAiU,OAAA,EACArc,EAAAoI,GAAA0c,OAAAjf,EAAAif,OAAAjb,cAGA,MAAA7J,IAGAW,kBAAA,SAAAA,GACA,MAAA,KAAA7F,EAAAsJ,QAAAyH,MAAA,IAAAlL,EAAA,IAAA,iBACA,OAEAA,GAIAo/B,8BAAA,SAAAA,GACA,GAAAthC,EACA,OAAA3D,GAAAmJ,MAAAwG,UAAAs1B,KACAthC,EAAAmiC,OAAAb,GACAthC,EAAA,GACAA,EAHA,QAQAqhC,8BAAA,SAAAA,GACA,GAAArhC,EACA,OAAA3D,GAAAmJ,MAAAwG,UAAAq1B,KACArhC,EAAAmiC,OAAAd,GACArhC,EAAA,GACAA,EAHA,QAQAmlB,YAAA,SAAAA,GACA,MAAA,KAAA9oB,EAAAsJ,QAAAyH,MAAA,IAAA+X,EAAA,IAAA,eACA,OAEAA,GAIA4C,WAAA,SAAAA,GACA,MAAA,iBAAAA,GACAA,EADA,QAKA6Z,gBAAA,SAAAA,GACA,MAAA,iBAAAA,GACAA,EADA,QAKAC,mBAAA,SAAAA,GACA,MAAA,iBAAAA,GACAA,EADA,QAKApU,WAAA,SAAAA,GACA,MAAA,gBAAAA,IAIA,UAAAnwB,KAAAmwB,KACAA,EAAAA,EAAArb,OAAA,IAGA,KAAA/V,EAAAsJ,QAAAyH,MAAAqgB,EAAA,QACA,OAEAA,GAXA,QAeA0H,gBAAA,SAAAA,GACA,GAAAn1B,EACA,OAAA3D,GAAAmJ,MAAAwG,UAAAmpB,KACAn1B,EAAAmiC,OAAAhN,GACAn1B,EAAA,GACAA,EAHA,QAQAiC,SAAA,SAAAA,GACA,MAAAuQ,QAAAvQ,IAGA0jB,OAAA,SAAAA,GACA,MAAAA,KAAAtpB,EAAAC,EAAAwb,UAAAG,SACA5b,EAAAC,EAAAwb,UAAAG,SACO0N,IAAAtpB,EAAAC,EAAAwb,UAAAE,UACP3b,EAAAC,EAAAwb,UAAAE,UAEA3b,EAAAC,EAAAwb,UAAAC,aAIArX,SAAA,SAAAA,GACA,MAAA,iBAAAA,GACAA,EADA,QAKA8sB,gBAAA,SAAAA,GACA,GAAAxtB,EACA,OAAA3D,GAAAmJ,MAAAwG,UAAAwhB,KACAxtB,EAAAmiC,OAAA3U,GACAxtB,EAAA,GACAA,EAHA,QAQAstB,gBAAA,SAAAA,GACA,GAAAxK,EAEA,IAAA,gBAAAwK,GASA,MALA,SAAAhwB,KAAAgwB,KACAA,EAAAjxB,EAAAC,EAAAD,IAAA,IAAAixB,GAEAxK,EAAAzmB,EAAAqR,IAAAN,MAAAkgB,GAEAxK,EAEOA,EAAAhV,KACP,OAEAgV,EAJA,QAQAzgB,YAAA,SAAAA,GACA,GAAAsH,GAAAlG,EAAA2+B,CAEA,IAAA,gBAAA//B,GACAA,GAAAA,OACO,MAAAA,YAAAP,QACP,MAIA,KADA2B,EAAApB,EAAAoB,OACAkG,EAAA,EAAmBlG,EAAAkG,EAAcA,IAAA,CAMjC,GALAy4B,EAAA//B,EAAAsH,GACA,WAAArM,KAAA8kC,KACAA,EAAA,QAAAA,GAGA,KAAA/lC,EAAAsJ,QAAAyH,MAAAg1B,EAAA,YACA,MAEA//B,GAAAsH,GAAAy4B,EAGA,MAAA//B,IAGAD,SAAA,SAAAA,GACA,MAAA,iBAAAA,GACAA,EADA,QAKAE,YAAA,SAAAA,GACA,GAAAqH,GAAAlG,EAAA4+B,EAAAj7B,CASA,KAPA9E,YAAAR,SAGAQ,GAAAA,IAGAmB,EAAAnB,EAAAmB,OACAkG,EAAA,EAAmBlG,EAAAkG,EAAcA,IAAA,CAOjC,GANA04B,EAAA//B,EAAAqH,GAEA04B,EAAAnjB,SACAmjB,EAAAnJ,MAAAmJ,EAAAnjB,UAGAmjB,EAAAnJ,OAAAmJ,EAAAvmC,WAAAumC,EAAApgC,SACA,MAQA,KALAogC,EAAAnJ,eAAAp3B,SACAugC,EAAAnJ,MAAAmJ,EAAAnJ,OAGAz1B,EAAA4+B,EAAAnJ,KAAAz1B,OACAkG,EAAA,EAAqBlG,EAAAkG,EAAcA,IAOnC,GANAvC,EAAAi7B,EAAAnJ,KAAAvvB,GAEA,WAAArM,KAAA8J,KACAA,EAAA,QAAAA,GAGA,KAAA/K,EAAAsJ,QAAAyH,MAAAhG,EAAA,YACA,OAIA,MAAA9E,IAGAsjB,gBAAA,SAAAA,GACA,MAAA,gBAAAA,GACAA,EADA,QAKAhB,kBAAA,SAAAA,GACA,MAAA,iBAAAA,GACAA,EADA,QAKAvC,wBAAA,SAAAA,GACA,GAAAriB,EACA,OAAA3D,GAAAmJ,MAAAwG,UAAAqW,KACAriB,EAAAmiC,OAAA9f,GACAriB,EAAA,GACAA,EAHA,QAQAsiB,4BAAA,SAAAA,GACA,GAAAtiB,EACA,OAAA3D,GAAAmJ,MAAAwG,UAAAsW,KACAtiB,EAAAmiC,OAAA7f,GACAtiB,EAAA,GACAA,EAHA,QAQAwC,UAAA,SAAAA,GACA,MAAA,iBAAAA,GACAA,EADA,QAKA2pB,oBAAA,SAAAA,GACA,MAAAA,aAAAmW,UACAnW,EADA,UAOAtf,EAAAvQ,EAAAA,EACAD,EAAAwQ,GAAAA,K/Bu1Q6BvS,KAAKX,EAAU,WAAa,MAAOI,WAI1D,SAASH,EAAQD,GgC9xTvBC,EAAAD,QAAA,SAAA0C,GACA,GAAAoJ,IACAgwB,aACAC,SAAA,SAAAhY,GACAA,EAAAhS,OACAgS,EAAAhS,KAAAgS,EAAAhS,KAAAV,QAAA,0BAAA,eAGAmxB,WAAA,SAAA9E,GAYA,MAAAA,GAAArsB,QAAA,gBAAA,uBAGAuqB,SAEAgN,UAAA,WACA,MAAAznC,UAAAqD,OAAAqkC,sBAGAhN,4BAAA,SAAA9X,GACA3jB,KAAAwoC,aAAA7kB,EAAAhS,OACAgS,EAAAhS,KAAAgS,EAAAhS,KAAAV,QAAA,SAAA,UAIAusB,qBAAA,SAAAF,GAeA,GAAAoL,GAAAC,CACA,IAAArL,EAAA1rB,QAAA,MAAA0rB,EAAA1rB,QAAA,MAAA,CAGA+2B,EAAArL,EAAA3U,MAAA,cACA,KAAA,GAAAnX,GAAA,EAAqBA,EAAAm3B,EAAAj/B,OAAiB8H,IAGtCm3B,EAAAn3B,GAAAQ,WAAA42B,OAAA,SAAA,GACAF,EAAApL,EAAA1rB,QAAA+2B,EAAAn3B,GAAAQ,YAAA22B,EAAAn3B,GAAAQ,WAAAtI,OACA,OAAA4zB,EAAAjlB,OAAAqwB,EAAA,KACApL,EAAAA,EAAAjlB,OAAA,EAAAqwB,GAAA,uBAAApL,EAAAjlB,OAAAqwB,KAIWC,EAAAn3B,GAAAQ,WAAA42B,OAAA,QAAA,IACXF,EAAApL,EAAA1rB,QAAA+2B,EAAAn3B,GAAAQ,WAAA2W,MAAA,OAAAggB,EAAAn3B,GAAAQ,WAAA2W,MAAA,MAAA3W,WAAAtI,OACA4zB,EAAAA,EAAAjlB,OAAA,EAAAqwB,GAAA,uBAAApL,EAAAjlB,OAAAqwB,IAIA,MAAApL,IAGA+E,yCAAA,SAAA/E,GAUA,MAAAA,GAAArsB,QAAA,kBAAA3O,EAAAmJ,MAAAsJ,wBAIA0jB,QACA0J,2BAAA,SAAA7E,GACA,GAAAQ,GAAA+K,CAEA,OAAAn9B,GAAA8vB,QAAAgN,cACAK,EAAAvL,EAAA1rB,QAAA,aACA,KAAAi3B,IACA/K,EAAAR,EAAAjlB,OAAAwwB,GACA/K,EAAAA,EAAA7sB,QAAA,sBACA,0CACAqsB,EAAAjlB,OAAA,EAAAwwB,GAAA/K,GAGAR,GAGA5E,qBAAA,SAAAj1B,GACAA,EAAA0uB,cACA1uB,EAAA0uB,aAAA/L,UAMA,OAAA1a,KhC+yTM,SAAS7L,EAAQD,GiC15TvBC,EAAAD,QAAA,SAAA0C,GA6BA,QAAAwmC,KACA,MAAAnlB,GAAA0G,MAAA,QAAA1G,EAAA0G,KAAAiC,OAAA,QACAP,EAAA,MACA,GAIA,QAAAgd,KACA,MAAAplB,GAAAgG,QACAhG,EAAAmG,QAAAzR,OAAA,EAAA,KAAA1W,EAAAqkB,cAAAsF,QADA,QAEAS,EAAA,MACA,GAKA,QAAAid,KACA,GAAA/D,GAAA3iC,EAAAmJ,MAAAqF,gBAAA6S,EAAAhS,MACAuY,EAAAvG,EAAA6E,UAAA,iBAEA,OAAA0B,GAAA+a,GACAlZ,EAAA,MACA,GAFA,OAMA,QAAAkd,KACA,GAAA5a,GAAAze,EACAs5B,EAAAvlB,EAAA8F,SACAK,EAAAnG,EAAAmG,QACAC,EAAApG,EAAAoG,IAEA,KAAApG,EAAAgG,OACA,GAAAhG,EAAAqE,SAAA1lB,EAAAC,EAAAgc,OAAA,CAEA,GADA8P,EAAA1sB,EAAAsmB,aAAAqI,IAAA3M,EAAAwE,YAEA,MAEA,KAAAvY,IAAAjO,GAAAsmB,aAAAqI,IAEA,GADAjC,EAAA1sB,EAAAsmB,aAAAqI,IAAA1gB,GACAye,EAAAN,QAAAtE,WAAAyf,GAAA7a,EAAAN,QAAAjE,UAAAA,GAAAuE,EAAAN,QAAAhE,OAAAA,EAEA,MADAgC,GAAA,MACA,MAIK,CAEL,GADAsC,EAAA1sB,EAAAsmB,aAAAsI,KAAA5M,EAAAwE,YAEA,MAEA,KAAAvY,IAAAjO,GAAAsmB,aAAAsI,KAEA,GADAlC,EAAA1sB,EAAAsmB,aAAAsI,KAAA3gB,GACAye,EAAAN,QAAAtE,WAAAyf,GAAA7a,EAAAN,QAAAjE,UAAAA,GAAAuE,EAAAN,QAAAhE,OAAAA,EAEA,MADAgC,GAAA,MACA,GASA,QAAAod,KACA,MAAAxlB,GAAA0F,WAAA,OAAA3f,OAAA,GACAyG,EAAA7I,KAAA,kFACA,GAFA,OAMA,QAAA8hC,KACA,GAAAnb,GAAAtsB,EAAAqkB,cAAAiI,OACA,OAAAtK,GAAA2F,IAAAlW,OAAA6a,GAAAltB,SAAA4iB,EAAA2F,IAAAiD,MACApc,EAAA7I,KAAA,wFACA,GAFA,OAMA,QAAA+hC,KACA,GACApE,GAAA3iC,EAAAmJ,MAAAqF,gBAAA6S,EAAAhS,MACAuY,EAAAvG,EAAA6E,UAAA,iBAEA,OAAA0B,GAAA+a,GACA90B,EAAA7I,KAAA,sGACA,GAFA,OAOA,QAAAgiC,KAKA,IAJA,GACAC,IAAA,OAAA,KAAA,UAAA,OAAA,OACA35B,EAAA25B,EAAA7/B,OAEAkG,KACA,IAAA+T,EAAA2G,UAAAif,EAAA35B,IAEA,MADAO,GAAA7I,KAAA,oCAAAiiC,EAAA35B,GAAA,4BACA,EAMA,QAAAmc,GAAAvoB,GACA,GAAA0R,GACA7R,EAAA,WAAAG,EAAA,IAAAlB,EAAAC,EAAAE,cAAAe,GAAA,OACA2oB,EAAAxI,EAAA0F,WAAA,OACA3f,EAAAyiB,EAAAziB,OACAkG,EAAA,CAEA,KAAAA,EAAUlG,EAAAkG,EAAcA,IACxBvM,GAAA,QAAA8oB,EAAAvc,GAAA,MAGAsF,GAAAyO,EAAA6E,UAAA,MAEA7E,EAAAgG,SACAzU,GAAA,QAAY5S,EAAAmJ,MAAAoH,UAGZxP,GAAA,OAAA6R,EAAA,OACA7R,GAAA,SAAAsgB,EAAA6E,UAAA,QAAA,OACAnlB,GAAA,YAAAsgB,EAAAmG,QAAA,OACAzmB,GAAA,SAAAsgB,EAAAoG,KAAA,IAAApG,EAAAqE,OAAA,OACA3kB,GAAA,OAEAqE,EAAAie,KAAAtiB,GA5JA,GAAAwkB,GACA1X,EACAwT,EAAAhiB,EAAA+F,EACA8hC,KACAC,KACA7/B,IA0JA4/B,GAAApiC,KAAA0hC,GACAU,EAAApiC,KAAA2hC,GACAS,EAAApiC,KAAA4hC,GACAQ,EAAApiC,KAAA6hC,GAEAQ,EAAAriC,KAAA+hC,GACAM,EAAAriC,KAAAgiC,GACAK,EAAAriC,KAAAiiC,GAEAz/B,EAAAxC,KAAAkiC,GAEAzhB,EAAA,SAAArnB,EAAAkpC,EAAAC,GACA,GAAA1E,GAAA2E,CASA,KAPAjmB,EAAAnjB,EACAmB,EAAA+nC,EACAhiC,EAAAiiC,EAEAx5B,EAAAxO,EAAA+Y,UAAA,mBAEAuqB,EAAAr7B,EAAAF,OACAu7B,KAEA,GADA2E,EAAAhgC,EAAAq7B,GAAAthB,GACAimB,KAAA,EACA,OAAA,CAIA,IAAAjmB,YAAArhB,GAAAslB,iBAEA,IADAqd,EAAAuE,EAAA9/B,OACAu7B,KAEA,GADA2E,EAAAJ,EAAAvE,GAAAthB,GACAimB,KAAA,EACA,OAAA,MAKA,IAAAjmB,YAAArhB,GAAAylB,iBAEA,IADAkd,EAAAwE,EAAA//B,OACAu7B,KAEA,GADA2E,EAAAH,EAAAxE,GAAAthB,GACAimB,KAAA,EACA,OAAA,CAMA,QAAA,GAGAtnC,EAAAulB,YAAAA,IjC+6TM,SAAShoB,EAAQD,GkCroUvBC,EAAAD,QAAA,SAAA6L,GACA,GAAAE,EA0JA,OAxJAA,GAAA,SAAAhK,GACA3B,KAAAmQ,OAAAxO,EAAA+Y,UAAA,8BACA1a,KAAA+B,SAAAJ,EAAAqkB,cAAA7d,kBACAnI,KAAAkI,SAAAvG,EAAAqkB,cAAA9d,SACAlI,KAAA6pC,OAAA,KACA7pC,KAAA8pC,GAAA,EACA9pC,KAAA+pC,MAAA,WACA/pC,KAAAqD,SAAA,MAYAsI,EAAA5F,UAAAotB,aAAA,SAAApF,EAAAiF,GASA,GANAhzB,KAAAgqC,UAAAhX,EAAAgX,UACAhqC,KAAAsmC,MAAAtT,EAAAsT,MACAtmC,KAAAiqC,MAAAjX,EAAAiX,MACAjqC,KAAAkqC,OAAAlX,EAAAkX,OACAlqC,KAAAkzB,MAAAF,EAAAE,MAEAlzB,KAAAgqC,WACA,GAAA,QAAAhqC,KAAAgqC,UAEA,MADAhqC,MAAAmQ,OAAA7I,KAAA,iFACA,MAGAtH,MAAAgqC,UAAA,KAGA,KAAAhqC,KAAAsmC,MAEA,MADAtmC,MAAAmQ,OAAA7I,KAAA,2DACA,CAGA,KAAAtH,KAAAiqC,MAEA,MADAjqC,MAAAmQ,OAAA7I,KAAA,2DACA,CAIA,IAAA0rB,EAAAmX,IACA,GAAAnX,EAAAmX,IAAAv4B,QAAA,QAAA,GACA5R,KAAAmqC,IAAA,WACK,CAAA,KAAAnX,EAAAmX,IAAAv4B,QAAA,YAAA,IAKL,MADA5R,MAAAmQ,OAAA7I,KAAA,6FACA,CAJAtH,MAAAmqC,IAAA,eAOAnqC,MAAAmqC,IAAA,IAoBA,OAfAnqC,MAAAgoB,OAAA+F,EAAA/F,OACAhoB,KAAAiI,IAAA8lB,EAAA1D,KACArqB,KAAA6pC,OAAAp+B,EAAA6G,kBAAA,IACAtS,KAAA8pC,IAAA,EACA9pC,KAAAoqC,cAGA,aAAApqC,KAAA8pC,KACA9pC,KAAA8pC,GAAA,EACA9pC,KAAA+pC,MAAA,YAIA/pC,KAAAqqC,qBAEA,GAQA1+B,EAAA5F,UAAAskC,kBAAA,WACA,GAAAC,GAAAC,CAGAD,GAAA7+B,EAAAiK,aAAA1V,KAAA+B,SAAA,IAAA/B,KAAAsmC,MAAA,IAAAtmC,KAAAkI,UAEA,SAAAlI,KAAAmqC,KAEAI,EAAA9+B,EAAAiK,aAAA1V,KAAAgoB,OAAA,IAAAhoB,KAAAiI,KAEAjI,KAAAqD,SAAAoI,EAAAiK,aAAA40B,EAAA,IAAAtqC,KAAAiqC,MAAA,IAAAjqC,KAAA+pC,MAAA,IAAA/pC,KAAA6pC,OAAA,SAAAU,IAEG,aAAAvqC,KAAAmqC,KAEHI,EAAA9+B,EAAAiK,aAAA1V,KAAAgoB,OAAA,IAAAhoB,KAAAiI,IAAA,IAAAwD,EAAAiK,aAAA1V,KAAA2R,KAAA3R,KAAA2R,KAAA,KAEA3R,KAAAqD,SAAAoI,EAAAiK,aAAA40B,EAAA,IAAAtqC,KAAAiqC,MAAA,IAAAjqC,KAAA+pC,MAAA,IAAA/pC,KAAA6pC,OAAA,aAAAU,IAEG,OAAAvqC,KAAAmqC,MAEHI,EAAA9+B,EAAAiK,aAAA1V,KAAAgoB,OAAA,IAAAhoB,KAAAiI,KAEAjI,KAAAqD,SAAAoI,EAAAiK,aAAA40B,EAAA,IAAAtqC,KAAAiqC,MAAA,IAAAM,KAQA5+B,EAAA5F,UAAAiM,SAAA,WACA,GAAAw4B,KAEA,KAAAxqC,KAAAqD,SACA,KAAA,IAAA2D,OAAA,sEAkBA,OAfAwjC,GAAApjC,KAAA,aAAApH,KAAAgqC,WACAQ,EAAApjC,KAAA,aAAApH,KAAA+B,SAAA,KACAyoC,EAAApjC,KAAA,UAAApH,KAAAsmC,MAAA,KACAkE,EAAApjC,KAAA,UAAApH,KAAAiqC,MAAA,KACAO,EAAApjC,KAAA,QAAApH,KAAAiI,IAAA,KACAuiC,EAAApjC,KAAA,aAAApH,KAAAqD,SAAA,KACArD,KAAAkqC,QACAM,EAAApjC,KAAA,WAAApH,KAAAkqC,OAAA,KAEAlqC,KAAAmqC,MACAK,EAAApjC,KAAA,OAAApH,KAAAmqC,KACAK,EAAApjC,KAAA,WAAApH,KAAA6pC,OAAA,KACAW,EAAApjC,KAAA,MAAApH,KAAA+pC,QAGA,UAAAS,EAAA32B,KAAA,OAQAlI,EAAA5F,UAAAqkC,YAAA,WACA,GAAAK,GAAArC,OAAApoC,KAAA8pC,IAAA93B,SAAA,GACAhS,MAAA+pC,MAAA,WAAA1xB,OAAA,EAAA,EAAAoyB,EAAA/gC,QAAA+gC,GAGA9+B,IlCwpUM,SAAS9L,EAAQD,GmC7zUvBC,EAAAD,QAAA,SAAA0C,GAOA,QAAAooC,GAAAC,EAAAC,GACA,QAAAC,KAAqB7qC,KAAAyP,YAAAk7B,EACrBE,EAAA9kC,UAAA6kC,EAAA7kC,UACA4kC,EAAA5kC,UAAA,GAAA8kC,GAGA,QAAAC,GAAAnnB,EAAAonB,EAAAC,EAAAnhB,EAAAlnB,EAAAsoC,GACAjrC,KAAA2jB,QAAAA,EACA3jB,KAAA+qC,SAAAA,EACA/qC,KAAAgrC,MAAAA,EACAhrC,KAAA6pB,OAAAA,EACA7pB,KAAA2C,KAAAA,EACA3C,KAAAirC,OAAAA,EAEAjrC,KAAA8K,KAAA,cAKA,QAAAuI,GAAA63B,GAm0BA,QAAAC,KACA,MAAAD,GAAAv2B,UAAAy2B,EAAAC,GAGA,QAAAxhB,KACA,MAAAuhB,GAuBA,QAAAE,GAAAC,GACA,QAAAC,GAAAC,EAAAC,EAAAC,GACA,GAAAjrC,GAAAkrC,CAEA,KAAAlrC,EAAAgrC,EAA0BC,EAAAjrC,EAAYA,IACtCkrC,EAAAV,EAAA95B,OAAA1Q,GACA,OAAAkrC,GACAH,EAAAI,QAAkCJ,EAAA9oC,OAClC8oC,EAAAR,OAAA,EACAQ,EAAAI,QAAA,GACW,OAAAD,GAAA,WAAAA,GAAA,WAAAA,GACXH,EAAA9oC,OACA8oC,EAAAR,OAAA,EACAQ,EAAAI,QAAA,IAEAJ,EAAAR,SACAQ,EAAAI,QAAA,GAcA,MATAC,KAAAP,IACAO,EAAAP,IACAO,EAAA,EACAC,GAAkCppC,KAAA,EAAAsoC,OAAA,EAAAY,QAAA,IAElCL,EAAAO,EAAAD,EAAAP,GACAO,EAAAP,GAGAQ,EAGA,QAAAC,GAAAjB,GACAkB,EAAAZ,IAEAA,EAAAY,IACAA,EAAAZ,EACAa,MAGAA,EAAA9kC,KAAA2jC,IAGA,QAAAoB,GAAAxoB,EAAAonB,EAAAQ,GACA,QAAAa,GAAArB,GACA,GAAAv5B,GAAA,CAYA,KAVAu5B,EAAAsB,KAAA,SAAAv1B,EAAAC,GACA,MAAAD,GAAAtJ,YAAAuJ,EAAAvJ,YACA,GACWsJ,EAAAtJ,YAAAuJ,EAAAvJ,YACX,EAEA,IAIAgE,EAAAu5B,EAAArhC,QACAqhC,EAAAv5B,EAAA,KAAAu5B,EAAAv5B,GACAu5B,EAAA/uB,OAAAxK,EAAA,GAEAA,IAKA,QAAA86B,GAAAvB,EAAAC,GACA,QAAAuB,GAAAt1B,GACA,QAAAwzB,GAAAmB,GAA4B,MAAAA,GAAA7zB,WAAA,GAAA/F,SAAA,IAAAX,cAE5B,MAAA4F,GACAhG,QAAA,MAAA,QACAA,QAAA,KAAA,OACAA,QAAA,QAAA,OACAA,QAAA,MAAA,OACAA,QAAA,MAAA,OACAA,QAAA,MAAA,OACAA,QAAA,MAAA,OACAA,QAAA,2BAAA,SAAA26B,GAA+D,MAAA,OAAAnB,EAAAmB,KAC/D36B,QAAA,wBAAA,SAAA26B,GAA+D,MAAA,MAAAnB,EAAAmB,KAC/D36B,QAAA,mBAAA,SAAA26B,GAA+D,MAAA,OAAAnB,EAAAmB,KAC/D36B,QAAA,mBAAA,SAAA26B,GAA+D,MAAA,MAAAnB,EAAAmB,KAG/D,GACAY,GAAAC,EAAAj7B,EADAk7B,EAAA,GAAA3kC,OAAAgjC,EAAArhC,OAGA,KAAA8H,EAAA,EAAmBA,EAAAu5B,EAAArhC,OAAqB8H,IACxCk7B,EAAAl7B,GAAAu5B,EAAAv5B,GAAAhE,WAWA,OARAg/B,GAAAzB,EAAArhC,OAAA,EACAgjC,EAAAp7B,MAAA,EAAA,IAAAuC,KAAA,MACA,OACA64B,EAAA3B,EAAArhC,OAAA,GACAgjC,EAAA,GAEAD,EAAAzB,EAAA,IAAAuB,EAAAvB,GAAA,IAAA,eAEA,YAAAwB,EAAA,QAAAC,EAAA,UAGA,GAAAE,GAAArB,EAAAC,GACAP,EAAAO,EAAAL,EAAAxhC,OAAAwhC,EAAA95B,OAAAm6B,GAAA,IAMA,OAJA,QAAAR,GACAqB,EAAArB,GAGA,GAAAD,GACA,OAAAnnB,EAAAA,EAAA2oB,EAAAvB,EAAAC,GACAD,EACAC,EACAO,EACAoB,EAAAhqC,KACAgqC,EAAA1B,QAIA,QAAA2B,GAAA31B,GACA,GAAAzF,GAAAq7B,EAAA,GAAA9kC,OAAAkP,EAAAvN,OAEA,KAAA8H,EAAA,EAAiBA,EAAAyF,EAAAvN,OAAc8H,IAC/Bq7B,EAAAr7B,GAAAyF,EAAAc,WAAAvG,GAAA,EAGA,OAAAq7B,GAGA,QAAAC,GAAAjE,GASA,QAAAkE,GAAAv9B,GACA,MAAA,mBAAA7J,OAAAI,UAAAiM,SAAAlC,MAAAN,MAAAA,EAGA,IAZA,GAMAib,GAAAjZ,EANAq7B,EAAAG,EAAAnE,GACAoE,EAAA,EACAC,KACAr7B,EAAAg7B,EAAAnjC,OACAyjC,KACA/wB,OAOA,CACA,KAAAvK,EAAAo7B,GACA,OAAAJ,EAAAI,IACA,IAAA,GACA7wB,EAAAhV,KAAA2lC,EAAAK,EAAAP,EAAAI,EAAA,MACAA,GAAA,CACA,MAEA,KAAA,GACA7wB,EAAAhV,KAAAikC,GACA4B,GACA,MAEA,KAAA,GACA7wB,EAAAwb,MACAqV,GACA,MAEA,KAAA,GACA5B,EAAAjvB,EAAAwb,MACAqV,GACA,MAEA,KAAA,GACA7wB,EAAA1S,QAAAmjC,EAAAI,EAAA,GACAA,GAAA,CACA,MAEA,KAAA,GACA7wB,EAAAJ,OAAA,GAAA,GACAixB,GACA,MAEA,KAAA,GACA7wB,EAAAA,EAAA1S,OAAA,GAAAtC,KAAAgV,EAAAwb,OACAqV,GACA,MAEA,KAAA,GACA7wB,EAAAhV,KAAAgV,EAAAJ,OAAAI,EAAA1S,OAAAmjC,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,KACAA,GAAA,CACA,MAEA,KAAA,GACA7wB,EAAAwb,MACAxb,EAAAhV,KAAA8jC,EAAAv2B,UAAAyH,EAAAA,EAAA1S,OAAA,GAAA2hC,IACA4B,GACA,MAEA,KAAA,GACAE,EAAA/lC,KAAAyK,GACAq7B,EAAA9lC,KAAA6lC,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,IAEA7wB,EAAAA,EAAA1S,OAAA,IACAmI,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GACAA,GAAA,IAEAp7B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,GACAA,GAAA,EAAAJ,EAAAI,EAAA,GAGA,MAEA,KAAA,IACAE,EAAA/lC,KAAAyK,GACAq7B,EAAA9lC,KAAA6lC,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,IAEA7wB,EAAAA,EAAA1S,OAAA,KAAA2jC,GACAx7B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GACAA,GAAA,IAEAp7B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,GACAA,GAAA,EAAAJ,EAAAI,EAAA,GAGA,MAEA,KAAA,IACAE,EAAA/lC,KAAAyK,GACAq7B,EAAA9lC,KAAA6lC,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,IAEA7wB,EAAAA,EAAA1S,OAAA,KAAA2jC,GACAx7B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GACAA,GAAA,IAEAp7B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,GACAA,GAAA,EAAAJ,EAAAI,EAAA,GAGA,MAEA,KAAA,IACA7wB,EAAAA,EAAA1S,OAAA,KAAA2jC,GACAF,EAAA/lC,KAAAyK,GACAq7B,EAAA9lC,KAAA6lC,GAEAp7B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GACAA,GAAA,GAEAA,GAAA,EAAAJ,EAAAI,EAAA,EAGA,MAEA,KAAA,IACAE,EAAA/lC,KAAAyK,GACAq7B,EAAA9lC,KAAA6lC,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,IAEA/B,EAAAxhC,OAAA2hC,GACAx5B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GACAA,GAAA,IAEAp7B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,GACAA,GAAA,EAAAJ,EAAAI,EAAA,GAGA,MAEA,KAAA,IACAE,EAAA/lC,KAAAyK,GACAq7B,EAAA9lC,KAAA6lC,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,IAEA/B,EAAA7yB,OAAAgzB,EAAA+B,EAAAP,EAAAI,EAAA,IAAAvjC,UAAA0jC,EAAAP,EAAAI,EAAA,KACAp7B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GACAA,GAAA,IAEAp7B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,GACAA,GAAA,EAAAJ,EAAAI,EAAA,GAGA,MAEA,KAAA,IACAE,EAAA/lC,KAAAyK,GACAq7B,EAAA9lC,KAAA6lC,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,IAEA/B,EAAA7yB,OAAAgzB,EAAA+B,EAAAP,EAAAI,EAAA,IAAAvjC,QAAA/B,gBAAAylC,EAAAP,EAAAI,EAAA,KACAp7B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GACAA,GAAA,IAEAp7B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,GACAA,GAAA,EAAAJ,EAAAI,EAAA,GAGA,MAEA,KAAA,IACAE,EAAA/lC,KAAAyK,GACAq7B,EAAA9lC,KAAA6lC,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,IAEAG,EAAAP,EAAAI,EAAA,IAAA1pC,KAAA2nC,EAAA95B,OAAAi6B,KACAx5B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GACAA,GAAA,IAEAp7B,EAAAo7B,EAAA,EAAAJ,EAAAI,EAAA,GAAAJ,EAAAI,EAAA,GACAA,GAAA,EAAAJ,EAAAI,EAAA,GAGA,MAEA,KAAA,IACA7wB,EAAAhV,KAAA8jC,EAAA7yB,OAAAgzB,EAAAwB,EAAAI,EAAA,KACA5B,GAAAwB,EAAAI,EAAA,GACAA,GAAA,CACA,MAEA,KAAA,IACA7wB,EAAAhV,KAAAgmC,EAAAP,EAAAI,EAAA,KACA5B,GAAA+B,EAAAP,EAAAI,EAAA,IAAAvjC,OACAujC,GAAA,CACA,MAEA,KAAA,IACA7wB,EAAAhV,KAAAimC,GACA,IAAAC,GACAtB,EAAAoB,EAAAP,EAAAI,EAAA,KAEAA,GAAA,CACA,MAEA,KAAA,IACA7B,EAAAhvB,EAAAA,EAAA1S,OAAA,EAAAmjC,EAAAI,EAAA,IACAA,GAAA,CACA,MAEA,KAAA,IACA7B,EAAAC,EACA4B,GACA,MAEA,KAAA,IAEA,IADAxiB,EAAAoiB,EAAAv7B,MAAA27B,EAAA,EAAAA,EAAA,EAAAJ,EAAAI,EAAA,IACAz7B,EAAA,EAAyBA,EAAAq7B,EAAAI,EAAA,GAAgBz7B,IACzCiZ,EAAAjZ,GAAA4K,EAAAA,EAAA1S,OAAA,EAAA+gB,EAAAjZ,GAGA4K,GAAAJ,OACAI,EAAA1S,OAAAmjC,EAAAI,EAAA,GACAJ,EAAAI,EAAA,GACAG,EAAAP,EAAAI,EAAA,IAAAn9B,MAAA,KAAA2a,IAGAwiB,GAAA,EAAAJ,EAAAI,EAAA,EACA,MAEA,KAAA,IACA7wB,EAAAhV,KAAA0lC,EAAAD,EAAAI,EAAA,KACAA,GAAA,CACA,MAEA,KAAA,IACAK,IACAL,GACA,MAEA,KAAA,IACAK,IACAL,GACA,MAEA,SACA,KAAA,IAAAjmC,OAAA,mBAAA6lC,EAAAI,GAAA,KAIA,KAAAE,EAAAzjC,OAAA,GAIA,KAHAmI,GAAAs7B,EAAAvV,MACAqV,EAAAC,EAAAtV,MAMA,MAAAxb,GAAA,GAttCA,GAwzBAmxB,GAxzBA3sC,EAAAkb,UAAApS,OAAA,EAAAoS,UAAA,MAEAuxB,KAEAG,GAAgCC,QAAA,IAAAC,iBAAA,IAAAC,aAAA,IAAAC,iBAAA,GAAAC,QAAA,GAAAC,mBAAA,IAAAC,IAAA,IAAAC,YAAA,GAAAC,QAAA,IAAAC,oBAAA,IAAAC,eAAA,IAAAC,aAAA,IAAAC,KAAA,IAAAjjB,YAAA,IAAAlQ,MAAA,IAAAozB,KAAA,IAAAl7B,KAAA,GAAAm7B,aAAA,IAAAC,mBAAA,IAAAC,cAAA,GAAAC,SAAA,IAAAC,SAAA,IAAAC,GAAA,IAAAC,SAAA,IAAAztC,KAAA,IAAA0tC,iBAAA,IAAA9b,UAAA,KAChC+b,EAAA,IAEA3B,GACA,QACWxgC,KAAA,UAAA3G,MAAA,OAAAuH,YAAA,YACX,UACWZ,KAAA,QAAA3G,MAAA,QAAAuH,YAAA,SACX,aACWZ,KAAA,QAAA3G,MAAA,WAAAuH,YAAA,YACX,gBACWZ,KAAA,QAAA3G,MAAA,cAAAuH,YAAA,eACX,cACWZ,KAAA,QAAA3G,MAAA,cAAAuH,YAAA,eACX,QACWZ,KAAA,QAAA3G,MAAA,MAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,SACX,gBACWZ,KAAA,QAAA3G,MAAA,cAAAuH,YAAA,eACX,KACWZ,KAAA,UAAA3G,MAAA,IAA2BuH,YAAA,OACtC,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,QACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX6/B,EACA,KACWzgC,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,SAAAwhC,GAA6B,MAAAA,GAAAn7B,KAAA,KAC7B,QAEA,WAAsB,MAAA,KACtB,WAAsB,MAAA,KACtB,WACA,MAAAs3B,MACA,UACWv+B,KAAA,QAAA3G,MAAA,QAAAuH,YAAA,SACX,kBACWZ,KAAA,QAAA3G,MAAA,kBAAAuH,YAAA,mBACX,gBACWZ,KAAA,QAAA3G,MAAA,gBAAAuH,YAAA,iBACX,UACWZ,KAAA,QAAA3G,MAAA,QAAAuH,YAAA,SACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,WACA,MAAA29B,MACA,KACWv+B,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,MACWZ,KAAA,UAAA3G,MAAA,KAAAuH,YAAA,UACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,KACWZ,KAAA,UAAA3G,MAAA,IAA2BuH,YAAA,OACtC,KACWZ,KAAA,UAAA3G,MAAA,IAA2BuH,YAAA,OACtC,WAAsB,MAAA,KACtB,WAAsB,MAAA,KACtB,WAAsB,MAAA,KACtB,WAAsB,MAAA,KACtB,WAAsB,MAAA,KACtB,WAAsB,MAAA,KACtB,WAAsB,MAAA,KACtB,WAAsB,MAAA,KACtB,WAAsB,MAAA,KACtB,WAAsB,MAAA,KACtB,WAAsB,MAAA,KACtB,UACWZ,KAAA,QAAA3G,MAAA,QAAAuH,YAAA,SACX,UACWZ,KAAA,QAAA3G,MAAA,QAAAuH,YAAA,SACX,WACWZ,KAAA,QAAA3G,MAAA,UAAAuH,YAAA,WACX,SAAAyhC,GACA,MAAAA,IACA,UACWriC,KAAA,QAAA3G,MAAA,QAAAuH,YAAA,SACX,YACWZ,KAAA,QAAA3G,MAAA,YAAAuH,YAAA,aACX,cACWZ,KAAA,QAAA3G,MAAA,cAAAuH,YAAA,eACX,aACWZ,KAAA,QAAA3G,MAAA,YAAAuH,YAAA,aACX,WACA8O,EAAArU,IAAA,GAAA3F,GAAAqR,IAAA2I,EAAAgQ,OAAAhQ,EAAAvI,KAAAuI,EAAAlJ,KAAAkJ,EAAAiQ,YACAjQ,GAAAgQ,aACAhQ,GAAAvI,WACAuI,GAAAlJ,WACAkJ,GAAAhJ,gBACAgJ,GAAAiQ,MAEA,WACAjQ,EAAArU,IAAA,GAAA3F,GAAAqR,IAAA2I,EAAAgQ,OAAAhQ,EAAAvI,KAAAuI,EAAAlJ,KAAAkJ,EAAAiQ,KAAAjQ,EAAA4yB,WAAA5yB,EAAA6yB,mBACA7yB,GAAAgQ,aACAhQ,GAAAvI,WACAuI,GAAAlJ,WACAkJ,GAAAhJ,gBACAgJ,GAAAiQ,WACAjQ,GAAA4yB,WAEA,YAAAtuC,EAAAwuC,YAAwE9yB,EAAAA,EAAArU,MAExE,QACW2E,KAAA,UAAA3G,MAAA,OAAAuH,YAAA,UACX,OACWZ,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,SACX,SAAA6hC,GACA/yB,EAAAgQ,OAAA+iB,EAAA1nC,eACA,WACA2U,EAAAvI,KAAAC,mBAAAm3B,IAAA75B,MAAA,EAAA,MACA,WACAgL,EAAApU,SAAAijC,KACA,WAEA,MADA7uB,GAAAlJ,KAAA+3B,IAAAxjC,cACA2U,EAAAlJ,MACA,WAEA,MADAkJ,GAAAhJ,UAAA,SACA63B,KACA,mBACWv+B,KAAA,QAAA3G,MAAA,kBAAAuH,YAAA,mBACX,kBACWZ,KAAA,QAAA3G,MAAA,iBAAAuH,YAAA,kBACX,WAEA,MADA8O,GAAAhJ,UAAA,OACA63B,KACA,MACWv+B,KAAA,UAAA3G,MAAA,KAAAuH,YAAA,QACX,WAEA,MADA8O,GAAAhJ,UAAA,OACA63B,KACA,WAEA,MADA7uB,GAAAhJ,UAAA,OACA63B,KACA,MACWv+B,KAAA,UAAA3G,MAAA,KAAAuH,YAAA,QACX,UACWZ,KAAA,QAAA3G,MAAA,QAAAuH,YAAA,SACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,UACWZ,KAAA,QAAA3G,MAAA,QAAAuH,YAAA,SACX,KACWZ,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,UACWZ,KAAA,QAAA3G,MAAA,QAAAuH,YAAA,SACX,SAAA+e,GAGA,MAFAA,GAAAla,SAAAka,EAAA1Y,KAAA,KACAyI,EAAAiQ,KAAAA,EACAA,GACA,cACW3f,KAAA,UAAA3G,MAAA,aAAAuH,YAAA,gBACX,OACWZ,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,SACX,OACWZ,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,SACX,QACWZ,KAAA,UAAA3G,MAAA,OAAAuH,YAAA,UACX,OACWZ,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,SACX,SAAA9F,GACA4U,EAAA4yB,aAAA5yB,EAAA4yB,eACA5yB,EAAA4yB,WAAA,UAAAxnC,EAAAC,eACA,SACWiF,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,SACWZ,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,MACWZ,KAAA,UAAA3G,MAAA,KAAAuH,YAAA,QACX,SAAAuG,GACAuI,EAAA4yB,aAAA5yB,EAAA4yB,eACA5yB,EAAA4yB,WAAA,KAAAn7B,EAAApM,eACA,WACWiF,KAAA,UAAA3G,MAAA,UAAAuH,YAAA,aACX,SAAAwa,GACA1L,EAAA4yB,aAAA5yB,EAAA4yB,eACA5yB,EAAA4yB,WAAA,OAAAlnB,GACA,QACWpb,KAAA,UAAA3G,MAAA,OAAAuH,YAAA,UACX,SAAA8hC,GACAhzB,EAAAmO,SAAAnO,EAAAmO,WACAnO,EAAAmO,OAAA,IAAA6kB,GACA,UACW1iC,KAAA,UAAA3G,MAAA,SAAAuH,YAAA,YACX,SAAA+hC,GACAjzB,EAAA4yB,aAAA5yB,EAAA4yB,eACA5yB,EAAA4yB,WAAA,MAAAK,GACA,MACW3iC,KAAA,UAAA3G,MAAA,KAAAuH,YAAA,QACX,WACA8O,EAAA4yB,aAAA5yB,EAAA4yB,eACA5yB,EAAA4yB,WAAA,GAAAnuC,QACA,SAAA0rB,EAAAxmB,GACAqW,EAAA4yB,aAAA5yB,EAAA4yB,eAEAjpC,EADA,OAAAA,EACAlF,OAGAkF,EAAA,GAEAqW,EAAA4yB,WAAAziB,EAAA9kB,eAAA1B,GAAAA,EAAA0B,eACA,SAAA6nC,GAA2B,MAAAA,GAAA37B,KAAA,KAC3B,SAAA47B,GAA4B,MAAAA,GAAA57B,KAAA,KAC5B,SAAAY,EAAAi7B,GACAj7B,EAAAA,EAAAZ,KAAA,IAAAlM,cACA+nC,EAAAA,EAAA77B,KAAA,IACAyI,EAAA6yB,cAAA7yB,EAAA6yB,gBACA7yB,EAAA6yB,YAAA16B,GAGA6H,EAAA6yB,YAAA16B,GAAArN,KAAAsoC,GAFApzB,EAAA6yB,YAAA16B,IAAAi7B,IAIA,WAEA,aAAA9uC,EAAAwuC,YACA9yB,EAAArU,IAAA,GAAA3F,GAAAqR,IAAA2I,EAAAgQ,OAAAhQ,EAAAvI,KAAAuI,EAAAlJ,KAAAkJ,EAAAiQ,KAAAjQ,EAAA4yB,WAAA5yB,EAAA6yB,mBACA7yB,GAAAgQ,aACAhQ,GAAAvI,WACAuI,GAAAlJ,WACAkJ,GAAAhJ,gBACAgJ,GAAAiQ,WACAjQ,GAAA4yB,aAGA,MACWtiC,KAAA,UAAA3G,MAAA,KAAAuH,YAAA,QACX,WACA8O,EAAAgQ,OAAA6e,MACWv+B,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,SACX,WACA8O,EAAAqzB,YAAAxE,KACA,UACWv+B,KAAA,UAAA3G,MAAA,SAAAuH,YAAA,YACX,OACWZ,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,SACX,SACWZ,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,WACWZ,KAAA,UAAA3G,MAAA,UAAAuH,YAAA,aACX,OACWZ,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,SACX,UACWZ,KAAA,UAAA3G,MAAA,SAAAuH,YAAA,YACX,YACWZ,KAAA,UAAA3G,MAAA,WAAAuH,YAAA,cACX,aACWZ,KAAA,UAAA3G,MAAA,YAAAuH,YAAA,eACX,UACWZ,KAAA,UAAA3G,MAAA,SAAAuH,YAAA,YACX,SACWZ,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,WAGA,MADA8O,GAAA0L,OAAAmjB,IACA7uB,EAAA0L,QACA,SAAAxkB,GACA8Y,EAAA9Y,YAAA6O,SAAA7O,EAAAqQ,KAAA,MACA,WACAyI,EAAA8N,cAAA+gB,KACA,WACA7uB,EAAA6uB,KACA,WACA,GAAAv7B,GAAAlG,CAEA,KADAA,EAAA4S,EAAAszB,aAAAlmC,OACAkG,EAAA,EAA+ClG,EAAAkG,EAAcA,IAC7D,GAAA,OAAA0M,EAAAszB,aAAAhgC,GAAAmZ,OAAA,CACAzM,EAAA,IACA,OAIAA,EADA,OAAAA,EACAA,EAAAszB,aAEA,IAEA,WACA,GAAA9mB,EACAxM,GAAAszB,eAAAtzB,EAAAszB,gBACA,KACA9mB,EAAA,GAAAxmB,GAAA4oB,eAAA5O,EAAArU,IAAAqU,EAAA8O,YAAA9O,EAAAmO,cACAnO,GAAArU,UACAqU,GAAA8O,kBACA9O,GAAAmO,OACmC,MAAA3mB,GACnCglB,EAAA,KAEAxM,EAAAszB,aAAAxoC,MAA2DwiB,SAAAyhB,EAC3DxhB,OAAAA,IACAd,OAAAD,KAEA,SAAAsC,GACAA,EAAA+f,IAAAjiB,OACA,MAAAkC,EAAA,KACAA,EAAAA,EAAAzW,UAAA,EAAAyW,EAAA1hB,OAAA,IAEA4S,EAAA8O,YAAAA,GACA,KACWxe,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,SAAAqiC,GACAvzB,EAAAmO,SAAAnO,EAAAmO,WACAnO,EAAAmO,OAAA,EAAAolB,GACA,WACWjjC,KAAA,UAAA3G,MAAA,UAAAuH,YAAA,aACX,SAAAgmB,GACAlX,EAAAmO,SAAAnO,EAAAmO,WACAnO,EAAAmO,OAAA,QAAA+I,GACA,SAAAsc,GACA,MAAAz9B,UAAAy9B,EAAAj8B,KAAA,MACA,KACWjH,KAAA,UAAA3G,MAAA,IAAAuH,YAAA,OACX,WACA,MAAA4E,YAAA+4B,MACA,SAAA1e,EAAAxmB,GACAqW,EAAAmO,SAAAnO,EAAAmO,WAEAxkB,EADA,OAAAA,EACAlF,OAGAkF,EAAA,GAEAqW,EAAAmO,OAAAgC,EAAA9kB,eAAA1B,GACA,UACW2G,KAAA,UAAA3G,MAAA,SAAAuH,YAAA,YACX,WACWZ,KAAA,UAAA3G,MAAA,UAAAuH,YAAA,aACX,QACWZ,KAAA,UAAA3G,MAAA,OAAAuH,YAAA,UACX,SACWZ,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,WACA,wBAAA5M,EAAAwuC,YACA9yB,EAAA1P,KAAAu+B,IAAAxjC,gBAGA,YACWiF,KAAA,UAAA3G,MAAA,WAAAuH,YAAA,cACX,YACWZ,KAAA,UAAA3G,MAAA,WAAAuH,YAAA,cACX,YACWZ,KAAA,UAAA3G,MAAA,WAAAuH,YAAA,cACX,SAAA9D,GACA4S,EAAAjK,SAAA3I,EAAAmK,KAAA,MACA,WACAyI,EAAA6uB,KACA,QACWv+B,KAAA,UAAA3G,MAAA,OAAAuH,YAAA,UACX,SACWZ,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,SACWZ,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,SACWZ,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,eACWZ,KAAA,UAAA3G,MAAA,cAAAuH,YAAA,iBACX,WACWZ,KAAA,UAAA3G,MAAA,UAAAuH,YAAA,aACX,aACWZ,KAAA,UAAA3G,MAAA,YAAAuH,YAAA,eACX,MACWZ,KAAA,UAAA3G,MAAA,KAAAuH,YAAA,QACX,SAAAuiC,GACAzzB,EAAArW,MAAAoM,SAAA09B,EAAAl8B,KAAA,MACA,SAAA2f,GAA6BlX,EAAAkX,GAC7B,SAAAwc,GACA1zB,EAAAjH,MAAA26B,EAAAroC,eACA,WACA,GAAAsoC,GAAA3zB,EAAA2zB,GACA3zB,GAAA,GAAAha,GAAA4oB,eAAA5O,EAAArU,IAAAqU,EAAA8O,YAAA9O,EAAAmO,QACAwlB,GAAsC3zB,EAAAoQ,SAAA,MAAAujB,IAEtC,OACWrjC,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,SACX,SAAAyiC,GAAyB3zB,EAAA2zB,IAAAA,GACzB,SAAAC,GACA5zB,EAAAjK,SAAA69B,EAAAr8B,KAAA,MACA,SAAAs8B,GAAiC7zB,EAAA6zB,GACjC,WACA7zB,EAAA,GAAAha,GAAA4oB,eAAA5O,EAAArU,IAAAqU,EAAA8O,YAAA9O,EAAAmO,SAEA,UACW7d,KAAA,UAAA3G,MAAA,SAAAuH,YAAA,YACX,SACWZ,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,SAAA84B,GAA2BhqB,EAAAgqB,MAAAA,GAC3B,UACW15B,KAAA,UAAA3G,MAAA,SAAAuH,YAAA,YACX,SACWZ,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,SAAAy8B,GAA2B3tB,EAAA2tB,MAAAA,GAC3B,UACWr9B,KAAA,UAAA3G,MAAA,SAAAuH,YAAA,YACX,SAAA08B,GAA4B5tB,EAAA4tB,OAAAA,GAC5B,SACWt9B,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,QACWZ,KAAA,UAAA3G,MAAA,OAAAuH,YAAA,UACX,WAAsB8O,EAAA4W,OAAA,GACtB,SACWtmB,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,WAAsB8O,EAAA4W,OAAA,GACtB,aACWtmB,KAAA,UAAA3G,MAAA,YAAAuH,YAAA,eACX,OACWZ,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,SACX,YACWZ,KAAA,UAAA3G,MAAA,WAAAuH,YAAA,cACX,SAAAw8B,GACA1tB,EAAA0tB,UAAAA,EAAA34B,eACA,OACWzE,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,SACX,YACWZ,KAAA,UAAA3G,MAAA,WAAAuH,YAAA,cACX,QACWZ,KAAA,UAAA3G,MAAA,OAAAuH,YAAA,UACX,SAAA4iC,GACA9zB,EAAA6tB,MAAA7tB,EAAA6tB,QACA7tB,EAAA6tB,IAAA/iC,KAAAgpC,EAAAzoC,gBACA,SAAA0oC,GACA/zB,EAAArW,MAAAoM,SAAAg+B,EAAAx8B,KAAA,MACA,WACA,GAAAjE,GAAAlG,CAEA,KADAA,EAAA4S,EAAAszB,aAAAlmC,OACAkG,EAAA,EAAyClG,EAAAkG,EAAcA,IACvD,GAAA,OAAA0M,EAAAszB,aAAAhgC,GAAAmZ,OAAA,CACAzM,EAAA,IACA,OAIAA,EADA,OAAAA,EACAA,EAAAszB,aAEA,IAEA,WACA,GAAA9mB,EACAxM,GAAAszB,eAAAtzB,EAAAszB,gBACA,KACA9mB,EAAA,GAAAxmB,GAAA4oB,eAAA5O,EAAArU,IAAAqU,EAAA8O,YAAA9O,EAAAmO,cACAnO,GAAArU,UACAqU,GAAA8O,kBACA9O,GAAAmO,OAC6B,MAAA3mB,GAC7BglB,EAAA,KAEAxM,EAAAszB,aAAAxoC,MAAqDwiB,SAAAyhB,EACrDxhB,OAAAA,IACAd,OAAAD,KAEA,WACAxM,EAAA,GAAAha,GAAA4oB,eAAA5O,EAAArU,IAAAqU,EAAA8O,YAAA9O,EAAAmO,SAEA,SAAA6lB,GACAh0B,EAAArW,MAAAoM,SAAAi+B,EAAAz8B,KAAA,MACA,UACWjH,KAAA,UAAA3G,MAAA,SAAAuH,YAAA,YACX,WACWZ,KAAA,UAAA3G,MAAA,UAAAuH,YAAA,aACX,cACWZ,KAAA,UAAA3G,MAAA,aAAAuH,YAAA,gBACX,WACA8O,EAAA8R,MAAA+c,KACA,UACWv+B,KAAA,UAAA3G,MAAA,SAAAuH,YAAA,YACX,SAAA6Y,GACA,mBAAAA,KAAA/J,EAAA+J,OAAAA,IACA,SAAAmN,GACA,mBAAAA,KAAAlX,EAAAkX,QAAAA,IACA,eACW5mB,KAAA,UAAA3G,MAAA,cAAAuH,YAAA,iBACX,SAAA+iC,GACA,mBAAAA,KAAAj0B,EAAAi0B,YAAAA,IACA,eACW3jC,KAAA,UAAA3G,MAAA,cAAAuH,YAAA,iBACX,aACWZ,KAAA,UAAA3G,MAAA,YAAAuH,YAAA,eACX,YACWZ,KAAA,UAAA3G,MAAA,WAAAuH,YAAA,cACX,WACWZ,KAAA,UAAA3G,MAAA,UAAAuH,YAAA,aACX,UACWZ,KAAA,UAAA3G,MAAA,SAAAuH,YAAA,YACX,cACWZ,KAAA,UAAA3G,MAAA,aAAAuH,YAAA,gBACX,aACWZ,KAAA,UAAA3G,MAAA,YAAAuH,YAAA,eACX,WACA,GAAAyiC,GAAA3zB,EAAA2zB,GACA3zB,GAAA,GAAAha,GAAA4oB,eAAA5O,EAAArU,IAAAqU,EAAA8O,YAAA9O,EAAAmO,QACAwlB,GAAoC3zB,EAAAoQ,SAAA,MAAAujB,IAEpC,OACWrjC,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,SACX,SAAAgjC,GACAl0B,EAAAgzB,IAAAkB,GACA,SACW5jC,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,SAAAijC,GACAn0B,EAAAizB,MAAAkB,GACA,YACW7jC,KAAA,UAAA3G,MAAA,WAAAuH,YAAA,cACX,SAAAkjC,GACAp0B,EAAAq0B,SAAAD,GACA,UACW9jC,KAAA,UAAA3G,MAAA,SAAAuH,YAAA,YACX,SAAA2a,GACA7L,EAAAiN,OAAApB,GACA,SACWvb,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,WACA,mBAAAojC,iBACAt0B,EAAAu0B,MAAAD,cAAA/8B,KAAA,MACA,SAAAi9B,GACAx0B,EAAAy0B,SAAAD,IACWlkC,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,UACAZ,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,UACAZ,KAAA,UAAA3G,MAAA,MAAAuH,YAAA,UACAZ,KAAA,UAAA3G,MAAA,OAAAuH,YAAA,UACX,SAAAwjC,GACA10B,EAAA5U,UAAAspC,GACA,WACA10B,EAAAlJ,KAAA+3B,KACA,SAAA8F,GACA30B,EAAAiQ,KAAAla,SAAA4+B,EAAAp9B,KAAA,MACA,SAAAy7B,GACA,MAAAj9B,UAAAi9B,EAAAz7B,KAAA,MACA,SACWjH,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,QACWZ,KAAA,UAAA3G,MAAA,OAAAuH,YAAA,UACX,SAAA8e,GACAhQ,EAAAgQ,OAAAA,GACA,SAAAlZ,GACAkJ,EAAAlJ,KAAAA,GACA,WACA,MAAA+3B,MACA,eACWv+B,KAAA,UAAA3G,MAAA,cAAAuH,YAAA,iBACX,SACWZ,KAAA,UAAA3G,MAAA,QAAAuH,YAAA,WACX,QACWZ,KAAA,UAAA3G,MAAA,OAAAuH,YAAA,UACX,WACA8O,EAAA5U,UAAAA,WACA,WACA4U,EAAA6uB,MAGA6B,GACAJ,EAAA,YACAA,EAAA,YACAA,EAAA,YACAA,EAAA,aACAA,EAAA,aACAA,EAAA,YACAA,EAAA,YACAA,EAAA,YACAA,EAAA,YACAA,EAAA,YACAA,EAAA,wHACAA,EAAA,YACAA,EAAA,4GACAA,EAAA,yDACAA,EAAA,oFACAA,EAAA,aACAA,EAAA,sEACAA,EAAA,mHACAA,EAAA,kBACAA,EAAA,YACAA,EAAA,YACAA,EAAA,kBACAA,EAAA,gRACAA,EAAA,wPACAA,EAAA,mNACAA,EAAA,4jBACAA,EAAA,gDACAA,EAAA,gDACAA,EAAA,gDACAA,EAAA,gDACAA,EAAA,gDACAA,EAAA,sCACAA,EAAA,sCACAA,EAAA,gDACAA,EAAA,gDACAA,EAAA,gDACAA,EAAA,gCACAA,EAAA,gCACAA,EAAA,sEACAA,EAAA,gDACAA,EAAA,wEACAA,EAAA,8EACAA,EAAA,gDACAA,EAAA,gEACAA,EAAA,iEACAA,EAAA,4FACAA,EAAA,qCACAA,EAAA,mFACAA,EAAA,6CACAA,EAAA,gGACAA,EAAA,6JACAA,EAAA,+DACAA,EAAA,8BACAA,EAAA,uHACAA,EAAA,iCACAA,EAAA,sDACAA,EAAA,sDACAA,EAAA,wxEACAA,EAAA,qEACAA,EAAA,mDACAA,EAAA,uGACAA,EAAA,8KACAA,EAAA,0GACAA,EAAA,sEACAA,EAAA,0CACAA,EAAA,sFACAA,EAAA,8DACAA,EAAA,uCACAA,EAAA,sCACAA,EAAA,sCACAA,EAAA,yEACAA,EAAA,oEACAA,EAAA,kCACAA,EAAA,kCACAA,EAAA,kBACAA,EAAA,oFACAA,EAAA,4GACAA,EAAA,iDACAA,EAAA,6CACAA,EAAA,sCACAA,EAAA,oFACAA,EAAA,YACAA,EAAA,2DACAA,EAAA,YACAA,EAAA,sDACAA,EAAA,qEACAA,EAAA,mDACAA,EAAA,kCACAA,EAAA,oCACAA,EAAA,kBACAA,EAAA,wHACAA,EAAA,4FACAA,EAAA,oGACAA,EAAA,cACAA,EAAA,gGACAA,EAAA,4HACAA,EAAA,YACAA,EAAA,sEACAA,EAAA,iOACAA,EAAA,cACAA,EAAA,8GACAA,EAAA,YACAA,EAAA,YACAA,EAAA,YACAA,EAAA,YACAA,EAAA,YACAA,EAAA,YACAA,EAAA,YACAA,EAAA,YACAA,EAAA,YACAA,EAAA,YACAA,EAAA,uEACAA,EAAA,2DACAA,EAAA,kBACAA,EAAA,sCACAA,EAAA,mGACAA,EAAA,gFACAA,EAAA,mEACAA,EAAA,iGACAA,EAAA,0FACAA,EAAA,uDACAA,EAAA,mGACAA,EAAA,kBACAA,EAAA,gDACAA,EAAA,iDACAA,EAAA,kCACAA,EAAA,kHACAA,EAAA,8DACAA,EAAA,kBACAA,EAAA,gFACAA,EAAA,kEACAA,EAAA,YACAA,EAAA,oEACAA,EAAA,gFACAA,EAAA,kCACAA,EAAA,iBACAA,EAAA,oGACAA,EAAA,YACAA,EAAA,kEACAA,EAAA,+BACAA,EAAA,YACAA,EAAA,kCACAA,EAAA,YACAA,EAAA,sCACAA,EAAA,YACAA,EAAA,sCACAA,EAAA,kCACAA,EAAA,kBACAA,EAAA,oFACAA,EAAA,kGACAA,EAAA,0FACAA,EAAA,YACAA,EAAA,gDACAA,EAAA,kCACAA,EAAA,kBACAA,EAAA,0HACAA,EAAA,MACAA,EAAA,gHACAA,EAAA,oGACAA,EAAA,4CACAA,EAAA,gDACAA,EAAA,4CACAA,EAAA,kBACAA,EAAA,gKACAA,EAAA,YACAA,EAAA,4CACAA,EAAA,kBACAA,EAAA,gDACAA,EAAA,oFACAA,EAAA,wEACAA,EAAA,sJACAA,EAAA,2CACAA,EAAA,gFACAA,EAAA,0DACAA,EAAA,kCACAA,EAAA,oFACAA,EAAA,oFACAA,EAAA,gGACAA,EAAA,gFACAA,EAAA,gFACAA,EAAA,gFACAA,EAAA,kCACAA,EAAA,gFACAA,EAAA,sDACAA,EAAA,uJACAA,EAAA,2FACAA,EAAA,aACAA,EAAA,uFACAA,EAAA,0FACAA,EAAA,YACAA,EAAA,gFACAA,EAAA,oGACAA,EAAA,oCACAA,EAAA,gDACAA,EAAA,gDACAA,EAAA,uDACAA,EAAA,gDACAA,EAAA,2EACAA,EAAA,0DACAA,EAAA,+BACAA,EAAA,mEACAA,EAAA,yDACAA,EAAA,8BACAA,EAAA,0GACAA,EAAA,iEACAA,EAAA,MACAA,EAAA,sCACAA,EAAA,sCACAA,EAAA,cACAA,EAAA,4CACAA,EAAA,qCACAA,EAAA,+DACAA,EAAA,gCACAA,EAAA,iDACAA,EAAA,4DACAA,EAAA,oIACAA,EAAA,yFACAA,EAAA,qCACAA,EAAA,gEACAA,EAAA,+HACAA,EAAA,gDACAA,EAAA,4BACAA,EAAA,uCAGAvB,EAAA,EACAD,EAAA,EACAU,EAAA,EACAC;AAAgCppC,KAAA,EAAAsoC,OAAA,EAAAY,QAAA,GAChCI,EAAA,EACAC,KACAoB,EAAA,CAIA,IAAA,aAAA1sC,GAAA,CACA,KAAAA,EAAAwuC,YAAA5B,IACA,KAAA,IAAAxmC,OAAA,mCAAApG,EAAAwuC,UAAA,KAGAL,GAAAvB,EAAA5sC,EAAAwuC,WA0ZA,GAAA9yB,KAIA,OAFAixB,GAAAT,EAAAiC,GAEAxB,IAAAF,GAAAhC,IAAAH,EAAAxhC,OACA4S,GAEAixB,IAAAF,GAAAhC,EAAAH,EAAAxhC,QACAsiC,GAAkBp/B,KAAA,MAAAY,YAAA,iBAGlB,IAIA,MA3uCAk9B,GAAAI,EAAA9jC,QA4uCA8jC,YAAAA,EACAz3B,MAAA,SAAA63B,EAAAkE,GAA8C,MAAA/7B,GAAA63B,GAAqBkE,UAAAA,QnCw0U7D,SAASvvC,EAAQD,GoC9kXvB,GAAAyF,GAAA,WACArF,KAAAkxC,YAKA7rC,GAAAU,UAAAlD,KAAA,SAAAiI,GAQA,QAAAqmC,GAAA31B,GACA,MAAA,YACAA,EAAA1L,MAAArG,EAAAiG,IATA,GAAAjG,GAAAzJ,KAAA0P,EAAA3H,MAAAhC,UAAAuL,MAAA/Q,KAAAub,UAAA,EACA,IAAAhR,IAAA9K,MAAAkxC,SAEA,IAAA,GADAE,GAAApxC,KAAAkxC,SAAApmC,GACA0G,EAAA,EAAuBA,EAAA4/B,EAAA1nC,OAAiB8H,IACxC7N,WAAAwtC,EAAAC,EAAA5/B,IAAA,IAYAnM,EAAAU,UAAAlE,GAAA,SAAAiJ,EAAA0Q,GACAzT,MAAAC,QAAA8C,KAAAA,GAAAA,GACA,KAAA,GAAA0G,GAAA,EAAmBA,EAAA1G,EAAApB,OAAiB8H,IAAA,CACpCxR,KAAAkxC,SAAApmC,EAAA0G,IAAAxR,KAAAkxC,SAAApmC,EAAA0G,OACA,IAAA4/B,GAAApxC,KAAAkxC,SAAApmC,EAAA0G,GACA4/B,GAAAhqC,KAAAoU,KAMAnW,EAAAU,UAAAgW,IAAA,SAAAjR,EAAA0Q,GACAxb,KAAAkxC,SAAApmC,GAAA9K,KAAAkxC,SAAApmC,MACA,IAAA+9B,GAAA7oC,KAAAkxC,SAAApmC,GAAA8G,QAAA4J,EACA,MAAAqtB,GACA7oC,KAAAkxC,SAAApmC,GAAAkR,OAAA6sB,EAAA,IAKAxjC,EAAAU,UAAA6V,KAAA,SAAA9Q,EAAA0Q,GAGA,QAAAK,KACAL,EAAA1L,MAAA9P,KAAA8b,WACArS,EAAAsS,IAAAjR,EAAA+Q,GAJA,GAAApS,GAAAzJ,IAOAyJ,GAAA5H,GAAAiJ,EAAA+Q,GAOA,IAAAw1B,GAAAhsC,EAAAU,UAAAlD,IACAwC,GAAAU,UAAAlD,KAAA,WACA,GAAA4G,GAAAzJ,KAAA0P,EAAAoM,SACAnY,YAAA,WACA0tC,EAAAvhC,MAAArG,EAAAiG,MAMA7P,EAAAD,QAAAyF,GpColXM,SAASxF,EAAQD,EAASM,GqCxpXhC,GAAAoC,GAAApC,EAAA,GACAmF,EAAAnF,EAAA,IACAoF,EAAApF,EAAA,IACAoxC,EAAApxC,EAAA,IAEAuF,EAAA6rC,EAAA7rC,OACArE,EAAAkwC,EAAAlwC,KAEAgB,EAAAlC,EAAA,IACAqxC,EAAArxC,EAAA,IAQA0B,EAAA,SAAAhB,GACAZ,KAAA4C,aAAA,GAAAyC,GACArF,KAAAwxC,UAAA5wC,EAAAA,EAAA4wC,iBACAxxC,KAAAyxC,SACAzxC,KAAA0xC,UAAA3wC,OACAf,KAAAwkC,aAAAzjC,OACAf,KAAAq/B,kBAAAt+B,OACAf,KAAA6gC,sBAAA9/B,OACAf,KAAA2xC,IAAA,GAAAJ,GACAvxC,KAAAiF,aAAA,GACAjF,KAAAmF,WAAA,GACAnF,KAAA4xC,cAKAhwC,GAAAmE,UAAA6rC,YAAA,WAEA,gBAAA5xC,MAAAwxC,UAAAhqC,YACAxH,KAAAwxC,UAAAhqC,YACa2e,OAAAnmB,KAAAwxC,UAAAhqC,YAGb,IAAAmlB,GAAAklB,GAAsBC,YAAA,EACtB,KAAAnlB,IAAA3sB,MAAAwxC,UAAAhqC,UAAAxH,KAAAwxC,UAAAhqC,UAAAsT,eAAA6R,IAAAhnB,OAAAosC,eAAAhqC,MAAAhC,UAAA4mB,EAAAklB,IAKAjwC,EAAAmE,UAAA4C,aAAA,SAAAu2B,GAIA,IAAA,GAHA13B,GAAA03B,EAAA13B,UACAwqC,EAAA,UAAAC,SAAAC,SAAAnB,SAEAv/B,EAAA,EAAmBA,EAAAhK,EAAAkC,OAAsB8H,IACzC,GACAwgC,GAAA,QAAAzuC,KAAAiE,EAAAgK,MAEAwgC,GAAA,OAAAzuC,KAAAiE,EAAAgK,IACA,CACA0tB,EAAA13B,WAAAA,EAAAgK,GACA,OAIAxR,KAAAwxC,UAAAtS,EACAl/B,KAAAiF,aAAAi6B,EAAAh4B,QAAA,GACAlH,KAAAmF,WAAA+5B,EAAAh4B,QAAA,GACAlH,KAAA4xC,eAKAhwC,EAAAmE,UAAAosC,aAAA,SAAA1uC,EAAAmJ,GACA,GAAAnD,GAAAzJ,IACAyD,GAAA6Y,KAAAjc,GAAAe,IACAqI,EAAA7G,aAAAC,KAAAT,EAAAgwC,cAAA3uC,EACA,IAAAd,GAAA,GAAA2C,IACA7B,QAAAA,EACAiuC,UAAAjoC,EACAiqB,WAAAjqB,EAAA+nC,UAAArpC,kBACAvF,aAAA6G,EAAA7G,aACAgK,KAAAA,EACA3H,aAAAwE,EAAAxE,aACAE,WAAAsE,EAAAtE,YAIA,OAFAsE,GAAA4oC,uBACA5oC,EAAAgoC,MAAAhuC,EAAA6Y,KAAAjc,IAAAsC,EACAA,GAKAf,EAAAmE,UAAAusC,eAAA,WAEA,MADAtyC,MAAAqyC,uBACAryC,KAAAyxC,OAKA7vC,EAAAmE,UAAAyD,oBAAA,WACA,GAAAioC,GAAAzxC,KAAAsyC,iBACAC,IACA,KAAA,GAAAlyC,KAAAoxC,GACAA,EAAA32B,eAAAza,IACAkyC,EAAAnrC,KAAAqqC,EAAApxC,GAGA,OAAAkyC,IAKA3wC,EAAAmE,UAAAuD,sBAAA,WACA,MAAAtJ,MAAAwJ,sBAAAO,OAAA,SAAAyoC,GACA,MAAAA,GAAApoC,gBAMAxI,EAAAmE,UAAAssC,qBAAA,WACA,IAAA,GAAAhyC,KAAAL,MAAAyxC,MACAzxC,KAAAyxC,MAAA32B,eAAAza,IACAL,KAAAyxC,MAAApxC,GAAAoyC,kBACAzyC,MAAAyxC,MAAApxC,GAQA,IAAAqyC,GAAA,CAGA9wC,GAAAmE,UAAA6C,MAAA,SAAAhI,GACA,GAAA6I,GAAAzJ,IAEAyJ,GAAApD,OACAoD,EAAAioC,oBAAApvC,GAAAwQ,IACArJ,EAAAioC,UAAA/L,WAAAl8B,EAAA+nC,WACA/nC,EAAAioC,UAAArpC,UAAA,IAGAoB,EAAAioC,UAAA,GAAApvC,GAAAwQ,GAAArJ,EAAA+nC,WACA/nC,EAAAkpC,uBAAA/xC,MACA6I,EAAAioC,UAAA7vC,GAAA,YAAA,SAAAiC,GACA4uC,EAAA,EACAjpC,EAAA7G,aAAAC,KAAAT,EAAAwwC,aAAA9uC,GACA2F,EAAAioC,UAAA/qC,UACAU,aAAAzG,EAAAyG,qBAGAoC,EAAAioC,UAAA7vC,GAAA,eAAA,SAAAiC,KACA4uC,IAAAjpC,EAAA+nC,UAAAqB,YAAA,KACAH,EAAA,EACAjpC,EAAApD,OACAoD,EAAA7G,aAAAC,KAAAT,EAAA6B,oBAAA,GAAA+C,OAAA,qEAEAyC,EAAA7G,aAAAC,KAAAT,EAAA0wC,gBAAAhvC,KAEA2F,EAAAioC,UAAA7vC,GAAA,aAAA,SAAAiC,GACA2F,EAAA7G,aAAAC,KAAAT,EAAAyB,cAAAC,KAEA2F,EAAAioC,UAAA7vC,GAAA,eAAA,SAAAiC,GACA2F,EAAA7G,aAAAC,KAAAT,EAAA+B,gBAAAL,KAEA2F,EAAAioC,UAAA7vC,GAAA,qBAAA,SAAAiC,GACA2F,EAAA7G,aAAAC,KAAAT,EAAA4B,sBAAAF,KAGA2F,EAAAioC,UAAA7vC,GAAA,SAAA,SAAA4B,GACA,GAAAsvC,EAEA,IAAAtvC,GAAAA,EAAAsqB,SAAAtqB,EAAAsqB,QAAAzD,UAAA,YAAA,CAKA,IAAA,GAJA0oB,GAAAvvC,EAAAsqB,QAAAvF,UAAA,YAAA5U,MAAA,KACAq/B,EAAAD,EAAA,GACAvB,EAAAhoC,EAAAD,sBACA0pC,EAAA,KACA1hC,EAAA,EAA+BA,EAAAigC,EAAA/nC,OAAkB8H,IACjD,GAAAigC,EAAAjgC,GAAA/N,QAAAsqB,QAAAjE,SACAmpB,IAAAxB,EAAAjgC,GAAA/N,QAAAsqB,QAAAjE,QAAA,CACAopB,EAAAzB,EAAAjgC,EACA,OAKA,GAAA0hC,EAAA,CACAA,EAAAC,OACAJ,GAAAtpC,EAAA0oC,aAAA1uC,EAAA6B,EAAA8tC,MAAAC,UACAN,EAAA3pC,SAAAS,KAAA,WACAJ,EAAA7G,aAAAC,KAAAT,EAAAkxC,aAAAP,EAAAG,GACAA,EAAAtkB,gBAKAmkB,GAAAtpC,EAAA0oC,aAAA1uC,EAAA6B,EAAA8tC,MAAAC,UACA5pC,EAAA7G,aAAAC,KAAAT,EAAAM,gBAAAqwC,MAKAtpC,EAAAioC,UAAA9L,gBAAA3e,qBAAA,aACAxd,EAAAioC,UAAA9oC,SAMAhH,EAAAmE,UAAAnC,WAAA,SAAAhD,EAAAkI,GACA,GAAAW,GAAAzJ,KAAA8I,IAAAA,CACAlI,GAAA6E,EAAAgE,EAAAkpC,uBAAA/xC,GACA6I,EAAAioC,WACAjoC,EAAAb,MAAAhI,GAEAkI,EAIAW,EAAAo8B,cAMAp8B,EAAAioC,UAAAhqC,UAAA0d,GAAAgB,SALA3c,EAAApD,OACAoD,EAAAb,MAAAhI,IALA6I,EAAAioC,UAAA/qC,SAAA/F,IAgBAgB,EAAAmE,UAAAM,KAAA,WACArG,KAAA0xC,oBAAApvC,GAAAwQ,KACA9S,KAAA0xC,UAAArrC,OACArG,KAAA0xC,UAAA,OAMA9vC,EAAAmE,UAAAxF,KAAA,SAAAgzC,EAAAC,GACA,GAAA/pC,GAAAzJ,KACAY,GACA2P,OACAC,aAA0BC,OAAA,EAAAC,OAAA,GAC1BE,QACAgpB,OACAnpB,MAAAhH,EAAAkoC,IAAA8B,YAEA5iC,QACAJ,MAAAhH,EAAAkoC,IAAA+B,eAIA9X,gBACAC,WACiBC,qBAAA,WAIjB7yB,EAAAuqC,EAAAvqC,WACAC,EAAAsqC,EAAAtqC,QAEAhC,IACA+B,IACA/B,EAAAE,KAAA,4BAAA6B,EAAA,IAAAjJ,KAAAwxC,UAAA5pC,QAEAsB,GACAhC,EAAAE,KAAA,oBAAA8B,GAGAhC,EAAAE,KAAAqC,EAAAxE,cACAiC,EAAAE,KAAAqC,EAAAtE,YAEAM,EAAA7E,GACAyG,aAAAH,GAEA,IAAAzD,GAAAzD,KAAA0xC,UAAA9Y,OAAA,GAAA2a,EAAA3yC,GACA+B,EAAA8G,EAAA0oC,aAAA1uC,EAAA6B,EAAA8tC,MAAAO,SAEA,OADA3zC,MAAA4C,aAAAC,KAAAT,EAAAW,aAAAJ,GACAA,GAKAf,EAAAmE,UAAAqD,OAAA,SAAAzG,GACA,MAAAA,IAAAA,EAAAyG,UAMAxH,EAAAmE,UAAAzB,OAAA,SAAA3B,GACAA,IACAA,EAAAisB,eACA5uB,MAAAyxC,MAAA9uC,EAAAwwC,WAMAvxC,EAAAmE,UAAAlE,GAAA,SAAAwiC,EAAAuP,GAEA,MADA5zC,MAAA4C,aAAAf,GAAAwiC,EAAAuP,GACA5zC,MAKA4B,EAAAmE,UAAA8/B,YAAA,WACA,SAAA7lC,KAAA0xC,WAAA1xC,KAAA0xC,UAAAhqC,WAAA1H,KAAA0xC,UAAAhqC,UAAA6d,YAKA3jB,EAAAmE,UAAA8tC,aAAA,WAEA,OAAA7zC,KAAA6lC,kBAAA7lC,KAAA0xC,WAAA1xC,KAAA0xC,UAAAhqC,WAAA1H,KAAA0xC,UAAAhqC,UAAA0d,IAAA,IAAAplB,KAAA0xC,UAAAhqC,UAAA0d,GAAAS,aAKAjkB,EAAAmE,UAAAgD,gBAAA,WACAtC,QAAAa,KAAAtH,KAAA6zC,eAAA7zC,KAAA6lC,gBACA7lC,KAAA6zC,gBAAA7zC,KAAA6lC,iBACA7lC,KAAA0xC,UAAAhqC,UAAAue,aACAjmB,KAAA0xC,UAAArrC,OACArG,KAAA0xC,UAAA,OAIA7xC,EAAAD,QAAAgC,GrC+pXM,SAAS/B,EAAQD,EAASM,GsCpxWhC,QAAA4zC,GAAA5tC,EAAA6tC,GAEA,IAAA,GADAC,GAAA9tC,EAAA86B,iBACAxvB,EAAA,EAAmBA,EAAAwiC,EAAAtqC,OAAmB8H,IACtCwiC,EAAAxiC,GAAAsxB,SAAAiR,EAxtBA,GAAAzxC,GAAApC,EAAA,GACAoxC,EAAApxC,EAAA,IACAkC,EAAAlC,EAAA,IAEA+zC,EAAA3C,EAAA2C,MACAxuC,EAAA6rC,EAAA7rC,OAEAojC,EAAA,EAMAvjC,EAAA,SAAA1E,GAyQA,QAAAszC,KACAzqC,EAAAK,QAAA,EACAL,EAAA0qC,gBAAA,KACA1qC,EAAAsxB,UAAA,EAsDA,QAAAqZ,GAAA/tB,GACA5c,EAAAhG,QAAA00B,WAAA,KAAA9R,GAAA/jB,EAAAC,EAAAF,OAAAoa,kBACAy3B,IACAzqC,EAAA7G,aAAAC,KAAAT,EAAAgB,WAAAqG,EAAA,KAAA,oBAnUA,GAAAA,GAAAzJ,IACAA,MAAA6oC,MAAAA,IAEA7oC,KAAAyD,QAAA7C,EAAA6C,QACAzD,KAAA0xC,UAAA9wC,EAAA8wC,UACA1xC,KAAA4C,aAAAhC,EAAAgC,aACA5C,KAAA0zB,WAAA9yB,EAAA8yB,WACA1zB,KAAAq0C,UAAAr0C,KAAAyD,SAAAzD,KAAAyD,QAAApD,GAEAL,KAAA8J,QAAA,EACA9J,KAAAyB,UAAA,EACAzB,KAAA0B,WACA1B,KAAAs0C,OAAA,EACAt0C,KAAAu0C,WAAA,EACAv0C,KAAAwB,QAAA,EACAxB,KAAAm0C,gBAAA,KAEAn0C,KAAA+6B,UAAA,EACA/6B,KAAA4M,KAAAhM,EAAAgM,KAEA5M,KAAAiF,aAAArE,EAAAqE,aACAjF,KAAAmF,WAAAvE,EAAAuE,WAEAnF,KAAAw0C,gBAAA,IAEAx0C,KAAAy0C,eACAC,UACAC,MAAmBC,MAAA,EAAAC,QAAA,YACnBC,aAA0BF,MAAA,EAAAC,QAAA,mBAC1BE,YAAyBH,MAAA,EAAAC,QAAA,kBACzBG,MAAmBJ,MAAA,EAAAC,QAAA,WAAApqC,OAAA,IACnBwqC,SAAsBL,MAAA,EAAAC,QAAA,WACtBK,OAAoBN,MAAA,EAAAC,QAAA,SACpBM,SAAsBP,MAAA,EAAAC,QAAA,WACtBO,UAAuBR,MAAA,EAAAC,QAAA,aAEvBlvB,KAAA,SAAAkvB,EAAAj0C,GAEAA,EAAAA,MACA6E,EAAAovC,EAAAj0C,EAEA,IAAAmpB,GAAA,IAEA,OAAA,IAAAlhB,SAAA,SAAA3F,EAAAgB,GAEA,GAAAgD,KAEAA,GAAAE,KAAA,gDACAF,EAAAE,KAAAqC,EAAAxE,cACAiC,EAAAE,KAAAqC,EAAAtE,YAEAsE,EAAAhG,QAAAmvB,YAAAtwB,EAAAC,EAAA+b,MACA3M,KAAAiJ,KAAAC,WACAkT,QAAA8mB,IAEAxtC,aAAAH,EACAkhB,gBAAA,SAAA/kB,GAIA,QAAAgyC,GAAAtnB,GACA,GAAA1qB,EAAA0mB,OAAAA,EAAA,CACA,GACAurB,GADA3jC,EAAAoc,GAAAA,EAAApc,MAAA,IAGA,KACA2jC,EAAA16B,KAAAvH,MAAA1B,GAEA,MAAA7N,GACAwxC,KAGAA,EAAAjyC,UAAAiyC,EAAAjyC,SAAAwxC,UAAAA,EAAAA,SACAS,EAAAjyC,SAAAooB,SACA,GAAA6pB,EAAAjyC,SAAAooB,OAAA/H,KACAxgB,EAAAoyC,EAAAjyC,SAAAooB,QAGAvnB,EAAAoxC,EAAAjyC,SAAAooB,SAIAwM,GAAA/R,aAAA+R,GACAxuB,EAAA7G,aAAAmZ,IAAA,WAAAs5B,GACAnyC,KA3BA,GAAA+0B,GAAA,IACA,OAAA50B,EAAAG,aACAumB,EAAA1mB,EAAA0mB,KA6BAkO,EAAAt0B,WAAA,WACAO,EAAA,GAAA8C,OAAA,sBACAyC,EAAA7G,aAAAmZ,IAAA,WAAAs5B,IAC6B5rC,EAAA+qC,iBAC7B/qC,EAAA7G,aAAAf,GAAA,WAAAwzC,IAGAnxC,EAAA,GAAA8C,OAAA,qCAAA3D,EAAAG,YAAA,6BAWA,IAAA+xC,GAAAv1C,KAAAyD,QAAAqkB,cACA9nB,MAAAyD,QAAAqkB,eAAA,SAAAiG,GACA,OAAAA,EAAA/F,QACA,IAAA1lB,GAAAC,EAAA+b,KAGA,GAFA7U,EAAA7G,aAAAC,KAAA,WAAAkrB,GAEA/tB,KAAA6jB,SAAAvhB,EAAA+uB,QAAA9uB,EAAAirB,kBAAAxtB,KAAA6jB,SAAAvhB,EAAA+uB,QAAA9uB,EAAAozB,uBAAA,CACA,GAAAnB,GAAAzG,EAAAvF,UAAA,eACA,IAAAgM,EAAA7L,MAAA,uBAEA,MADAoF,GAAAhC,MAAA,KACA/rB,KAGA,KAEA,KAAAsC,GAAAC,EAAAgc,OACA,GAAA9a,GAAAzD,IACA,IAAAyD,EAAAogB,SAAAvhB,EAAA+uB,QAAA9uB,EAAAirB,kBACAO,EAAAjE,SAAArmB,EAAAitB,QAAAjtB,EAAAitB,OAAArwB,IAAA0tB,EAAAjE,SAAArmB,EAAAitB,OAAArwB,GAAAypB,QAAA,CAEArmB,EAAA0M,OAAAzJ,IAAA,qBACA,IAAA8uC,GAAA/xC,EAAA0uB,aAAAK,eAAA0P,iBAAA5E,GAMA,OALAvP,GAAAhC,MAAA,IAAA,MAAA,YAAAtiB,EAAA/H,SAAA8zC,EAAA,WACA/xC,EAAAogB,OAAAvhB,EAAA+uB,QAAA9uB,EAAAozB,uBACAlyB,EAAAq2B,kBAAA/L,EAAAynB,GACA/xC,EAAAs2B,gBAEAt2B,EAIA,KAEA,KAAAnB,GAAAC,EAAAkc,OACAhV,EAAA7G,aAAAC,KAAA,aAAAkrB,GAGA,MAAAwnB,GAAAzlC,MAAArG,EAAAhG,QAAAqY,YAMA9b,KAAAyD,QAAA5B,GAAA,aAAA,SAAAiC,GACA2F,EAAA7G,aAAAC,KAAAT,EAAAqzC,eAAAhsC,EAAA3F,GACAH,WAAA,WACA5C,SAAA0I,EAAAhG,QAAA0uB,aAAAuN,eACAj2B,EAAAhG,QAAA0uB,aAAAuN,eAAAj2B,EAAAhG,SAGAgG,EAAAhG,QAAA0uB,aAAAwN,oBAAA,GAESl2B,EAAAioC,UAAAF,UAAA,qBAAA,OAGTxxC,KAAA01C,iBAAA,CAMA,IAAAC,GAAA31C,KAAAyD,QAAAy5B,sBACA0Y,GAAA,CACA51C,MAAAyD,QAAA2kB,gBAAApoB,KAAAyD,QAAAy5B,sBAAA,SAAA75B,GACA,GAAAwyC,GAAA71C,KAAA0P,EAAAoM,SACA,SAAA,GACA,IAAA,cAA6BvY,KAAAF,EAAAG,aAE7B,GAAAiG,EAAAqsC,gBAEA,WADA91C,MAAA6C,KAAA,WAAAQ,EAGA,MACA,KAAA,yBAAsCE,KAAAF,EAAAG,aACtC,IAAAiG,EAAAqsC,gBAAA,KAGA,IAAA,cAAArsC,EAAAhG,QAAA0uB,aAAAK,eAAAuN,oBAAA6V,EAsBA,YAfAA,IACAnsC,EAAA7G,aAAAgZ,KAAAxZ,EAAA2zC,aAAA,WAEAH,GAAA,EACAD,EAAA7lC,MAAA+lC,EAAAnmC,KAGAjG,EAAA7G,aAAAgZ,KAAAxZ,EAAA4zC,UAAA,WAEAJ,GAAA,EACAnsC,EAAAhG,QAAAg3B,mBAAAp3B,EAAA,KAAA,2BAGAuyC,GAAA,GAnBAA,IAAA,EAyBA,MAAAD,GAAA7lC,MAAA+lC,EAAAnmC,IAMA1P,KAAAyD,QAAA5B,GAAA,WAAA,SAAAiC,GAMA,GALA2F,EAAAK,QAAA,EAKAL,EAAAhG,QAAAogB,SAAAvhB,EAAA+uB,QAAA9uB,EAAAk0B,oBAAA,MAAA3yB,EAAAN,aAAA,gBAAAM,GAAA,MAAA,KAAAA,EAAA6N,KAAAC,QAAA,MAAA,CACA,GAAAnO,GAAAgG,EAAAhG,QACAJ,EAAAS,CAEA,IAAAL,EAAAyuB,SAAA,CACA,IAAAzuB,EAAAs1B,aAAA11B,EAAA,OACA,MAEAI,GAAAmzB,WAAA,EACAnzB,EAAA0uB,aAAAmC,eACAjxB,EAAAsO,KACA,WACAlO,EAAAitB,OAAAsB,QAAA5qB,KAAA/D,EAAAmlB,UAAA,SACA/kB,EAAAogB,OAAAvhB,EAAA+uB,QAAA9uB,EAAAk0B,mBACAhzB,EAAA4G,OACAZ,EAAAisC,iBAAA,EACAjsC,EAAA7G,aAAAC,KAAAT,EAAA6zC,aAAAxsC,EAAA3F,IAEA,SAAAA,GACAL,EAAA0M,OAAA7I,KAAAxD,GACAL,EAAAg3B,mBAAAp3B,EAAA,IAAA,uBACAI,EAAAy1B,OAAA71B,EAAAf,EAAAC,EAAAF,OAAAwb,6BAUA7d,KAAAyD,QAAA5B,GAAA,WAAA,SAAAiC,GACA2F,EAAAsxB,YAAA,IACAtxB,EAAAK,QAAA,EACAL,EAAAsxB,UAAA,EACAtxB,EAAA0qC,gBAAA,GAAAl5B,MACAxR,EAAA7G,aAAAC,KAAAT,EAAA8zC,YAAAzsC,EAAA3F,MAeA9D,KAAAyD,QAAA5B,GAAA,WAAA,SAAAiC,GACAowC,IACAzqC,EAAA7G,aAAAC,KAAAT,EAAA+zC,aAAA1sC,EAAA3F,KAQA9D,KAAAyD,QAAA5B,GAAA,SAAA,SAAAiC,GACAowC,IACAzqC,EAAA7G,aAAAC,KAAAT,EAAAe,UAAAsG,EAAA3F,KAMA9D,KAAAyD,QAAA5B,GAAA,MAAA,SAAAiC,GACAowC,IACAzqC,EAAA7G,aAAAC,KAAAT,EAAAe,UAAAsG,EAAA3F,KAMA9D,KAAAyD,QAAA5B,GAAA,SAAA,SAAAwB,EAAAC,GACAtD,KAAAm4B,WAAA,KAAA70B,GACA4wC,IACAzqC,EAAA7G,aAAAC,KAAAT,EAAAgB,WAAAqG,EAAApG,EAAAC,GAEAA,IAAAhB,EAAAC,EAAAF,OAAAqa,iBAEA1c,KAAA6jB,SAAAvhB,EAAA+uB,QAAA9uB,EAAAirB,kBACAxtB,KAAAm4B,WAAA,KAAA71B,EAAAC,EAAAF,OAAAqa,mBAOA1c,KAAAyD,QAAA5B,GAAA,aAAA,SAAAwB,EAAAC,GACA4wC,IACAzqC,EAAA7G,aAAAC,KAAAT,EAAAg0C,eAAA3sC,EAAApG,EAAAC,IAeA,IAAA+yC,GAAAr2C,KAAAyD,QAAA0uB,aAAAK,eAAAsN,4BAAA,aACAwW,GAAA,CACAt2C,MAAAyD,QAAA0uB,aAAAK,eAAAsN,2BAAA,WAEA,GAAA1R,GAAApuB,KAAA+/B,kBAGA,QAFAsW,EAAAvmC,MAAA9P,KAAA8b,WAEAsS,GACA,IAAA,YACA3kB,EAAA7G,aAAAC,KAAAT,EAAAm0C,aAAA9sC,EACA,MACA,KAAA,YAEA6sC,IACA7sC,EAAA7G,aAAAC,KAAAT,EAAA2zC,aAAAtsC,GACA6sC,GAAA,EAEA,MACA,KAAA,eACAlC,IACA3qC,EAAA7G,aAAAC,KAAAT,EAAAo0C,gBAAA/sC,EACA,MACA,KAAA,SACAA,EAAA7G,aAAAC,KAAAT,EAAA4zC,UAAAvsC,IAOA,IAAAgtC,IAAA,EAGAC,EAAA12C,KAAAyD,QAAAg2B,YACAz5B,MAAAyD,QAAAg2B,aAAA,WACAgd,GAAA,CACA,IAAAE,GAAAD,EAAA5mC,MAAA9P,KAAA8b,WACA86B,EAAA52C,KAAAk6B,kBACA2c,EAAA72C,KAAAm6B,cASA,OARAn6B,MAAAk6B,kBAAA,WAEA,MADAzwB,GAAA7G,aAAAC,KAAAT,EAAA00C,sBAAArtC,GACAmtC,EAAA9mC,MAAA9P,UAEAA,KAAAm6B,eAAA,WAEA,MADA1wB,GAAA7G,aAAAC,KAAAT,EAAA20C,mBAAAttC,GACAotC,EAAA/mC,MAAA9P,UAEA22C,EAMA,IAAAK,GAAAh3C,KAAAyD,QAAA22B,uBACAp6B,MAAAyD,QAAA22B,wBAAA,SAAA/2B,GACA,QAAA,GACA,IAAA,cAA4BE,KAAAF,EAAAG,aAC5B,GAAAizC,EAEA,WADAz2C,MAAA4yB,YAAAtwB,EAAAC,EAAA4b,KAAiD4L,KAAA1mB,EAAA0mB,MAGjD0sB,IAAA,EAGA,MAAAO,GAAAlnC,MAAA9P,KAAA8b,YAMA9b,KAAA4M,OAAAtH,EAAA8tC,MAAAC,UACArzC,KAAA0B,QAAAoJ,KAAA9K,KAAAyD,QAAAsqB,QAAA9Y,KAAAhN,IAAAmjB,YACAprB,KAAA0B,QAAA6xC,OAAAvzC,KAAAyD,QAAAsqB,QAAA9Y,KAAAhN,IAAA8L,MAGA/T,KAAA4M,OAAAtH,EAAA8tC,MAAAO,WACA3zC,KAAA0B,QAAAoJ,KAAA9K,KAAAyD,QAAAsqB,QAAA7Y,GAAAjN,IAAAmjB,YACAprB,KAAA0B,QAAA6xC,OAAAvzC,KAAAyD,QAAAsqB,QAAA7Y,GAAAjN,IAAA8L,MAOAzO,GAAA8tC,OACAC,SAAA,WACAM,SAAA,YAKAruC,EAAAS,UAAAotC,MAAA,WACA,MAAAnzC,MAAAyD,QAAA6Y,KAAAjc,IAKAiF,EAAAS,UAAAkxC,WAAA,WACA,MAAAj3C,MAAAyD,SAKA6B,EAAAS,UAAA6oB,OAAA,WACA,GAAAnrB,GAAAzD,KAAAi3C,YACA,OAAA,IAAApuC,SAAA,SAAA3F,EAAAgB,GACAT,EAAA8uB,WAA2B7H,WAAA,MAC3BxnB,OAMAoC,EAAAS,UAAAmxC,OAAA,SAAAnD,GACA,GAAAtqC,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACA,GAAAuF,EAAAK,OAAA,CACA,GAAA6Z,GAAAowB,EACAtqC,EAAAgrC,cAAAC,SAAAI,YACArrC,EAAAgrC,cAAAC,SAAAK,UAEA,IAAAtrC,EAAAhI,WAAAsyC,IAAAtqC,EAAAhI,UAAAsyC,EACA,MAAAtqC,GAAAgrC,cAAA9uB,KAAAhC,GACA9Z,KAAA,SAAAyS,GAEA,MADA7S,GAAAhI,WAAAsyC,EACAz3B,QAKApY,GAAA,GAAA8C,OAAA,iCAOA1B,EAAAS,UAAAivC,KAAA,SAAAvqC,GACA,GAAAhB,GAAAzJ,IAEA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACA,MAAAuG,GACAhB,EAAAK,OACAL,EAAAgrC,cAAA9uB,KAAAlc,EAAAgrC,cAAAC,SAAAM,MACAvqC,OAAAA,QAIAvG,GAAA,GAAA8C,OAAA,8BAPA,UAYA1B,EAAAS,UAAA4uC,KAAA,WAEA,GAAAlrC,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACAuF,EAAAK,OACA5G,EAAAuG,EAAAgrC,cAAA9uB,KAAAlc,EAAAgrC,cAAAC,SAAAC,OAGAzwC,EAAA,GAAA8C,OAAA,iCAOA1B,EAAAS,UAAAkE,SAAA,SAAAhE,EAAAsvB,GACA,GAAA9rB,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACA,GAAAuF,EAAAK,OAAA,CACAyrB,EAAAljB,SAAAkjB,IAAA,GACA,IAAA4hB,GAAA1tC,EAAAhG,QAAA0uB,aAAAK,eACAtsB,EAAAuD,EAAAhG,QAAAu4B,kBAAA,GACAob,EAAAD,EAAAE,iBAAAnxC,EAAA86B,iBAAA,GACAjgC,UAAAq2C,GAAAA,EAAAE,eACAF,EAAAG,WAAAtxC,EAAAsvB,GAEAryB,QAGAgB,GAAA,GAAA8C,OAAA,iCAOA1B,EAAAS,UAAAyxC,aAAA,SAAAvxC,EAAAsvB,GACA,GAAA9xB,GAAAzD,KAAAyD,OACA,OAAA,IAAAoF,SAAA,SAAA3F,EAAAgB,GACAqxB,EAAAljB,SAAAkjB,IAAA,IACA9xB,EAAAq0B,KAAA7xB,EAAA+L,YACAujB,SAAAA,IAEAryB,OAMAoC,EAAAS,UAAA0xC,cAAA,SAAAhtC,EAAA7J,GACA,GAAA6C,GAAAzD,KAAAyD,QACAgG,EAAAzJ,KACAqH,KACAktB,EAAA9pB,CAGA,OAFA7J,GAAAA,MAEA,GAAAiI,SAAA,SAAA3F,EAAAgB,GAIAT,EAAAogB,SAAAvhB,EAAA+uB,QAAA9uB,EAAAirB,kBACAtpB,EAAA,GAAA5B,GAAA4I,WAAA0Y,kBAAAngB,EAAAogB,QAKA,KACApZ,EAAAnI,EAAAsJ,QAAAyH,MAAA5I,EAAA,YAAAxC,KAAAwC,EACS,MAAA3G,GACTL,EAAA0M,OAAAgK,MAAA,sCAAA1P,GACAhH,EAAA0M,OAAAgK,MAAA,2CAKA,GADA1P,EAAAhH,EAAA9B,GAAA4R,gBAAA9I,IACAA,EACA,KAAA,IAAAiR,WAAA,mBAAA6Y,EAGAltB,GAAAD,KAAA,YAAA3D,EAAA/B,SACA2F,EAAAD,KAAA,UAAA9E,EAAAmJ,MAAA2J,kBAAA3R,EAAA9B,KACA0F,EAAAD,KAAA,aAAAqD,GACApD,EAAAD,KAAA,gBAAAqC,EAAAxE,cACAoC,EAAAD,KAAA,YAAAqC,EAAAxE,cAIAxB,EAAAmvB,YAAAtwB,EAAAC,EAAAuc,OACAzX,aAAAA,EACAsK,KAAA/Q,EAAA+Q,KACAyW,gBAAA,SAAA/kB,GAKA,QAAAq0C,GAAA3pB,GACA,GAAAA,EAAAjE,UAAAmpB,EAAA,CACA,GAAAthC,GAAAoc,GAAAA,EAAApc,MAAA,EACA,SAAA,GACA,IAAA,YAA+CpO,KAAAoO,GAC/Coc,EAAAhC,MAAA,IACA,MACA,KAAA,YAA+CxoB,KAAAoO,GAC/ClI,EAAAhG,QAAA8uB,YACArM,aAAA+R,GACAxuB,EAAA7G,aAAAmZ,IAAA,aAAA27B,GACAx0C,GACA,MACA,SACAgB,EAAAyN,KAlBA,GAAAsmB,GAAA,IACA,IAAA,MAAA50B,EAAAG,YAAA,CACA,GAAAyvC,GAAA5vC,EAAAymB,OAsBAmO,GAAAt0B,WAAA,WACAO,EAAA,GAAA8C,OAAA,sBACAyC,EAAA7G,aAAAmZ,IAAA,aAAA27B,IACqBjuC,EAAA+qC,iBACrB/qC,EAAA7G,aAAAf,GAAA,aAAA61C,OAGAxzC,GAAA,GAAA8C,OAAA,gCAAA3D,EAAAG,YAAA,6BAUA8B,EAAAS,UAAAyE,SAAA,SAAAC,EAAA7J,GACA,GAAA6I,GAAAzJ,IACA,QAAAyJ,EAAAjI,OAAAqH,QAAA3F,QAAA,MAAAuG,EAAAxG,SAAA,IAAA4G,KAAA,WAAsF,MAAAoqC,GAAA,OAAqBpqC,KAAA,WAC3G,MAAAJ,GAAAguC,cAAAhtC,EAAA7J,MAOA0E,EAAAS,UAAA4xC,QAAA,SAAAltC,EAAA7J,GACA,GAAA6I,GAAAzJ,KAAA6jC,EAAA,IACA,OAAAp6B,GAAAL,SAAAS,KAAA,WACA,MAAA,IAAAhB,SAAA,SAAA3F,EAAAgB,GACA2/B,EAAAzT,YAAA,WACA,KAAA3mB,EAAAhG,QAAAogB,SACAoM,cAAA4T,GACAp6B,EAAAa,SAAA,GACA3G,WAAA,WACA8F,EAAAe,SAAAC,EAAA7J,GACAsC,KACqB,OAER,SASboC,EAAAS,UAAAqD,OAAA,WACA,GAAAK,GAAAzJ,IAEA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GAEA,QAAA0zC,KACA10C,IACAuG,EAAA7G,aAAAmZ,IAAA3Z,EAAA8zC,YAAA0B,GACAnuC,EAAA7G,aAAAmZ,IAAA3Z,EAAAgB,WAAAy0C,GAGA,QAAAA,GAAA/zC,GACAI,EAAAJ,GACA2F,EAAA7G,aAAAmZ,IAAA3Z,EAAA8zC,YAAA0B,GACAnuC,EAAA7G,aAAAmZ,IAAA3Z,EAAAgB,WAAAy0C,GAGApuC,EAAA7G,aAAAf,GAAAO,EAAA8zC,YAAA0B,GACAnuC,EAAA7G,aAAAf,GAAAO,EAAAgB,WAAAy0C,GAEApuC,EAAA7G,aAAAC,KAAAT,EAAA6zC,aAAAxsC,GAEAA,EAAAhG,QAAAsxB,QACAxkB,OACAC,aAA8BC,OAAA,EAAAC,OAAA,GAC9BE,QACAgpB,OACAnpB,MAAAhH,EAAAioC,UAAAC,IAAA8B,YAEA5iC,QACAJ,MAAAhH,EAAAioC,UAAAC,IAAA+B,oBAeApuC,EAAAS,UAAAuE,QAAA,SAAAypC,GACA,GAAAtqC,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACAuF,EAAA6qC,QAAAP,EACAtqC,EAAAK,QACAgqC,EAAArqC,EAAAhG,QAAAu4B,kBAAA,GAAAvyB,EAAA6qC,OACAP,EAAAtqC,EAAA7G,aAAAC,KAAAT,EAAA01C,SAAAruC,GAAAA,EAAA7G,aAAAC,KAAAT,EAAA21C,WAAAtuC,GACAvG,KAGAgB,EAAA,GAAA8C,OAAA,iCAmBA1B,EAAAS,UAAAiyC,YAAA,SAAAjE,GACA,GAAAtqC,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACAuF,EAAA8qC,YAAAR,EACAtqC,EAAA6qC,QAAAP,EACAtqC,EAAAK,QACAgqC,EAAArqC,EAAAhG,QAAAu4B,kBAAA,GAAAvyB,EAAA8qC,WACAT,EAAArqC,EAAAhG,QAAAs4B,mBAAA,GAAAtyB,EAAA8qC,WACAR,EAAAtqC,EAAA7G,aAAAC,KAAAT,EAAA01C,SAAAruC,GAAAA,EAAA7G,aAAAC,KAAAT,EAAA21C,WAAAtuC,GACAvG,KAGAgB,EAAA,GAAA8C,OAAA,iCAUA1B,EAAAS,UAAA6sB,YAAA,SAAA5K,EAAArW,EAAA/Q,GACA,GAAA6I,GAAAzJ,IAGA,IAFAY,EAAAA,MAEAZ,KAAAyD,QAAAitB,OAAA,CAEA,GAAA3C,GAAA,GAAAzrB,GAAAioB,gBACAvC,EACAve,EAAAhG,QAAAitB,OAAAoB,cACAroB,EAAAhG,QAAA9B,IAEAooB,KAAAnpB,EAAAmpB,OAAAtgB,EAAAhG,QAAAitB,OAAAU,cAAA,GACAtH,QAAArgB,EAAAhG,QAAAitB,OAAArwB,GAAAypB,QACAuB,SAAA5hB,EAAAhG,QAAAitB,OAAAkB,UACAnI,SAAAhgB,EAAAhG,QAAAitB,OAAArwB,GAAAoxB,UACAxG,OAAAxhB,EAAAhG,QAAAitB,OAAAmB,WACAlI,OAAAlgB,EAAAhG,QAAAitB,OAAArwB,GAAAqxB,WACA9G,UAAAnhB,EAAAhG,QAAAitB,OAAA9F,UACAF,WAAA9pB,EAAA8pB,WACAC,aAAA/pB,EAAA+pB,cAEA/pB,EAAAyG,iBACAsK,GAAA5Q,OAGA,IAAAuB,GAAAmuB,eACA1C,QAAAA,EACAU,iBAAA,WACAhlB,EAAAhG,QAAAgrB,oBAEA/qB,iBAAA,WACA+F,EAAAhG,QAAAC,oBAEA0kB,gBAAAxnB,EAAAwnB,iBAAA,SAAA/kB,MAEKoG,EAAAhG,QAAA9B,IAAAgkB,SASLrgB,EAAAS,UAAAkyC,aAAA,SAAAlE,GACA,GAAAtqC,GAAAzJ,IAEA,OADAyJ,GAAAjI,SAAAuyC,EACA,GAAAlrC,SAAA,SAAA3F,EAAAgB,GACA,IAAAuF,EAAAK,SAAAL,EAAAhG,QAAAitB,OAuCA,KAAA,IAAA1pB,OAAA,4BAtCA,IAAA2K,GAAAlI,EAAAhG,QAAA0uB,aAAAK,eAAA0P,iBAAA5E,GACA7zB,GAAAjI,QAEAmQ,EAAAA,EAAAV,QAAA,aAAA,cACAxH,EAAAhG,QAAA0uB,aAAAjoB,OACAT,EAAAhG,QAAA+1B,OAAA,WAGA/vB,EAAAhG,QAAA0uB,aAAAhoB,SACAV,EAAAhG,QAAAk2B,SAAA,UAGAlwB,EAAAmpB,YAAAtwB,EAAAC,EAAAgc,OAAA5M,GACAtK,cACA,gCACA,YAAAoC,EAAAhG,QAAA/B,QACA+H,EAAAxE,aACAwE,EAAAtE,YAEAijB,gBAAA,SAAA/kB,GACA,QAAA,GACA,IAAA,cAAwCE,KAAAF,EAAAG,aACxC,KACA,KAAA,cAAwCD,KAAAF,EAAAG,aACxCN,IACAuG,EAAAmpB,YAAAtwB,EAAAC,EAAA4b,IAAA,MACA4L,KAAA1mB,EAAA0mB,MAEA,MACA,SACA7lB,EAAA,mBAAAb,EAAAG,aACAiG,EAAAjI,QAAAiI,EAAAjI,cAeA8D,EAAAS,UAAAmyC,OAAA,SAAAnE,GACA,GAAAtqC,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACA,QAAAi0C,KACAj1C,IACAuG,EAAA7G,aAAAmZ,IAAA3Z,EAAA20C,mBAAAqB,GAGA,QAAAA,GAAAt0C,GACAI,EAAAJ,GACA2F,EAAA7G,aAAAmZ,IAAA3Z,EAAA00C,sBAAAqB,GAGA1uC,EAAA7G,aAAAgZ,KAAAxZ,EAAA00C,sBAAAqB,GACA1uC,EAAA7G,aAAAgZ,KAAAxZ,EAAA20C,mBAAAqB,GAEArE,EAAAtqC,EAAAhG,QAAAyG,OAAAT,EAAAhG,QAAA0G,YAMA7E,EAAAS,UAAA9C,QAAA,SAAA8wC,GACA,GAAAtqC,GAAAzJ,IACA,OAAA,IAAA6I,SAAA,SAAA3F,EAAAgB,GACAuF,EAAAjI,SAAAuyC,EACAtqC,EAAAK,OACA5G,EAAAuG,EAAAyuC,OAAAnE,GAAAlqC,KAAA,SAAA8sC,GAMA,MALA5C,GACAtqC,EAAA7G,aAAAC,KAAAT,EAAAi2C,SAAA5uC,GAEAA,EAAA7G,aAAAC,KAAAT,EAAAk2C,WAAA7uC,GAEAktC,IANAltC,SAOa,SAAA3F,GAEb,KADA2F,GAAAjI,QAAAiI,EAAAjI,OACAsC,KAIAI,EAAA,GAAA8C,OAAA,iCAMA1B,EAAAS,UAAA/C,SAAA,WACA,MAAAhD,MAAAwB,QAKA8D,EAAAS,UAAAwyC,SAAA,WACA,MAAAv4C,MAAAs0C,OAAAt0C,KAAAu0C,WAKAjvC,EAAAS,UAAAyyC,WAAA,WACA,MAAAx4C,MAAAyB,UAKA6D,EAAAS,UAAA0yC,WAAA,WACA,MAAAz4C,MAAA0B,SAKA4D,EAAAS,UAAA2yC,gBAAA,WACA,MAAA14C,MAAAm0C,iBACA,GAAAl5B,OAAA09B,UAAA34C,KAAAm0C,gBAAAwE,UAGA,GAMArzC,EAAAS,UAAAqE,WAAA,WACA,MAAA,WAAApK,KAAAyD,QAAA0uB,aAAAK,eAAA0N,iBACAlgC,KAAAyD,QAAA0zB,WAKA7xB,EAAAS,UAAA0sC,SAAA,WACA,MAAAzyC,MAAAyD,QAAAogB,SAAAvhB,EAAA+uB,QAAA9uB,EAAAg0B,iBAAAv2B,KAAAyD,QAAAogB,SAAAvhB,EAAA+uB,QAAA9uB,EAAAgrB,mBAKAjoB,EAAAS,UAAA+vC,cAAA,WACA,MAAA91C,MAAA01C,iBAKA71C,EAAAD,QAAA0F,GtCg/XM,SAASzF,EAAQD,GuCz6ZvBC,EAAAD,SAEAq0C,MAAA,SAAA2E,GACA,MAAA,IAAA/vC,SAAA,SAAA3F,EAAAgB,GACAP,WAAAT,EAAA01C,MAIApzC,MAAA,WACA,GAAAqzC,KAKA,OAJAA,GAAAtxC,QAAA,GAAAsB,SAAA,SAAA3F,EAAAgB,GACA20C,EAAA31C,QAAAA,EACA21C,EAAA30C,OAAAA,IAEA20C,GAGApzC,OAAA,SAAAqzC,EAAAxV,GAMA,MALAA,GAAAA,MACAwV,EAAAA,MACAnzC,OAAAg8B,KAAA2B,GAAA/8B,QAAA,SAAAoS,GACAmgC,EAAAngC,GAAA2qB,EAAA3qB,KAEAmgC,GAGAC,KAAA,SAAAzV,GACA,MAAAtjC,MAAAyF,UAA6B69B,IAG7BliC,KAAA,WACA,MAAA,uCAAA6P,QAAA,QAAA,SAAAxQ,GACA,GAAAgS,GAAA,GAAAE,KAAAC,SAAA,EAAAM,EAAA,KAAAzS,EAAAgS,EAAA,EAAAA,EAAA,CACA,OAAAS,GAAAlB,SAAA,SvCm7ZM,SAASnS,EAAQD,GwCp9ZvBC,EAAAD,SACA+jB,QAAA,UACAq1B,cAAA,gBACApG,aAAA,eACAE,gBAAA,kBACAjvC,cAAA,gBACAM,gBAAA,kBACAH,sBAAA,wBACAlB,aAAA,eACAJ,gBAAA,kBACAK,aAAA,eACA0yC,eAAA,iBACAQ,aAAA,eACAC,YAAA,cACAC,aAAA,eACAhzC,UAAA,YACAizC,eAAA,iBACAhzC,WAAA,aACAi1C,SAAA,WACAC,WAAA,aACAR,SAAA,WACAC,WAAA,aACAzE,aAAA,eACAlB,cAAA,gBACAnuC,oBAAA,sBACAsyC,aAAA,eACAR,aAAA,eACAC,UAAA,YACAiD,YAAA,cACAC,UAAA,YACA1C,gBAAA,kBACAM,sBAAA,wBACAC,mBAAA,uBxC49ZM,SAASl3C,EAAQD,EAASM,GyC1/ZhC,QAAAqxC,KAMA,GAAA4H,GAAAlH,SAAAmH,cAAA,SACAC,EAAApH,SAAAmH,cAAA,SACAE,EAAA,SAAAl4C,IACAm4C,EAAA,UAAAn4C,GAEA+3C,GAAAK,aAAA,KAAAF,GACAH,EAAAK,aAAA,WAAA,QACAL,EAAAK,aAAA,SAAA,QACAL,EAAAK,aAAA,QAAA,IAEAH,EAAAG,aAAA,KAAAD,GACAF,EAAAG,aAAA,WAAA,QACAH,EAAAG,aAAA,SAAA,QAEAvH,SAAAtgC,KAAA8nC,YAAAN,GACAlH,SAAAtgC,KAAA8nC,YAAAJ,GAEAF,EAAAlV,OAAA,EAEAjkC,KAAAyzC,WAAA0F,EACAn5C,KAAA0zC,YAAA2F,EACAr5C,KAAA05C,aAAAJ,EACAt5C,KAAA25C,cAAAJ,EA9BA,GAAAn4C,GAAAlB,EAAA,IAAAkB,IAkCAvB,GAAAD,QAAA2xC,GzCkgaM,SAAS1xC,EAAQD,EAASM,G0CpiahC,YASA,SAAAqF,GAAAq0C,EAAAh5C,GAEA,GAAA6I,GAAAzJ,IAEAY,GAAAA,MAEAZ,KAAA65C,SAAAD,EACA55C,KAAA85C,UAAAl5C,EAAAyyC,UAAA,qBACArzC,KAAA+5C,UAAAn5C,EAAA+yC,UAAA,qBACA3zC,KAAAg6C,UAEAJ,EAAA/3C,GAAA+3C,EAAAz3C,OAAAW,aAAA,WACA2G,EAAAwwC,cAAA,KAGAL,EAAA/3C,GAAA+3C,EAAAz3C,OAAAY,aAAA,WACA0G,EAAAywC,cAAA,KAGAN,EAAA/3C,GAAA+3C,EAAAz3C,OAAA8zC,aAAA,SAAAxyC,GACAA,EAAAqyC,iBACArsC,EAAAywC,cAAA,KAIAN,EAAA/3C,IAAA+3C,EAAAz3C,OAAA+zC,YAAA0D,EAAAz3C,OAAAg0C,aAAAyD,EAAAz3C,OAAAgB,UAAAy2C,EAAAz3C,OAAAiB,YAAA,WACAqG,EAAAwwC,cAAA,GACAxwC,EAAAywC,cAAA,KAlCA,GAAAzpC,GAAAvQ,EAAA,GAuCAqF,GAAAQ,UAAAo0C,WAAA,SAAA9sC,EAAA0mC,EAAA9P,GAEAjkC,KAAAg6C,OAAA3sC,GAMA0mC,EACA/zC,KAAAg6C,OAAA3sC,GAAA+sC,QAGAp6C,KAAAg6C,OAAA3sC,GAAAhH,OATA0tC,IACAhzC,SAAAkjC,IAAAxzB,EAAAwzB,OAAAA,GACAjkC,KAAAg6C,OAAA3sC,GAAAoD,EAAAuzB,KAAA32B,GAAgDgtC,MAAA,MAahD90C,EAAAQ,UAAAk0C,aAAA,SAAAlG,GACA/zC,KAAAm6C,WAAAn6C,KAAA85C,UAAA/F,EAAA,KAGAxuC,EAAAQ,UAAAm0C,aAAA,SAAAnG,GACA/zC,KAAAm6C,WAAAn6C,KAAA+5C,UAAAhG,EAAA,IAGAl0C,EAAAD,QAAA2F,G1C4iaM,SAAS1F,EAAQD,EAASM,G2C/mahC,GACAmF,IADAoB,QAAA4T,MACAna,EAAA,IAEAL,GAAAD,SAEAokC,KAAA,SAAA32B,EAAAzM,GAEA,GAAA05C,GAAA,GAAAj1C,GAEAoL,EAAA,GAAA8pC,MAsDA,IApDA9pC,EAAAwzB,OAAA,EAEAxzB,EAAApM,iBAAA,aAAA,SAAAgR,GACAilC,EAAAz3C,KAAA,YACA0yB,SAAA9kB,EAAA8kB,SACAT,SAAArkB,EAAA+pC,YAAA/pC,EAAA8kB,aAIA9kB,EAAApM,iBAAA,SAAA,SAAAgR,GACAilC,EAAAz3C,KAAA,YACA0yB,SAAA9kB,EAAA8kB,SACAT,SAAArkB,EAAA+pC,YAAA/pC,EAAA8kB,aAGA9kB,EAAApM,iBAAA,QAAA,SAAAgR,GACAilC,EAAAz3C,KAAA,WAEA4N,EAAApM,iBAAA,QAAA,SAAAgR,GACAilC,EAAAz3C,KAAA,YACA0yB,SAAA9kB,EAAA8kB,SACAwO,QAAA,EACAjP,SAAArkB,EAAA+pC,YAAA/pC,EAAA8kB,aAGA9kB,EAAApM,iBAAA,OAAA,SAAAgR,GACAilC,EAAAz3C,KAAA,YACA0yB,SAAA9kB,EAAA8kB,SACAklB,SAAA,EACA3lB,SAAArkB,EAAA+pC,YAAA/pC,EAAA8kB,aAGA9kB,EAAApM,iBAAA,QAAA,WACAoC,QAAAC,IAAA,QAAA+J,EAAA4J,OACAigC,EAAAz3C,KAAA,QAAA4N,EAAA4J,SAGAigC,EAAAj0C,KAAAoK,EAAAiqC,MAAA54C,KAAA2O,GACA6pC,EAAAI,MAAAjqC,EAAAiqC,MAAA54C,KAAA2O,GACA6pC,EAAAK,OAAAlqC,EAAAuzB,KAAAliC,KAAA2O,GACA6pC,EAAAF,MAAA,WACA3pC,EAAA+pC,YAAA,EACA/pC,EAAAuzB,QAGAsW,EAAA/kB,SAAA,WACA,MAAA5iB,MAAAioC,KAAAnqC,EAAA8kB,WAGA9kB,EAAA6yB,IAAAj2B,EACAoD,EAAAoqC,KAAAxtC,GAEAzM,EACA,IAAA,GAAAk6C,KAAAl6C,GACAk6C,IAAArqC,KACAA,EAAAqqC,GAAAl6C,EAAAk6C,GAOA,OAFArqC,GAAAuzB,OAEAsW","file":"ringcentral-web-phone.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebPhone\"] = factory();\n\telse\n\t\troot[\"RingCentral\"] = root[\"RingCentral\"] || {}, root[\"RingCentral\"][\"WebPhone\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebPhone\"] = factory();\n\telse\n\t\troot[\"RingCentral\"] = root[\"RingCentral\"] || {}, root[\"RingCentral\"][\"WebPhone\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar SIP = __webpack_require__(2);\nvar EventEmitter = __webpack_require__(35);\nvar UserAgent = __webpack_require__(36);\nvar PhoneLine = __webpack_require__(37);\nvar AudioHelper = __webpack_require__(41);\nvar defer = __webpack_require__(38).defer;\nvar uuid = __webpack_require__(38).uuid;\nvar extend = __webpack_require__(38).extend;\nvar EVENT_NAMES = __webpack_require__(39);\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//Patching proto because of https://developers.google.com/web/updates/2015/07/mediastream-deprecations\nvar mediaStreamManagerProto = Object.create(SIP.WebRTC.MediaStreamManager.prototype, {\n    'release': {\n        value: function release(stream) {\n            var streamId = SIP.WebRTC.MediaStreamManager.streamId(stream);\n            if (this.acquisitions[streamId] === false) {\n                //MediaStream.stop removed in M47\n                if (typeof (stream.stop) === 'function') {\n                    stream.stop();\n                }\n                else {\n                    stream.getTracks().forEach(function(track) {\n                        track.stop()\n                    });\n                }\n            }\n            delete this.acquisitions[streamId];\n        }\n    }\n});\n\nSIP.WebRTC.MediaStreamManager.prototype = mediaStreamManagerProto;\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n/**\n * @namespace RingCentral\n * @param {boolean} [options.audioHelper] Automatically create audio helper\n * @param {string} [options.uuid] Instance ID\n * @constructor\n */\nfunction WebPhone(options) {\n\n    options = options || {};\n\n    var service = this;\n\n    this.__registerDeferred = undefined;\n    this.__unregisterDeferred = undefined;\n    this.__callDeferred = undefined;\n    this.__sipRegistered = false;\n    this.__sipOutboundEnabled = false;\n\n    if (options.uuid) {\n        this.uuid = options.uuid;\n    } else {\n        localStorage['rc-webPhone-uuid'] = localStorage['rc-webPhone-uuid'] || uuid();\n        this.uuid = localStorage['rc-webPhone-uuid'];\n    }\n\n    this.activeLine = null;\n\n    this.onMute = false;\n    this.onHold = false;\n    this.onRecord = false;\n    this.contact = undefined;\n\n    var ua = new UserAgent();\n\n    this.ua = ua;\n    this.on = ua.on.bind(ua);\n\n    this.username = null;\n\n    this.isRegistered = false;\n    this.isRegistering = false;\n    this.isUnregistering = false;\n\n    this.events = EVENT_NAMES;\n\n    this.causes = SIP.C.causes;\n    this.reasons = SIP.C.REASON_PHRASE;\n\n    //naming convention: incoming or sipincoming?\n    service.on(EVENT_NAMES.sipIncomingCall, function(line) {\n        service.ua.eventEmitter.emit(EVENT_NAMES.incomingCall, line);\n    });\n\n    //naming convention: outgoing or sipoutgoing?\n    service.on(EVENT_NAMES.outgoingCall, function(line) {\n        if (service.activeLine && !service.activeLine.isOnHold()) {\n            service.activeLine.setHold();\n        }\n        service.__callDeferred && service.__callDeferred.resolve(line);\n        service.__callDeferred = null;\n    });\n\n    //naming convention: call or line?\n    service.on([EVENT_NAMES.callEnded, EVENT_NAMES.callFailed], function(call) {\n        //delete activeLine property if the call has ended on the other side\n        if (call && service.activeLine && call === service.activeLine) {\n            service.activeLine = null;\n        }\n    });\n\n    // On Call Failed due to 503 Invite Connection error reconnect the call\n    service.on(EVENT_NAMES.callFailed, function(call, response, cause) {\n        if (response) {\n            switch (true) {\n                //[WRTC-424] Should reconnect the websocket if received 503 on INVITE\n                case (/^503$/.test(response.status_code)):\n                    //This method will throw 'Connection Error', so we just remove it\n                    call.session.onTransportError = function() {};\n                    //Re-register after 500ms\n                    setTimeout(service.reregister.bind(service, true), 500);\n                    break;\n            }\n        }\n    });\n\n\n    // Setting flags for SIP Registration process\n    service.on(EVENT_NAMES.sipRegistered, function(e) {\n        service.__sipRegistered = true;\n        service.__registerDeferred && service.__registerDeferred.resolve(e);\n        service.isRegistered = true;\n        service.isRegistering = false;\n        service.isUnregistering = false;\n        service.isUnregistered = false;\n    });\n\n    service.on([EVENT_NAMES.sipRegistrationFailed, EVENT_NAMES.sipConnectionFailed], function(e) {\n        service.__sipRegistered = false;\n        service.__registerDeferred && service.__registerDeferred.reject(e);\n        service.isRegistered = false;\n        service.isRegistering = false;\n        service.isUnregistering = false;\n        service.isUnregistered = false;\n    });\n\n    service.on(EVENT_NAMES.sipUnRegistered, function(e) {\n        service.__sipRegistered = false;\n        service.__unregisterDeferred && service.__unregisterDeferred.resolve(e);\n        service.isRegistered = false;\n        service.isRegistering = false;\n        service.isUnregistered = true;\n        service.isUnregistering = false;\n    });\n\n    window.addEventListener('unload', function() {\n        service.hangup();\n        service.unregister();\n    });\n\n    this._audioHelper = null;\n    if (options.audioHelper) service.createAudioHelper(options.audioHelper);\n\n    this._appKey = options.appKey;\n    this._appName = options.appName;\n    this._appVersion = options.appVersion;\n\n    this._x_userAgent = (options.appName ? (options.appName + (options.appVersion ? '/' + options.appVersion : '')) + ' ' : '') +\n                      'RCWEBPHONE/' + WebPhone.version;\n\n    this._client_id = options.appkey;\n\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.version = '0.1.0';\n\nWebPhone.PhoneLine = PhoneLine;\nWebPhone.EventEmitter = EventEmitter;\nWebPhone.UserAgent = UserAgent;\nWebPhone.AudioHelper = AudioHelper;\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n/**\n * @param [options]\n * @return {AudioHelper}\n */\nWebPhone.prototype.createAudioHelper = function(options) {\n    if (!this._audioHelper) {\n        console.log('Helper Created');\n        this._audioHelper = new AudioHelper(this, options);\n    }\n    return this._audioHelper;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.prototype.register = function(info, checkFlags) {\n\n    try {\n        var service = this;\n\n        // console.log(\"Sip Data\"+JSON.stringify(data));\n\n        if (!checkFlags || (\n            typeof(info.sipFlags) === 'object' &&\n                //checking for undefined for platform v7.3, which doesn't support this flag\n            (info.sipFlags.outboundCallsEnabled === undefined || info.sipFlags.outboundCallsEnabled === true))\n        ) {\n\n            // Access SIP flags\n            this.__sipOutboundEnabled = info.sipFlags.outboundCallsEnabled;\n\n            // console.log('SIP Provision data', data+'\\n');\n            info = info.sipInfo[0];\n\n        } else {\n            throw new Error('ERROR.sipOutboundNotAvailable'); //FIXME Better error reporting...\n        }\n\n        var headers = [];\n        var endpointId = this.uuid;\n        if (endpointId) {\n            headers.push('P-rc-endpoint-id: ' + endpointId);\n            headers.push('x-user-agent:'+ this._x_userAgent);\n            headers.push('client-id:'+this._client_id);\n        }\n\n        extend(info, {\n            extraHeaders: headers\n        });\n\n        if (service.isRegistered) {\n            console.warn('Already registered, please unregister the UA first');\n            return service.__registerDeferred.promise;\n        }\n\n        if (service.isRegistering) {\n            console.warn('Already registering the UA');\n            return service.__registerDeferred.promise;\n        }\n\n        service.__registerDeferred = defer();\n        service.isRegistering = true;\n        service.isRegistered = false;\n\n        //compatability properties\n        info.wsServers = info.outboundProxy && info.transport\n            ? info.transport.toLowerCase() + '://' + info.outboundProxy\n            : info.wsServers;\n        info.domain = info.domain || info.sipDomain;\n        info.username = info.username || info.userName;\n\n        info.extraHeaders = Array.isArray(info.extraHeaders) ? info.extraHeaders : [];\n\n\n\n\n\n        var options = {\n            wsServers: info.wsServers,\n            uri: \"sip:\" + info.username + \"@\" + info.domain,\n            password: info.password,\n            authorizationUser: info.authorizationId,\n            traceSip: true,\n            stunServers: info.stunServers || ['stun:74.125.194.127:19302'],\n            turnServers: [],\n            log: {\n                level: 3 //FIXME LOG LEVEL 3\n            },\n            domain: info.domain,\n            autostart: false,   //turn off autostart on UA creation\n            register: false,     //turn off auto register on UA creation,\n            iceGatheringTimeout: info.iceGatheringTimeout || 3000,\n\n            headers: headers\n        };\n\n        service.username = info.userName;\n        service.ua.setSIPConfig(options);\n        service.ua.start({\n            extraHeaders: info.extraHeaders\n        });\n    }\n    catch (e) {\n        service.isRegistering = false;\n        service.isRegistered = false;\n        return Promise.reject(e);\n    }\n\n    return service.__registerDeferred.promise;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.prototype.reregister = function(reconnect) {\n    var service = this;\n    if (service.isRegistering) return service.__registerDeferred;\n    service.__registerDeferred = defer();\n    service.isRegistering = true;\n    service.ua.reregister({}, !!reconnect);\n    return service.__registerDeferred.promise;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.prototype.unregister = function() {\n    var service = this;\n    if (service.isRegistering) {\n        service.ua.forceDisconnect();\n        service.isRegistering = false;\n        service.isUnregistering = false;\n        service.isRegistered = false;\n        service.isUnregistered = true;\n    }\n\n    if (service.isUnregistered || service.isUnregistering) return service.__unregisterDeferred;\n\n    service.isUnregistering = true;\n    service.isUnregistered = false;\n\n    service.__unregisterDeferred = defer();\n    if (service.__sipRegistered) {\n        service.ua.stop();\n    }\n    else {\n        service.__unregisterDeferred.resolve(null);\n    }\n    return service.__unregisterDeferred.promise.catch(function() {\n        return null;\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.prototype.forceDisconnect = function() {\n    this.ua.forceDisconnect();\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.prototype.call = function(toNumber, fromNumber, country) {\n    var service = this;\n    if(!this.__sipOutboundEnabled || false === Boolean(this.__sipOutboundEnabled)) {\n        throw new Error('Outbound calling is disabled'); // TODO: Fix this to be more robust error messaging\n    }\n    if(!toNumber)\n        throw new Error('Invalid or undefined [toNumber]');\n    if (!service.__callDeferred) {\n        service.__callDeferred = defer();\n        this.activeLine = service.ua.call.call(service.ua, toNumber, {\n            fromNumber: fromNumber,\n            country: country\n        });\n    }\n    return service.__callDeferred;\n};\n\n\n/*--------------------------------------------------------------------------------------------------------------------*/\nWebPhone.prototype.answer = function(line) {\n    var incomingLines = this.ua.getIncomingLinesArray();\n    var activeLines = this.ua.getActiveLinesArray();\n    var self = this;\n\n    return new Promise(function(resolve, reject) {\n        if (!line) {\n            line = incomingLines.length > 0 && incomingLines[0];\n        }\n\n        if (line) {\n            var promises = [];\n            activeLines.forEach(function (activeLine) {\n                if (activeLine !== line) {\n                    !activeLine.isOnHold() && promises.push(activeLine.setHold(true));\n                }\n            });\n            resolve(Promise\n                .all(promises)\n                .then(function () {\n                    self.activeLine = line;\n                    self.ua.answer(line);\n                })\n                .catch(function (e) {\n                    self.hangup(line);\n                    throw e;\n                }));\n        } else {\n            reject();            \n        }\n    });\n\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.prototype.onCall = function() {\n    return this.ua.getActiveLinesArray().filter(function(line) {\n            return line.onCall;\n        }).length > 0;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/***\n * deprecated\n * @param line\n * @returns {*}\n */\nWebPhone.prototype.hangup = function(line) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        self.ua.hangup(line);\n        if (line === self.activeLine) self.activeLine = null;\n        resolve();\n    });\n};\n\nWebPhone.prototype.getLine = function(line) {\n    if (!line) line = this.activeLine;\n    if (!line) throw new Error('No line or no active line');\n    return line;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//FIXME: Check if we can replace this with  SIPJS dtmf(tone,[options]) ref: http://sipjs.com/api/0.7.0/session/#dtmftone-options\n/***\n * deprecated\n * @param value\n * @param line\n * @returns {*}\n */\nWebPhone.prototype.sendDTMF = function(value, line) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        line && line.sendDTMF.call(line, value);\n        resolve();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/***\n * deprecated\n * @param line\n * @returns {*}\n */\nWebPhone.prototype.hold = function(line) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        line && line.setHold(true);\n        if (line === self.activeLine) self.activeLine = null;\n        resolve();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/***\n * deprecated\n * @param line\n * @returns {*}\n */\nWebPhone.prototype.unhold = function(line) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        if (line) {\n            self.ua.getActiveLinesArray().forEach(function (activeLine) {\n                if (activeLine !== line && !activeLine.isIncoming() && !activeLine.isOnHold()) {\n                    activeLine.setHold(true);\n                }\n            });\n            line.setHold(false);\n            self.activeLine = line;\n        }\n        resolve();\n    });\n};\n\n////FIXME: Use SIPJS mute() and unmute() ref:http://sipjs.com/api/0.7.0/session/#muteoptions\n/*--------------------------------------------------------------------------------------------------------------------*/\n/***\n * deprecated\n * @param line\n * @returns {*}\n */\nWebPhone.prototype.mute = function(line) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        line && line.setMute(true);\n        resolve();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/***\n * deprecated\n * @param line\n * @returns {*}\n */\nWebPhone.prototype.unmute = function(line) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        line && line.setMute(false);\n        resolve();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/***\n * deprecated\n * @param line\n * @param target\n * @param options\n * @returns {*}\n */\n//Phone-line->transfer->blindTransfer\nWebPhone.prototype.transfer = function(line, target, options) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        line && line.transfer(target, options);\n        if (line === self.activeLine) self.activeLine = null;\n        resolve();\n    });\n};\n\nmodule.exports = WebPhone;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * @name SIP\n * @namespace\n */\nmodule.exports = (function(window) {\n  \"use strict\";\n\n  var SIP = {};\n\n  var pkg = __webpack_require__(3);\n\n  Object.defineProperties(SIP, {\n    version: {\n      get: function(){ return pkg.version; }\n    },\n    name: {\n      get: function(){ return pkg.title; }\n    }\n  });\n\n  __webpack_require__(4)(SIP);\n  var Logger = __webpack_require__(5);\n  SIP.LoggerFactory = __webpack_require__(6)(window, Logger);\n  __webpack_require__(7)(SIP);\n  SIP.C = __webpack_require__(8)(SIP.name, SIP.version);\n  SIP.Exceptions = __webpack_require__(9);\n  SIP.Timers = __webpack_require__(10)(window);\n  __webpack_require__(11)(SIP, window);\n  __webpack_require__(12)(SIP);\n  __webpack_require__(13)(SIP);\n  __webpack_require__(14)(SIP);\n  __webpack_require__(15)(SIP);\n  __webpack_require__(16)(SIP, window);\n  var DialogRequestSender = __webpack_require__(17)(SIP, window);\n  __webpack_require__(18)(SIP, DialogRequestSender);\n  __webpack_require__(19)(SIP);\n  __webpack_require__(20)(SIP, window);\n  SIP.MediaHandler = __webpack_require__(21)(SIP.EventEmitter);\n  __webpack_require__(22)(SIP);\n  __webpack_require__(23)(SIP);\n  var SessionDTMF = __webpack_require__(24)(SIP);\n  __webpack_require__(25)(SIP, window, SessionDTMF);\n  __webpack_require__(26)(SIP, window);\n  var WebRTCMediaHandler = __webpack_require__(27)(SIP);\n  var WebRTCMediaStreamManager = __webpack_require__(28)(SIP);\n  SIP.WebRTC = __webpack_require__(29)(SIP.Utils, window, WebRTCMediaHandler, WebRTCMediaStreamManager);\n  __webpack_require__(30)(SIP, window);\n  SIP.Hacks = __webpack_require__(31)(SIP);\n  __webpack_require__(32)(SIP);\n  SIP.DigestAuthentication = __webpack_require__(33)(SIP.Utils);\n  SIP.Grammar = __webpack_require__(34)(SIP);\n\n  return SIP;\n})((typeof window !== 'undefined') ? window : global);\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\nmodule.exports = {\n\t\"_args\": [\n\t\t[\n\t\t\t\"sip.js@0.6.4\",\n\t\t\t\"/Users/howard.zhang/Sites/ringcentral-web-phone\"\n\t\t]\n\t],\n\t\"_from\": \"sip.js@0.6.4\",\n\t\"_id\": \"sip.js@0.6.4\",\n\t\"_inCache\": true,\n\t\"_installable\": true,\n\t\"_location\": \"/sip.js\",\n\t\"_npmUser\": {\n\t\t\"email\": \"eric.green@onsip.com\",\n\t\t\"name\": \"egreen_onsip\"\n\t},\n\t\"_npmVersion\": \"1.4.13\",\n\t\"_phantomChildren\": {},\n\t\"_requested\": {\n\t\t\"name\": \"sip.js\",\n\t\t\"raw\": \"sip.js@0.6.4\",\n\t\t\"rawSpec\": \"0.6.4\",\n\t\t\"scope\": null,\n\t\t\"spec\": \"0.6.4\",\n\t\t\"type\": \"version\"\n\t},\n\t\"_requiredBy\": [\n\t\t\"/\"\n\t],\n\t\"_resolved\": \"https://registry.npmjs.org/sip.js/-/sip.js-0.6.4.tgz\",\n\t\"_shasum\": \"e080d4b0fa1a7dd803741d6bca6d32c29ae37380\",\n\t\"_shrinkwrap\": null,\n\t\"_spec\": \"sip.js@0.6.4\",\n\t\"_where\": \"/Users/howard.zhang/Sites/ringcentral-web-phone\",\n\t\"author\": {\n\t\t\"email\": \"will@onsip.com\",\n\t\t\"name\": \"Will Mitchell\"\n\t},\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/onsip/SIP.js/issues\"\n\t},\n\t\"contributors\": [\n\t\t{\n\t\t\t\"url\": \"http://sipjs.com/authors/\"\n\t\t}\n\t],\n\t\"dependencies\": {},\n\t\"description\": \"A simple, intuitive, and powerful JavaScript signaling library\",\n\t\"devDependencies\": {\n\t\t\"browserify\": \"^4.1.8\",\n\t\t\"grunt\": \"~0.4.0\",\n\t\t\"grunt-browserify\": \"^2.1.0\",\n\t\t\"grunt-cli\": \"~0.1.6\",\n\t\t\"grunt-contrib-copy\": \"^0.5.0\",\n\t\t\"grunt-contrib-jasmine\": \"~0.6.0\",\n\t\t\"grunt-contrib-jshint\": \">0.5.0\",\n\t\t\"grunt-contrib-uglify\": \"~0.2.0\",\n\t\t\"grunt-peg\": \"~1.3.1\",\n\t\t\"grunt-trimtrailingspaces\": \"^0.4.0\",\n\t\t\"node-minify\": \"~0.7.2\",\n\t\t\"pegjs\": \"0.8.0\",\n\t\t\"sdp-transform\": \"~0.4.0\"\n\t},\n\t\"directories\": {},\n\t\"dist\": {\n\t\t\"shasum\": \"e080d4b0fa1a7dd803741d6bca6d32c29ae37380\",\n\t\t\"tarball\": \"http://registry.npmjs.org/sip.js/-/sip.js-0.6.4.tgz\"\n\t},\n\t\"engines\": {\n\t\t\"node\": \">=0.8\"\n\t},\n\t\"gitHead\": \"209fb9bb50f1918522d37a002b83f21abd6946ab\",\n\t\"homepage\": \"http://sipjs.com\",\n\t\"keywords\": [\n\t\t\"sip\",\n\t\t\"websocket\",\n\t\t\"webrtc\",\n\t\t\"library\",\n\t\t\"javascript\"\n\t],\n\t\"license\": \"MIT\",\n\t\"main\": \"src/SIP.js\",\n\t\"maintainers\": [\n\t\t{\n\t\t\t\"email\": \"joseph@onsip.com\",\n\t\t\t\"name\": \"joseph-onsip\"\n\t\t},\n\t\t{\n\t\t\t\"email\": \"eric.green@onsip.com\",\n\t\t\t\"name\": \"egreen_onsip\"\n\t\t}\n\t],\n\t\"name\": \"sip.js\",\n\t\"optionalDependencies\": {},\n\t\"readme\": \"ERROR: No README data found!\",\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git+https://github.com/onsip/SIP.js.git\"\n\t},\n\t\"scripts\": {\n\t\t\"test\": \"grunt travis --verbose\"\n\t},\n\t\"title\": \"SIP.js\",\n\t\"version\": \"0.6.4\"\n};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * @fileoverview Utils\n */\n\nmodule.exports = function (SIP) {\nvar Utils;\n\nUtils= {\n\n  augment: function (object, constructor, args, override) {\n    var idx, proto;\n\n    // Add public properties from constructor's prototype onto object\n    proto = constructor.prototype;\n    for (idx in proto) {\n      if (override || object[idx] === undefined) {\n        object[idx] = proto[idx];\n      }\n    }\n\n    // Construct the object as though it were just created by constructor\n    constructor.apply(object, args);\n  },\n\n  optionsOverride: function (options, winner, loser, isDeprecated, logger, defaultValue) {\n    if (isDeprecated && options[loser]) {\n      logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');\n    }\n\n    if (options[winner] && options[loser]) {\n      logger.warn(winner + ' overriding ' + loser);\n    }\n\n    options[winner] = options[winner] || options[loser] || defaultValue;\n  },\n\n  desugarSessionOptions: function desugarSessionOptions (options) {\n    if (global.HTMLMediaElement && options instanceof global.HTMLMediaElement) {\n      options = {\n        media: {\n          constraints: {\n            audio: true,\n            video: options.tagName === 'VIDEO'\n          },\n          render: {\n            remote: {\n              video: options\n            }\n          }\n        }\n      };\n    }\n    return options;\n  },\n\n  str_utf8_length: function(string) {\n    return encodeURIComponent(string).replace(/%[A-F\\d]{2}/g, 'U').length;\n  },\n\n  getPrefixedProperty: function (object, name) {\n    if (object == null) {\n      return;\n    }\n    var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);\n    var prefixedNames = [name, 'webkit' + capitalizedName, 'moz' + capitalizedName];\n    for (var i in prefixedNames) {\n      var property = object[prefixedNames[i]];\n      if (property) {\n        return property;\n      }\n    }\n  },\n\n  generateFakeSDP: function(body) {\n    if (!body) {\n      return;\n    }\n\n    var start = body.indexOf('o=');\n    var end = body.indexOf('\\r\\n', start);\n\n    return 'v=0\\r\\n' + body.slice(start, end) + '\\r\\ns=-\\r\\nt=0 0\\r\\nc=IN IP4 0.0.0.0';\n  },\n\n  isFunction: function(fn) {\n    if (fn !== undefined) {\n      return Object.prototype.toString.call(fn) === '[object Function]';\n    } else {\n      return false;\n    }\n  },\n\n  isDecimal: function (num) {\n    return !isNaN(num) && (parseFloat(num) === parseInt(num,10));\n  },\n\n  createRandomToken: function(size, base) {\n    var i, r,\n      token = '';\n\n    base = base || 32;\n\n    for( i=0; i < size; i++ ) {\n      r = Math.random() * base|0;\n      token += r.toString(base);\n    }\n\n    return token;\n  },\n\n  newTag: function() {\n    return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);\n  },\n\n  // http://stackoverflow.com/users/109538/broofa\n  newUUID: function() {\n    var UUID =  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);\n      return v.toString(16);\n    });\n\n    return UUID;\n  },\n\n  hostType: function(host) {\n    if (!host) {\n      return;\n    } else {\n      host = SIP.Grammar.parse(host,'host');\n      if (host !== -1) {\n        return host.host_type;\n      }\n    }\n  },\n\n  /**\n  * Normalize SIP URI.\n  * NOTE: It does not allow a SIP URI without username.\n  * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.\n  * Detects the domain part (if given) and properly hex-escapes the user portion.\n  * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.\n  * @private\n  * @param {String} target\n  * @param {String} [domain]\n  */\n  normalizeTarget: function(target, domain) {\n    var uri, target_array, target_user, target_domain;\n\n    // If no target is given then raise an error.\n    if (!target) {\n      return;\n    // If a SIP.URI instance is given then return it.\n    } else if (target instanceof SIP.URI) {\n      return target;\n\n    // If a string is given split it by '@':\n    // - Last fragment is the desired domain.\n    // - Otherwise append the given domain argument.\n    } else if (typeof target === 'string') {\n      target_array = target.split('@');\n\n      switch(target_array.length) {\n        case 1:\n          if (!domain) {\n            return;\n          }\n          target_user = target;\n          target_domain = domain;\n          break;\n        case 2:\n          target_user = target_array[0];\n          target_domain = target_array[1];\n          break;\n        default:\n          target_user = target_array.slice(0, target_array.length-1).join('@');\n          target_domain = target_array[target_array.length-1];\n      }\n\n      // Remove the URI scheme (if present).\n      target_user = target_user.replace(/^(sips?|tel):/i, '');\n\n      // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.\n      if (/^[\\-\\.\\(\\)]*\\+?[0-9\\-\\.\\(\\)]+$/.test(target_user)) {\n        target_user = target_user.replace(/[\\-\\.\\(\\)]/g, '');\n      }\n\n      // Build the complete SIP URI.\n      target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain;\n\n      // Finally parse the resulting URI.\n      if (uri = SIP.URI.parse(target)) {\n        return uri;\n      } else {\n        return;\n      }\n    } else {\n      return;\n    }\n  },\n\n  /**\n  * Hex-escape a SIP URI user.\n  * @private\n  * @param {String} user\n  */\n  escapeUser: function(user) {\n    // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n    return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');\n  },\n\n  headerize: function(string) {\n    var exceptions = {\n      'Call-Id': 'Call-ID',\n      'Cseq': 'CSeq',\n      'Rack': 'RAck',\n      'Rseq': 'RSeq',\n      'Www-Authenticate': 'WWW-Authenticate'\n      },\n      name = string.toLowerCase().replace(/_/g,'-').split('-'),\n      hname = '',\n      parts = name.length, part;\n\n    for (part = 0; part < parts; part++) {\n      if (part !== 0) {\n        hname +='-';\n      }\n      hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);\n    }\n    if (exceptions[hname]) {\n      hname = exceptions[hname];\n    }\n    return hname;\n  },\n\n  sipErrorCause: function(status_code) {\n    var cause;\n\n    for (cause in SIP.C.SIP_ERROR_CAUSES) {\n      if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {\n        return SIP.C.causes[cause];\n      }\n    }\n\n    return SIP.C.causes.SIP_FAILURE_CODE;\n  },\n\n  /**\n  * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n  * @private\n  */\n  getRandomTestNetIP: function() {\n    function getOctet(from,to) {\n      return Math.floor(Math.random()*(to-from+1)+from);\n    }\n    return '192.0.2.' + getOctet(1, 254);\n  },\n\n  getAllowedMethods: function(ua) {\n    var event,\n      allowed = SIP.UA.C.ALLOWED_METHODS.toString();\n\n    for (event in SIP.UA.C.EVENT_METHODS) {\n      if (ua.checkListener(event)) {\n        allowed += ','+ SIP.UA.C.EVENT_METHODS[event];\n      }\n    }\n\n    return allowed;\n  },\n\n  // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info\n  calculateMD5: function(string) {\n    function RotateLeft(lValue, iShiftBits) {\n      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));\n    }\n\n    function AddUnsigned(lX,lY) {\n      var lX4,lY4,lX8,lY8,lResult;\n      lX8 = (lX & 0x80000000);\n      lY8 = (lY & 0x80000000);\n      lX4 = (lX & 0x40000000);\n      lY4 = (lY & 0x40000000);\n      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);\n      if (lX4 & lY4) {\n        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\n      }\n      if (lX4 | lY4) {\n        if (lResult & 0x40000000) {\n          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n        } else {\n          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\n        }\n      } else {\n        return (lResult ^ lX8 ^ lY8);\n      }\n    }\n\n    function F(x,y,z) {\n      return (x & y) | ((~x) & z);\n    }\n\n    function G(x,y,z) {\n      return (x & z) | (y & (~z));\n    }\n\n    function H(x,y,z) {\n      return (x ^ y ^ z);\n    }\n\n    function I(x,y,z) {\n      return (y ^ (x | (~z)));\n    }\n\n    function FF(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    }\n\n    function GG(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    }\n\n    function HH(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    }\n\n    function II(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    }\n\n    function ConvertToWordArray(string) {\n      var lWordCount;\n      var lMessageLength = string.length;\n      var lNumberOfWords_temp1=lMessageLength + 8;\n      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;\n      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;\n      var lWordArray=Array(lNumberOfWords-1);\n      var lBytePosition = 0;\n      var lByteCount = 0;\n      while ( lByteCount < lMessageLength ) {\n        lWordCount = (lByteCount-(lByteCount % 4))/4;\n        lBytePosition = (lByteCount % 4)*8;\n        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));\n        lByteCount++;\n      }\n      lWordCount = (lByteCount-(lByteCount % 4))/4;\n      lBytePosition = (lByteCount % 4)*8;\n      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\n      lWordArray[lNumberOfWords-2] = lMessageLength<<3;\n      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;\n      return lWordArray;\n    }\n\n    function WordToHex(lValue) {\n      var WordToHexValue=\"\",WordToHexValue_temp=\"\",lByte,lCount;\n      for (lCount = 0;lCount<=3;lCount++) {\n        lByte = (lValue>>>(lCount*8)) & 255;\n        WordToHexValue_temp = \"0\" + lByte.toString(16);\n        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);\n      }\n      return WordToHexValue;\n    }\n\n    function Utf8Encode(string) {\n      string = string.replace(/\\r\\n/g,\"\\n\");\n      var utftext = \"\";\n\n      for (var n = 0; n < string.length; n++) {\n        var c = string.charCodeAt(n);\n\n        if (c < 128) {\n          utftext += String.fromCharCode(c);\n        }\n        else if((c > 127) && (c < 2048)) {\n          utftext += String.fromCharCode((c >> 6) | 192);\n          utftext += String.fromCharCode((c & 63) | 128);\n        }\n        else {\n          utftext += String.fromCharCode((c >> 12) | 224);\n          utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n          utftext += String.fromCharCode((c & 63) | 128);\n        }\n      }\n      return utftext;\n    }\n\n    var x=[];\n    var k,AA,BB,CC,DD,a,b,c,d;\n    var S11=7, S12=12, S13=17, S14=22;\n    var S21=5, S22=9 , S23=14, S24=20;\n    var S31=4, S32=11, S33=16, S34=23;\n    var S41=6, S42=10, S43=15, S44=21;\n\n    string = Utf8Encode(string);\n\n    x = ConvertToWordArray(string);\n\n    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;\n\n    for (k=0;k<x.length;k+=16) {\n      AA=a; BB=b; CC=c; DD=d;\n      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);\n      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);\n      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);\n      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);\n      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);\n      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);\n      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);\n      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);\n      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);\n      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);\n      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);\n      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);\n      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);\n      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);\n      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);\n      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);\n      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);\n      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);\n      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);\n      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);\n      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);\n      d=GG(d,a,b,c,x[k+10],S22,0x2441453);\n      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);\n      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);\n      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);\n      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);\n      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);\n      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);\n      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);\n      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);\n      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);\n      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);\n      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);\n      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);\n      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);\n      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);\n      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);\n      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);\n      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);\n      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);\n      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);\n      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);\n      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);\n      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);\n      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);\n      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);\n      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);\n      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);\n      a=II(a,b,c,d,x[k+0], S41,0xF4292244);\n      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);\n      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);\n      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);\n      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);\n      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);\n      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);\n      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);\n      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);\n      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);\n      c=II(c,d,a,b,x[k+6], S43,0xA3014314);\n      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);\n      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);\n      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);\n      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);\n      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);\n      a=AddUnsigned(a,AA);\n      b=AddUnsigned(b,BB);\n      c=AddUnsigned(c,CC);\n      d=AddUnsigned(d,DD);\n    }\n\n    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);\n\n    return temp.toLowerCase();\n  }\n};\n\nSIP.Utils = Utils;\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\nmodule.exports = (function() {\n\nvar Logger = function(logger, category, label) {\n  this.logger = logger;\n  this.category = category;\n  this.label = label;\n};\n\n\nLogger.prototype.debug = function(content) {\n  this.logger.debug(this.category, this.label, content);\n};\n\nLogger.prototype.log = function(content) {\n  this.logger.log(this.category, this.label, content);\n};\n\nLogger.prototype.warn = function(content) {\n  this.logger.warn(this.category, this.label, content);\n};\n\nLogger.prototype.error = function(content) {\n  this.logger.error(this.category, this.label, content);\n};\n\nreturn Logger;\n})();\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\nmodule.exports = function (window, Logger) {\n\n// Console is not defined in ECMAScript, so just in case...\nvar console = window.console || {\n  debug: function () {},\n  log: function () {},\n  warn: function () {},\n  error: function () {}\n};\n\nvar LoggerFactory = function() {\n  var logger,\n    levels = {\n    'error': 0,\n    'warn': 1,\n    'log': 2,\n    'debug': 3\n    },\n\n    level = 2,\n    builtinEnabled = true,\n    connector = null;\n\n    this.loggers = {};\n\n    logger = this.getLogger('sip.loggerfactory');\n\n\n  Object.defineProperties(this, {\n    builtinEnabled: {\n      get: function(){ return builtinEnabled; },\n      set: function(value){\n        if (typeof value === 'boolean') {\n          builtinEnabled = value;\n        } else {\n          logger.error('invalid \"builtinEnabled\" parameter value: '+ JSON.stringify(value));\n        }\n      }\n    },\n\n    level: {\n      get: function() {return level; },\n      set: function(value) {\n        if (value >= 0 && value <=3) {\n          level = value;\n        } else if (value > 3) {\n          level = 3;\n        } else if (levels.hasOwnProperty(value)) {\n          level = levels[value];\n        } else {\n          logger.error('invalid \"level\" parameter value: '+ JSON.stringify(value));\n        }\n      }\n    },\n\n    connector: {\n      get: function() {return connector; },\n      set: function(value){\n        if(value === null || value === \"\" || value === undefined) {\n          connector = null;\n        } else if (typeof value === 'function') {\n          connector = value;\n        } else {\n          logger.error('invalid \"connector\" parameter value: '+ JSON.stringify(value));\n        }\n      }\n    }\n  });\n};\n\nLoggerFactory.prototype.print = function(target, category, label, content) {\n  var prefix = [];\n\n  prefix.push(new Date());\n\n  prefix.push(category);\n\n  if (label) {\n    prefix.push(label);\n  }\n\n  prefix.push('');\n\n  if (typeof content === 'string') {\n    target.call(console, prefix.join(' | ') + content);\n  } else {\n    target.call(console, content);\n  }\n};\n\nLoggerFactory.prototype.debug = function(category, label, content) {\n  if (this.level === 3) {\n    if (this.builtinEnabled) {\n      this.print(console.debug, category, label, content);\n    }\n\n    if (this.connector) {\n      this.connector('debug', category, label, content);\n    }\n  }\n};\n\nLoggerFactory.prototype.log = function(category, label, content) {\n  if (this.level >= 2) {\n    if (this.builtinEnabled) {\n      this.print(console.log, category, label, content);\n    }\n\n    if (this.connector) {\n      this.connector('log', category, label, content);\n    }\n  }\n};\n\nLoggerFactory.prototype.warn = function(category, label, content) {\n  if (this.level >= 1) {\n    if (this.builtinEnabled) {\n      this.print(console.warn, category, label, content);\n    }\n\n    if (this.connector) {\n      this.connector('warn', category, label, content);\n    }\n  }\n};\n\nLoggerFactory.prototype.error = function(category, label, content) {\n  if (this.builtinEnabled) {\n    this.print(console.error,category, label, content);\n  }\n\n  if (this.connector) {\n    this.connector('error', category, label, content);\n  }\n};\n\nLoggerFactory.prototype.getLogger = function(category, label) {\n  var logger;\n\n  if (label && this.level === 3) {\n    return new Logger(this, category, label);\n  } else if (this.loggers[category]) {\n    return this.loggers[category];\n  } else {\n    logger = new Logger(this, category);\n    this.loggers[category] = logger;\n    return logger;\n  }\n};\n\nreturn LoggerFactory;\n};\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview EventEmitter\n */\n\n/**\n * @augments SIP\n * @class Class creating an event emitter.\n */\nmodule.exports = function (SIP) {\nvar\n  EventEmitter,\n  Event,\n  logger = new SIP.LoggerFactory().getLogger('sip.eventemitter'),\n  C = {\n    MAX_LISTENERS: 10\n  };\n\nEventEmitter = function(){};\nEventEmitter.prototype = {\n  /**\n   * Initialize events dictionaries.\n   * @param {Array} events\n   */\n  initEvents: function(events) {\n    this.events = {};\n\n    return this.initMoreEvents(events);\n  },\n\n  initMoreEvents: function(events) {\n    var idx;\n\n    if (!this.logger) {\n      this.logger = logger;\n    }\n\n    this.maxListeners = C.MAX_LISTENERS;\n\n    for (idx = 0; idx < events.length; idx++) {\n      if (!this.events[events[idx]]) {\n        this.logger.log('adding event '+ events[idx]);\n        this.events[events[idx]] = [];\n      } else {\n        this.logger.log('skipping event '+ events[idx]+ ' - Event exists');\n      }\n    }\n\n    return this;\n  },\n\n  /**\n  * Check whether an event exists or not.\n  * @param {String} event\n  * @returns {Boolean}\n  */\n  checkEvent: function(event) {\n    return !!(this.events && this.events[event]);\n  },\n\n  /**\n  * Check whether an event exists and has at least one listener or not.\n  * @param {String} event\n  * @returns {Boolean}\n  */\n  checkListener: function(event) {\n    return this.checkEvent(event) && this.events[event].length > 0;\n  },\n\n  /**\n  * Add a listener to the end of the listeners array for the specified event.\n  * @param {String} event\n  * @param {Function} listener\n  */\n  on: function(event, listener, bindTarget) {\n    if (listener === undefined) {\n      return this;\n    } else if (typeof listener !== 'function') {\n      this.logger.error('listener must be a function');\n      return this;\n    } else if (!this.checkEvent(event)) {\n      this.logger.error('unable to add a listener to a nonexistent event '+ event);\n      throw new TypeError('Invalid or uninitialized event: ' + event);\n    }\n\n    var listenerObj = { listener: listener };\n    if (bindTarget) {\n      listenerObj.bindTarget = bindTarget;\n    }\n\n    if (this.events[event].length >= this.maxListeners) {\n      this.logger.warn('max listeners exceeded for event '+ event);\n      return this;\n    }\n\n    this.events[event].push(listenerObj);\n    this.logger.log('new listener added to event '+ event);\n    return this;\n  },\n\n  /**\n  * Add a one time listener for the specified event.\n  * The listener is invoked only the next time the event is fired, then it is removed.\n  * @param {String} event\n  * @param {Function} listener\n  */\n  once: function(event, listener, bindTarget) {\n    var self = this;\n    function listenOnce () {\n      listener.apply(this, arguments);\n      self.off(event, listenOnce, bindTarget);\n    }\n\n    return this.on(event, listenOnce, bindTarget);\n  },\n\n  /**\n  * Remove a listener from the listener array for the specified event.\n  * Note that the order of the array elements will change after removing the listener\n  * @param {String} event\n  * @param {Function} listener\n  */\n  off: function(event, listener, bindTarget) {\n    var events, length,\n      idx = 0;\n\n    if (listener && typeof listener !== 'function') {\n      this.logger.error('listener must be a function');\n      return this;\n    } else if (!event) {\n      for (idx in this.events) {\n        this.events[idx] = [];\n      }\n      return this;\n    } else if (!this.checkEvent(event)) {\n      this.logger.error('unable to remove a listener from a nonexistent event '+ event);\n      throw new TypeError('Invalid or uninitialized event: ' + event);\n    }\n\n    events = this.events[event];\n    length = events.length;\n\n    while (idx < length) {\n      if (events[idx] &&\n          (!listener || events[idx].listener === listener) &&\n          (!bindTarget || events[idx].bindTarget === bindTarget)) {\n        events.splice(idx,1);\n      } else {\n        idx ++;\n      }\n    }\n\n    return this;\n  },\n\n  /**\n  * By default EventEmitter will print a warning\n  * if more than C.MAX_LISTENERS listeners are added for a particular event.\n  * This function allows that limit to be modified.\n  * @param {Number} listeners\n  */\n  setMaxListeners: function(listeners) {\n    if (typeof listeners !== 'number' || listeners < 0) {\n      this.logger.error('listeners must be a positive number');\n      return this;\n    }\n\n    this.maxListeners = listeners;\n    return this;\n  },\n\n  /**\n  * Execute each of the listeners in order with the supplied arguments.\n  * @param {String} events\n  * @param {Array} args\n  */\n  emit: function(event) {\n    if (!this.checkEvent(event)) {\n      this.logger.error('unable to emit a nonexistent event '+ event);\n      throw new TypeError('Invalid or uninitialized event: ' + event);\n    }\n\n    this.logger.log('emitting event '+ event);\n\n    // Fire event listeners\n    var args = Array.prototype.slice.call(arguments, 1);\n    this.events[event].slice().forEach(function (listener) {\n      try {\n        listener.listener.apply(listener.bindTarget || this, args);\n      } catch(err) {\n        this.logger.error(err.stack);\n      }\n    }, this);\n\n    return this;\n  }\n};\n\nEvent = function(type, sender, data) {\n  this.type = type;\n  this.sender= sender;\n  this.data = data;\n};\n\nEventEmitter.C = C;\n\nSIP.EventEmitter = EventEmitter;\nSIP.Event = Event;\n};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview SIP Constants\n */\n\n/**\n * SIP Constants.\n * @augments SIP\n */\n\nmodule.exports = function (name, version) {\nreturn {\n  USER_AGENT: name +'/'+ version,\n\n  // SIP scheme\n  SIP:  'sip',\n  SIPS: 'sips',\n\n  // End and Failure causes\n  causes: {\n    // Generic error causes\n    CONNECTION_ERROR:         'Connection Error',\n    REQUEST_TIMEOUT:          'Request Timeout',\n    SIP_FAILURE_CODE:         'SIP Failure Code',\n    INTERNAL_ERROR:           'Internal Error',\n\n    // SIP error causes\n    BUSY:                     'Busy',\n    REJECTED:                 'Rejected',\n    REDIRECTED:               'Redirected',\n    UNAVAILABLE:              'Unavailable',\n    NOT_FOUND:                'Not Found',\n    ADDRESS_INCOMPLETE:       'Address Incomplete',\n    INCOMPATIBLE_SDP:         'Incompatible SDP',\n    AUTHENTICATION_ERROR:     'Authentication Error',\n    DIALOG_ERROR:             'Dialog Error',\n\n    // Session error causes\n    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',\n    WEBRTC_ERROR:             'WebRTC Error',\n    CANCELED:                 'Canceled',\n    NO_ANSWER:                'No Answer',\n    EXPIRES:                  'Expires',\n    NO_ACK:                   'No ACK',\n    NO_PRACK:                 'No PRACK',\n    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',\n    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',\n    RTP_TIMEOUT:              'RTP Timeout'\n  },\n\n  supported: {\n    UNSUPPORTED:        'none',\n    SUPPORTED:          'supported',\n    REQUIRED:           'required'\n  },\n\n  SIP_ERROR_CAUSES: {\n    REDIRECTED: [300,301,302,305,380],\n    BUSY: [486,600],\n    REJECTED: [403,603],\n    NOT_FOUND: [404,604],\n    UNAVAILABLE: [480,410,408,430],\n    ADDRESS_INCOMPLETE: [484],\n    INCOMPATIBLE_SDP: [488,606],\n    AUTHENTICATION_ERROR:[401,407]\n  },\n\n  // SIP Methods\n  ACK:        'ACK',\n  BYE:        'BYE',\n  CANCEL:     'CANCEL',\n  INFO:       'INFO',\n  INVITE:     'INVITE',\n  MESSAGE:    'MESSAGE',\n  NOTIFY:     'NOTIFY',\n  OPTIONS:    'OPTIONS',\n  REGISTER:   'REGISTER',\n  UPDATE:     'UPDATE',\n  SUBSCRIBE:  'SUBSCRIBE',\n  REFER:      'REFER',\n  PRACK:      'PRACK',\n\n  /* SIP Response Reasons\n   * DOC: http://www.iana.org/assignments/sip-parameters\n   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7\n   */\n  REASON_PHRASE: {\n    100: 'Trying',\n    180: 'Ringing',\n    181: 'Call Is Being Forwarded',\n    182: 'Queued',\n    183: 'Session Progress',\n    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199\n    200: 'OK',\n    202: 'Accepted',  // RFC 3265\n    204: 'No Notification',  //RFC 5839\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Moved Temporarily',\n    305: 'Use Proxy',\n    380: 'Alternative Service',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    410: 'Gone',\n    412: 'Conditional Request Failed',  // RFC 3903\n    413: 'Request Entity Too Large',\n    414: 'Request-URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Unsupported URI Scheme',\n    417: 'Unknown Resource-Priority',  // RFC 4412\n    420: 'Bad Extension',\n    421: 'Extension Required',\n    422: 'Session Interval Too Small',  // RFC 4028\n    423: 'Interval Too Brief',\n    428: 'Use Identity Header',  // RFC 4474\n    429: 'Provide Referrer Identity',  // RFC 3892\n    430: 'Flow Failed',  // RFC 5626\n    433: 'Anonymity Disallowed',  // RFC 5079\n    436: 'Bad Identity-Info',  // RFC 4474\n    437: 'Unsupported Certificate',  // RFC 4744\n    438: 'Invalid Identity Header',  // RFC 4744\n    439: 'First Hop Lacks Outbound Support',  // RFC 5626\n    440: 'Max-Breadth Exceeded',  // RFC 5393\n    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events\n    470: 'Consent Needed',  // RFC 5360\n    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.\n    480: 'Temporarily Unavailable',\n    481: 'Call/Transaction Does Not Exist',\n    482: 'Loop Detected',\n    483: 'Too Many Hops',\n    484: 'Address Incomplete',\n    485: 'Ambiguous',\n    486: 'Busy Here',\n    487: 'Request Terminated',\n    488: 'Not Acceptable Here',\n    489: 'Bad Event',  // RFC 3265\n    491: 'Request Pending',\n    493: 'Undecipherable',\n    494: 'Security Agreement Required',  // RFC 3329\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Server Time-out',\n    505: 'Version Not Supported',\n    513: 'Message Too Large',\n    580: 'Precondition Failure',  // RFC 3312\n    600: 'Busy Everywhere',\n    603: 'Decline',\n    604: 'Does Not Exist Anywhere',\n    606: 'Not Acceptable'\n  }\n};\n};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview Exceptions\n */\n\n/**\n * SIP Exceptions.\n * @augments SIP\n */\nmodule.exports = {\n  ConfigurationError: (function(){\n    var exception = function(parameter, value) {\n      this.code = 1;\n      this.name = 'CONFIGURATION_ERROR';\n      this.parameter = parameter;\n      this.value = value;\n      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter \"'+ this.parameter +'\"';\n    };\n    exception.prototype = new Error();\n    return exception;\n  }()),\n\n  InvalidStateError: (function(){\n    var exception = function(status) {\n      this.code = 2;\n      this.name = 'INVALID_STATE_ERROR';\n      this.status = status;\n      this.message = 'Invalid status: ' + status;\n    };\n    exception.prototype = new Error();\n    return exception;\n  }()),\n\n  NotSupportedError: (function(){\n    var exception = function(message) {\n      this.code = 3;\n      this.name = 'NOT_SUPPORTED_ERROR';\n      this.message = message;\n    };\n    exception.prototype = new Error();\n    return exception;\n  }()),\n\n  NotReadyError: (function(){\n    var exception = function(message) {\n      this.code = 4;\n      this.name = 'NOT_READY_ERROR';\n      this.message = message;\n    };\n    exception.prototype = new Error();\n    return exception;\n  }())\n};\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview SIP TIMERS\n */\n\n/**\n * @augments SIP\n */\nvar\n  T1 = 500,\n  T2 = 4000,\n  T4 = 5000;\nmodule.exports = function (timers) {\n  var exports = {\n    T1: T1,\n    T2: T2,\n    T4: T4,\n    TIMER_B: 64 * T1,\n    TIMER_D: 0  * T1,\n    TIMER_F: 64 * T1,\n    TIMER_H: 64 * T1,\n    TIMER_I: 0  * T1,\n    TIMER_J: 0  * T1,\n    TIMER_K: 0  * T4,\n    TIMER_L: 64 * T1,\n    TIMER_M: 64 * T1,\n    TIMER_N: 64 * T1,\n    PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1\n  };\n\n  ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']\n  .forEach(function (name) {\n    // can't just use timers[name].bind(timers) since it bypasses jasmine's\n    // clock-mocking\n    exports[name] = function () {\n      return timers[name].apply(timers, arguments);\n    };\n  });\n\n  return exports;\n};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview Transport\n */\n\n/**\n * @augments SIP\n * @class Transport\n * @param {SIP.UA} ua\n * @param {Object} server ws_server Object\n */\nmodule.exports = function (SIP, window) {\nvar Transport,\n  C = {\n    // Transport status codes\n    STATUS_READY:        0,\n    STATUS_DISCONNECTED: 1,\n    STATUS_ERROR:        2\n  };\n\nTransport = function(ua, server) {\n\n  this.logger = ua.getLogger('sip.transport');\n  this.ua = ua;\n  this.ws = null;\n  this.server = server;\n  this.reconnection_attempts = 0;\n  this.closed = false;\n  this.connected = false;\n  this.reconnectTimer = null;\n  this.lastTransportError = {};\n\n  this.ua.transport = this;\n\n  // Connect\n  this.connect();\n};\n\nTransport.prototype = {\n  /**\n   * Send a message.\n   * @param {SIP.OutgoingRequest|String} msg\n   * @returns {Boolean}\n   */\n  send: function(msg) {\n    var message = msg.toString();\n\n    if(this.ws && this.ws.readyState === window.WebSocket.OPEN) {\n      if (this.ua.configuration.traceSip === true) {\n        this.logger.log('sending WebSocket message:\\n\\n' + message + '\\n');\n      }\n      this.ws.send(message);\n      return true;\n    } else {\n      this.logger.warn('unable to send message, WebSocket is not open');\n      return false;\n    }\n  },\n\n  /**\n  * Disconnect socket.\n  */\n  disconnect: function() {\n    if(this.ws) {\n      // Clear reconnectTimer\n      SIP.Timers.clearTimeout(this.reconnectTimer);\n\n      this.closed = true;\n      this.logger.log('closing WebSocket ' + this.server.ws_uri);\n      this.ws.close();\n    }\n\n    if (this.reconnectTimer !== null) {\n      SIP.Timers.clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n      this.ua.emit('disconnected', {\n        transport: this,\n        code: this.lastTransportError.code,\n        reason: this.lastTransportError.reason\n      });\n    }\n  },\n\n  /**\n  * Connect socket.\n  */\n  connect: function() {\n    var transport = this;\n\n    if(this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {\n      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');\n      return false;\n    }\n\n    if(this.ws) {\n      this.ws.close();\n    }\n\n    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);\n    this.ua.onTransportConnecting(this,\n      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);\n\n    try {\n      this.ws = new window.WebSocket(this.server.ws_uri, 'sip');\n    } catch(e) {\n      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);\n    }\n\n    this.ws.binaryType = 'arraybuffer';\n\n    this.ws.onopen = function() {\n      transport.onOpen();\n    };\n\n    this.ws.onclose = function(e) {\n      transport.onClose(e);\n    };\n\n    this.ws.onmessage = function(e) {\n      transport.onMessage(e);\n    };\n\n    this.ws.onerror = function(e) {\n      transport.onError(e);\n    };\n  },\n\n  // Transport Event Handlers\n\n  /**\n  * @event\n  * @param {event} e\n  */\n  onOpen: function() {\n    this.connected = true;\n\n    this.logger.log('WebSocket ' + this.server.ws_uri + ' connected');\n    // Clear reconnectTimer since we are not disconnected\n    if (this.reconnectTimer !== null) {\n      SIP.Timers.clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    // Reset reconnection_attempts\n    this.reconnection_attempts = 0;\n    // Disable closed\n    this.closed = false;\n    // Trigger onTransportConnected callback\n    this.ua.onTransportConnected(this);\n  },\n\n  /**\n  * @event\n  * @param {event} e\n  */\n  onClose: function(e) {\n    var connected_before = this.connected;\n\n    this.connected = false;\n    this.lastTransportError.code = e.code;\n    this.lastTransportError.reason = e.reason;\n    this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');\n\n    if(e.wasClean === false) {\n      this.logger.warn('WebSocket abrupt disconnection');\n    }\n    // Transport was connected\n    if(connected_before === true) {\n      this.ua.onTransportClosed(this);\n      // Check whether the user requested to close.\n      if(!this.closed) {\n        this.reConnect();\n      } else {\n        this.ua.emit('disconnected', {\n          transport: this,\n          code: this.lastTransportError.code,\n          reason: this.lastTransportError.reason\n        });\n      }\n    } else {\n      // This is the first connection attempt\n      //Network error\n      this.ua.onTransportError(this);\n    }\n  },\n\n  /**\n  * @event\n  * @param {event} e\n  */\n  onMessage: function(e) {\n    var message, transaction,\n      data = e.data;\n\n    // CRLF Keep Alive response from server. Ignore it.\n    if(data === '\\r\\n') {\n      if (this.ua.configuration.traceSip === true) {\n        this.logger.log('received WebSocket message with CRLF Keep Alive response');\n      }\n      return;\n    }\n\n    // WebSocket binary message.\n    else if (typeof data !== 'string') {\n      try {\n        data = String.fromCharCode.apply(null, new Uint8Array(data));\n      } catch(evt) {\n        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');\n        return;\n      }\n\n      if (this.ua.configuration.traceSip === true) {\n        this.logger.log('received WebSocket binary message:\\n\\n' + data + '\\n');\n      }\n    }\n\n    // WebSocket text message.\n    else {\n      if (this.ua.configuration.traceSip === true) {\n        this.logger.log('received WebSocket text message:\\n\\n' + data + '\\n');\n      }\n    }\n\n    message = SIP.Parser.parseMessage(data, this.ua);\n\n    if (!message) {\n      return;\n    }\n\n    if(this.ua.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {\n      return;\n    }\n\n    // Do some sanity check\n    if(SIP.sanityCheck(message, this.ua, this)) {\n      if(message instanceof SIP.IncomingRequest) {\n        message.transport = this;\n        this.ua.receiveRequest(message);\n      } else if(message instanceof SIP.IncomingResponse) {\n        /* Unike stated in 18.1.2, if a response does not match\n        * any transaction, it is discarded here and no passed to the core\n        * in order to be discarded there.\n        */\n        switch(message.method) {\n          case SIP.C.INVITE:\n            transaction = this.ua.transactions.ict[message.via_branch];\n            if(transaction) {\n              transaction.receiveResponse(message);\n            }\n            break;\n          case SIP.C.ACK:\n            // Just in case ;-)\n            break;\n          default:\n            transaction = this.ua.transactions.nict[message.via_branch];\n            if(transaction) {\n              transaction.receiveResponse(message);\n            }\n            break;\n        }\n      }\n    }\n  },\n\n  /**\n  * @event\n  * @param {event} e\n  */\n  onError: function(e) {\n    this.logger.warn('WebSocket connection error: ' + e);\n  },\n\n  /**\n  * Reconnection attempt logic.\n  * @private\n  */\n  reConnect: function() {\n    var transport = this;\n\n    this.reconnection_attempts += 1;\n\n    if(this.reconnection_attempts > this.ua.configuration.wsServerMaxReconnection) {\n      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);\n      this.ua.onTransportError(this);\n    } else {\n      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');\n\n      this.reconnectTimer = SIP.Timers.setTimeout(function() {\n        transport.connect();\n        transport.reconnectTimer = null;\n      }, this.ua.configuration.wsServerReconnectionTimeout * 1000);\n    }\n  }\n};\n\nTransport.C = C;\nSIP.Transport = Transport;\n};\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview SIP Message Parser\n */\n\n/**\n * Extract and parse every header of a SIP message.\n * @augments SIP\n * @namespace\n */\nmodule.exports = function (SIP) {\nvar Parser;\n\nfunction getHeader(data, headerStart) {\n  var\n    // 'start' position of the header.\n    start = headerStart,\n    // 'end' position of the header.\n    end = 0,\n    // 'partial end' position of the header.\n    partialEnd = 0;\n\n  //End of message.\n  if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n    return -2;\n  }\n\n  while(end === 0) {\n    // Partial End of Header.\n    partialEnd = data.indexOf('\\r\\n', start);\n\n    // 'indexOf' returns -1 if the value to be found never occurs.\n    if (partialEnd === -1) {\n      return partialEnd;\n    }\n\n    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n      // Not the end of the message. Continue from the next position.\n      start = partialEnd + 2;\n    } else {\n      end = partialEnd;\n    }\n  }\n\n  return end;\n}\n\nfunction parseHeader(message, data, headerStart, headerEnd) {\n  var header, idx, length, parsed,\n    hcolonIndex = data.indexOf(':', headerStart),\n    headerName = data.substring(headerStart, hcolonIndex).trim(),\n    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();\n\n  // If header-field is well-known, parse it.\n  switch(headerName.toLowerCase()) {\n    case 'via':\n    case 'v':\n      message.addHeader('via', headerValue);\n      if(message.getHeaders('via').length === 1) {\n        parsed = message.parseHeader('Via');\n        if(parsed) {\n          message.via = parsed;\n          message.via_branch = parsed.branch;\n        }\n      } else {\n        parsed = 0;\n      }\n      break;\n    case 'from':\n    case 'f':\n      message.setHeader('from', headerValue);\n      parsed = message.parseHeader('from');\n      if(parsed) {\n        message.from = parsed;\n        message.from_tag = parsed.getParam('tag');\n      }\n      break;\n    case 'to':\n    case 't':\n      message.setHeader('to', headerValue);\n      parsed = message.parseHeader('to');\n      if(parsed) {\n        message.to = parsed;\n        message.to_tag = parsed.getParam('tag');\n      }\n      break;\n    case 'record-route':\n      parsed = SIP.Grammar.parse(headerValue, 'Record_Route');\n\n      if (parsed === -1) {\n        parsed = undefined;\n        break;\n      }\n\n      length = parsed.length;\n      for (idx = 0; idx < length; idx++) {\n        header = parsed[idx];\n        message.addHeader('record-route', headerValue.substring(header.position, header.offset));\n        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n      }\n      break;\n    case 'call-id':\n    case 'i':\n      message.setHeader('call-id', headerValue);\n      parsed = message.parseHeader('call-id');\n      if(parsed) {\n        message.call_id = headerValue;\n      }\n      break;\n    case 'contact':\n    case 'm':\n      parsed = SIP.Grammar.parse(headerValue, 'Contact');\n\n      if (parsed === -1) {\n        parsed = undefined;\n        break;\n      }\n\n      length = parsed.length;\n      for (idx = 0; idx < length; idx++) {\n        header = parsed[idx];\n        message.addHeader('contact', headerValue.substring(header.position, header.offset));\n        message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;\n      }\n      break;\n    case 'content-length':\n    case 'l':\n      message.setHeader('content-length', headerValue);\n      parsed = message.parseHeader('content-length');\n      break;\n    case 'content-type':\n    case 'c':\n      message.setHeader('content-type', headerValue);\n      parsed = message.parseHeader('content-type');\n      break;\n    case 'cseq':\n      message.setHeader('cseq', headerValue);\n      parsed = message.parseHeader('cseq');\n      if(parsed) {\n        message.cseq = parsed.value;\n      }\n      if(message instanceof SIP.IncomingResponse) {\n        message.method = parsed.method;\n      }\n      break;\n    case 'max-forwards':\n      message.setHeader('max-forwards', headerValue);\n      parsed = message.parseHeader('max-forwards');\n      break;\n    case 'www-authenticate':\n      message.setHeader('www-authenticate', headerValue);\n      parsed = message.parseHeader('www-authenticate');\n      break;\n    case 'proxy-authenticate':\n      message.setHeader('proxy-authenticate', headerValue);\n      parsed = message.parseHeader('proxy-authenticate');\n      break;\n    case 'refer-to':\n    case 'r':\n      message.setHeader('refer-to', headerValue);\n      parsed = message.parseHeader('refer-to');\n      if (parsed) {\n        message.refer_to = parsed;\n      }\n      break;\n    default:\n      // Do not parse this header.\n      message.setHeader(headerName, headerValue);\n      parsed = 0;\n  }\n\n  if (parsed === undefined) {\n    return {\n      error: 'error parsing header \"'+ headerName +'\"'\n    };\n  } else {\n    return true;\n  }\n}\n\n/** Parse SIP Message\n * @function\n * @param {String} message SIP message.\n * @param {Object} logger object.\n * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}\n */\nParser = {};\nParser.parseMessage = function(data, ua) {\n  var message, firstLine, contentLength, bodyStart, parsed,\n    headerStart = 0,\n    headerEnd = data.indexOf('\\r\\n'),\n    logger = ua.getLogger('sip.parser');\n\n  if(headerEnd === -1) {\n    logger.warn('no CRLF found, not a SIP message, discarded');\n    return;\n  }\n\n  // Parse first line. Check if it is a Request or a Reply.\n  firstLine = data.substring(0, headerEnd);\n  parsed = SIP.Grammar.parse(firstLine, 'Request_Response');\n\n  if(parsed === -1) {\n    logger.warn('error parsing first line of SIP message: \"' + firstLine + '\"');\n    return;\n  } else if(!parsed.status_code) {\n    message = new SIP.IncomingRequest(ua);\n    message.method = parsed.method;\n    message.ruri = parsed.uri;\n  } else {\n    message = new SIP.IncomingResponse(ua);\n    message.status_code = parsed.status_code;\n    message.reason_phrase = parsed.reason_phrase;\n  }\n\n  message.data = data;\n  headerStart = headerEnd + 2;\n\n  /* Loop over every line in data. Detect the end of each header and parse\n  * it or simply add to the headers collection.\n  */\n  while(true) {\n    headerEnd = getHeader(data, headerStart);\n\n    // The SIP message has normally finished.\n    if(headerEnd === -2) {\n      bodyStart = headerStart + 2;\n      break;\n    }\n    // data.indexOf returned -1 due to a malformed message.\n    else if(headerEnd === -1) {\n      logger.error('malformed message');\n      return;\n    }\n\n    parsed = parseHeader(message, data, headerStart, headerEnd);\n\n    if(parsed !== true) {\n      logger.error(parsed.error);\n      return;\n    }\n\n    headerStart = headerEnd + 2;\n  }\n\n  /* RFC3261 18.3.\n   * If there are additional bytes in the transport packet\n   * beyond the end of the body, they MUST be discarded.\n   */\n  if(message.hasHeader('content-length')) {\n    contentLength = message.getHeader('content-length');\n    message.body = data.substr(bodyStart, contentLength);\n  } else {\n    message.body = data.substring(bodyStart);\n  }\n\n  return message;\n};\n\nSIP.Parser = Parser;\n};\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview SIP Message\n */\n\nmodule.exports = function (SIP) {\nvar\n  OutgoingRequest,\n  IncomingMessage,\n  IncomingRequest,\n  IncomingResponse;\n\n/**\n * @augments SIP\n * @class Class for outgoing SIP request.\n * @param {String} method request method\n * @param {String} ruri request uri\n * @param {SIP.UA} ua\n * @param {Object} params parameters that will have priority over ua.configuration parameters:\n * <br>\n *  - cseq, call_id, from_tag, from_uri, from_displayName, to_uri, to_tag, route_set\n * @param {Object} [headers] extra headers\n * @param {String} [body]\n */\nOutgoingRequest = function(method, ruri, ua, params, extraHeaders, body) {\n  var\n    to,\n    from,\n    call_id,\n    cseq;\n\n  params = params || {};\n\n  // Mandatory parameters check\n  if(!method || !ruri || !ua) {\n    return null;\n  }\n\n  this.logger = ua.getLogger('sip.sipmessage');\n  this.ua = ua;\n  this.headers = {};\n  this.method = method;\n  this.ruri = ruri;\n  this.body = body;\n  this.extraHeaders = (extraHeaders || []).slice();\n  this.statusCode = params.status_code;\n  this.reasonPhrase = params.reason_phrase;\n\n  // Fill the Common SIP Request Headers\n\n  // Route\n  if (params.route_set) {\n    this.setHeader('route', params.route_set);\n  } else if (ua.configuration.usePreloadedRoute){\n    this.setHeader('route', ua.transport.server.sip_uri);\n  }\n\n  // Via\n  // Empty Via header. Will be filled by the client transaction.\n  this.setHeader('via', '');\n\n  // Max-Forwards\n  this.setHeader('max-forwards', SIP.UA.C.MAX_FORWARDS);\n\n  // To\n  to = (params.to_displayName || params.to_displayName === 0) ? '\"' + params.to_displayName + '\" ' : '';\n  to += '<' + (params.to_uri || ruri) + '>';\n  to += params.to_tag ? ';tag=' + params.to_tag : '';\n  this.to = new SIP.NameAddrHeader.parse(to);\n  this.setHeader('to', to);\n\n  // From\n  if (params.from_displayName || params.from_displayName === 0) {\n    from = '\"' + params.from_displayName + '\" ';\n  } else if (ua.configuration.displayName) {\n    from = '\"' + ua.configuration.displayName + '\" ';\n  } else {\n    from = '';\n  }\n  from += '<' + (params.from_uri || ua.configuration.uri) + '>;tag=';\n  from += params.from_tag || SIP.Utils.newTag();\n  this.from = new SIP.NameAddrHeader.parse(from);\n  this.setHeader('from', from);\n\n  // Call-ID\n  call_id = params.call_id || (ua.configuration.sipjsId + SIP.Utils.createRandomToken(15));\n  this.call_id = call_id;\n  this.setHeader('call-id', call_id);\n\n  // CSeq\n  cseq = params.cseq || Math.floor(Math.random() * 10000);\n  this.cseq = cseq;\n  this.setHeader('cseq', cseq + ' ' + method);\n};\n\nOutgoingRequest.prototype = {\n  /**\n   * Replace the the given header by the given value.\n   * @param {String} name header name\n   * @param {String | Array} value header value\n   */\n  setHeader: function(name, value) {\n    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n  },\n\n  /**\n   * Get the value of the given header name at the given position.\n   * @param {String} name header name\n   * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.\n   */\n  getHeader: function(name) {\n    var regexp, idx,\n      length = this.extraHeaders.length,\n      header = this.headers[SIP.Utils.headerize(name)];\n\n    if(header) {\n      if(header[0]) {\n        return header[0];\n      }\n    } else {\n      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n      for (idx = 0; idx < length; idx++) {\n        header = this.extraHeaders[idx];\n        if (regexp.test(header)) {\n          return header.substring(header.indexOf(':')+1).trim();\n        }\n      }\n    }\n\n    return;\n  },\n\n  /**\n   * Get the header/s of the given name.\n   * @param {String} name header name\n   * @returns {Array} Array with all the headers of the specified name.\n   */\n  getHeaders: function(name) {\n    var idx, length, regexp,\n      header = this.headers[SIP.Utils.headerize(name)],\n      result = [];\n\n    if(header) {\n      length = header.length;\n      for (idx = 0; idx < length; idx++) {\n        result.push(header[idx]);\n      }\n      return result;\n    } else {\n      length = this.extraHeaders.length;\n      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n      for (idx = 0; idx < length; idx++) {\n        header = this.extraHeaders[idx];\n        if (regexp.test(header)) {\n          result.push(header.substring(header.indexOf(':')+1).trim());\n        }\n      }\n      return result;\n    }\n  },\n\n  /**\n   * Verify the existence of the given header.\n   * @param {String} name header name\n   * @returns {boolean} true if header with given name exists, false otherwise\n   */\n  hasHeader: function(name) {\n    var regexp, idx,\n      length = this.extraHeaders.length;\n\n    if (this.headers[SIP.Utils.headerize(name)]) {\n      return true;\n    } else {\n      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n      for (idx = 0; idx < length; idx++) {\n        if (regexp.test(this.extraHeaders[idx])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  },\n\n  toString: function() {\n    var msg = '', header, length, idx, supported = [];\n\n    msg += this.method + ' ' + this.ruri + ' SIP/2.0\\r\\n';\n\n    for (header in this.headers) {\n      length = this.headers[header].length;\n      for (idx = 0; idx < length; idx++) {\n        msg += header + ': ' + this.headers[header][idx] + '\\r\\n';\n      }\n    }\n\n    length = this.extraHeaders.length;\n    for (idx = 0; idx < length; idx++) {\n      msg += this.extraHeaders[idx].trim() +'\\r\\n';\n    }\n\n    //Supported\n    if (this.method === SIP.C.REGISTER) {\n      supported.push('path', 'gruu');\n    } else if (this.method === SIP.C.INVITE &&\n               (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu)) {\n      supported.push('gruu');\n    }\n\n    if (this.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {\n      supported.push('100rel');\n    }\n\n    supported.push('outbound');\n\n    msg += 'Supported: ' +  supported +'\\r\\n';\n    msg += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n\n    if(this.body) {\n      length = SIP.Utils.str_utf8_length(this.body);\n      msg += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n      msg += this.body;\n    } else {\n      msg += 'Content-Length: 0\\r\\n\\r\\n';\n    }\n\n    return msg;\n  }\n};\n\n/**\n * @augments SIP\n * @class Class for incoming SIP message.\n */\nIncomingMessage = function(){\n  this.data = null;\n  this.headers = null;\n  this.method =  null;\n  this.via = null;\n  this.via_branch = null;\n  this.call_id = null;\n  this.cseq = null;\n  this.from = null;\n  this.from_tag = null;\n  this.to = null;\n  this.to_tag = null;\n  this.body = null;\n};\n\nIncomingMessage.prototype = {\n  /**\n  * Insert a header of the given name and value into the last position of the\n  * header array.\n  * @param {String} name header name\n  * @param {String} value header value\n  */\n  addHeader: function(name, value) {\n    var header = { raw: value };\n\n    name = SIP.Utils.headerize(name);\n\n    if(this.headers[name]) {\n      this.headers[name].push(header);\n    } else {\n      this.headers[name] = [header];\n    }\n  },\n\n  /**\n   * Get the value of the given header name at the given position.\n   * @param {String} name header name\n   * @returns {String|undefined} Returns the specified header, null if header doesn't exist.\n   */\n  getHeader: function(name) {\n    var header = this.headers[SIP.Utils.headerize(name)];\n\n    if(header) {\n      if(header[0]) {\n        return header[0].raw;\n      }\n    } else {\n      return;\n    }\n  },\n\n  /**\n   * Get the header/s of the given name.\n   * @param {String} name header name\n   * @returns {Array} Array with all the headers of the specified name.\n   */\n  getHeaders: function(name) {\n    var idx, length,\n      header = this.headers[SIP.Utils.headerize(name)],\n      result = [];\n\n    if(!header) {\n      return [];\n    }\n\n    length = header.length;\n    for (idx = 0; idx < length; idx++) {\n      result.push(header[idx].raw);\n    }\n\n    return result;\n  },\n\n  /**\n   * Verify the existence of the given header.\n   * @param {String} name header name\n   * @returns {boolean} true if header with given name exists, false otherwise\n   */\n  hasHeader: function(name) {\n    return(this.headers[SIP.Utils.headerize(name)]) ? true : false;\n  },\n\n  /**\n  * Parse the given header on the given index.\n  * @param {String} name header name\n  * @param {Number} [idx=0] header index\n  * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n  */\n  parseHeader: function(name, idx) {\n    var header, value, parsed;\n\n    name = SIP.Utils.headerize(name);\n\n    idx = idx || 0;\n\n    if(!this.headers[name]) {\n      this.logger.log('header \"' + name + '\" not present');\n      return;\n    } else if(idx >= this.headers[name].length) {\n      this.logger.log('not so many \"' + name + '\" headers present');\n      return;\n    }\n\n    header = this.headers[name][idx];\n    value = header.raw;\n\n    if(header.parsed) {\n      return header.parsed;\n    }\n\n    //substitute '-' by '_' for grammar rule matching.\n    parsed = SIP.Grammar.parse(value, name.replace(/-/g, '_'));\n\n    if(parsed === -1) {\n      this.headers[name].splice(idx, 1); //delete from headers\n      this.logger.warn('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n      return;\n    } else {\n      header.parsed = parsed;\n      return parsed;\n    }\n  },\n\n  /**\n   * Message Header attribute selector. Alias of parseHeader.\n   * @param {String} name header name\n   * @param {Number} [idx=0] header index\n   * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n   *\n   * @example\n   * message.s('via',3).port\n   */\n  s: function(name, idx) {\n    return this.parseHeader(name, idx);\n  },\n\n  /**\n  * Replace the value of the given header by the value.\n  * @param {String} name header name\n  * @param {String} value header value\n  */\n  setHeader: function(name, value) {\n    var header = { raw: value };\n    this.headers[SIP.Utils.headerize(name)] = [header];\n  },\n\n  toString: function() {\n    return this.data;\n  }\n};\n\n/**\n * @augments IncomingMessage\n * @class Class for incoming SIP request.\n */\nIncomingRequest = function(ua) {\n  this.logger = ua.getLogger('sip.sipmessage');\n  this.ua = ua;\n  this.headers = {};\n  this.ruri = null;\n  this.transport = null;\n  this.server_transaction = null;\n};\nIncomingRequest.prototype = new IncomingMessage();\n\n/**\n* Stateful reply.\n* @param {Number} code status code\n* @param {String} reason reason phrase\n* @param {Object} headers extra headers\n* @param {String} body body\n* @param {Function} [onSuccess] onSuccess callback\n* @param {Function} [onFailure] onFailure callback\n*/\nIncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {\n  var rr, vias, length, idx, response,\n  supported = [],\n    to = this.getHeader('To'),\n    r = 0,\n    v = 0;\n\n  code = code || null;\n  reason = reason || null;\n\n  // Validate code and reason values\n  if (!code || (code < 100 || code > 699)) {\n    throw new TypeError('Invalid status_code: '+ code);\n  } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n    throw new TypeError('Invalid reason_phrase: '+ reason);\n  }\n\n  reason = reason || SIP.C.REASON_PHRASE[code] || '';\n  extraHeaders = (extraHeaders || []).slice();\n\n  response = 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n\n  if(this.method === SIP.C.INVITE && code > 100 && code <= 200) {\n    rr = this.getHeaders('record-route');\n    length = rr.length;\n\n    for(r; r < length; r++) {\n      response += 'Record-Route: ' + rr[r] + '\\r\\n';\n    }\n  }\n\n  vias = this.getHeaders('via');\n  length = vias.length;\n\n  for(v; v < length; v++) {\n    response += 'Via: ' + vias[v] + '\\r\\n';\n  }\n\n  if(!this.to_tag && code > 100) {\n    to += ';tag=' + SIP.Utils.newTag();\n  } else if(this.to_tag && !this.s('to').hasParam('tag')) {\n    to += ';tag=' + this.to_tag;\n  }\n\n  response += 'To: ' + to + '\\r\\n';\n  response += 'From: ' + this.getHeader('From') + '\\r\\n';\n  response += 'Call-ID: ' + this.call_id + '\\r\\n';\n  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n\n  length = extraHeaders.length;\n  for (idx = 0; idx < length; idx++) {\n    response += extraHeaders[idx].trim() +'\\r\\n';\n  }\n\n  //Supported\n  if (this.method === SIP.C.INVITE &&\n               (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu)) {\n    supported.push('gruu');\n  }\n\n  if (this.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {\n    supported.push('100rel');\n  }\n\n  supported.push('outbound');\n\n  response += 'Supported: ' + supported + '\\r\\n';\n\n  if(body) {\n    length = SIP.Utils.str_utf8_length(body);\n    response += 'Content-Type: application/sdp\\r\\n';\n    response += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n    response += body;\n  } else {\n    response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n  }\n\n  this.server_transaction.receiveResponse(code, response, onSuccess, onFailure);\n\n  return response;\n};\n\n/**\n* Stateless reply.\n* @param {Number} code status code\n* @param {String} reason reason phrase\n*/\nIncomingRequest.prototype.reply_sl = function(code, reason) {\n  var to, response,\n    v = 0,\n    vias = this.getHeaders('via'),\n    length = vias.length;\n\n  code = code || null;\n  reason = reason || null;\n\n  // Validate code and reason values\n  if (!code || (code < 100 || code > 699)) {\n    throw new TypeError('Invalid status_code: '+ code);\n  } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n    throw new TypeError('Invalid reason_phrase: '+ reason);\n  }\n\n  reason = reason || SIP.C.REASON_PHRASE[code] || '';\n\n  response = 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n\n  for(v; v < length; v++) {\n    response += 'Via: ' + vias[v] + '\\r\\n';\n  }\n\n  to = this.getHeader('To');\n\n  if(!this.to_tag && code > 100) {\n    to += ';tag=' + SIP.Utils.newTag();\n  } else if(this.to_tag && !this.s('to').hasParam('tag')) {\n    to += ';tag=' + this.to_tag;\n  }\n\n  response += 'To: ' + to + '\\r\\n';\n  response += 'From: ' + this.getHeader('From') + '\\r\\n';\n  response += 'Call-ID: ' + this.call_id + '\\r\\n';\n  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n  response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n\n  this.transport.send(response);\n};\n\n\n/**\n * @augments IncomingMessage\n * @class Class for incoming SIP response.\n */\nIncomingResponse = function(ua) {\n  this.logger = ua.getLogger('sip.sipmessage');\n  this.headers = {};\n  this.status_code = null;\n  this.reason_phrase = null;\n};\nIncomingResponse.prototype = new IncomingMessage();\n\nSIP.OutgoingRequest = OutgoingRequest;\nSIP.IncomingRequest = IncomingRequest;\nSIP.IncomingResponse = IncomingResponse;\n};\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview SIP URI\n */\n\n/**\n * @augments SIP\n * @class Class creating a SIP URI.\n *\n * @param {String} [scheme]\n * @param {String} [user]\n * @param {String} host\n * @param {String} [port]\n * @param {Object} [parameters]\n * @param {Object} [headers]\n *\n */\nmodule.exports = function (SIP) {\nvar URI;\n\nURI = function(scheme, user, host, port, parameters, headers) {\n  var param, header;\n\n  // Checks\n  if(!host) {\n    throw new TypeError('missing or invalid \"host\" parameter');\n  }\n\n  // Initialize parameters\n  scheme = scheme || SIP.C.SIP;\n  this.parameters = {};\n  this.headers = {};\n\n  for (param in parameters) {\n    this.setParam(param, parameters[param]);\n  }\n\n  for (header in headers) {\n    this.setHeader(header, headers[header]);\n  }\n\n  Object.defineProperties(this, {\n    scheme: {\n      get: function(){ return scheme; },\n      set: function(value){\n        scheme = value.toLowerCase();\n      }\n    },\n\n    user: {\n      get: function(){ return user; },\n      set: function(value){\n        user = value;\n      }\n    },\n\n    host: {\n      get: function(){ return host; },\n      set: function(value){\n        host = value.toLowerCase();\n      }\n    },\n\n    port: {\n      get: function(){ return port; },\n      set: function(value){\n        port = value === 0 ? value : (parseInt(value,10) || null);\n      }\n    }\n  });\n};\nURI.prototype = {\n  setParam: function(key, value) {\n    if(key) {\n      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();\n    }\n  },\n\n  getParam: function(key) {\n    if(key) {\n      return this.parameters[key.toLowerCase()];\n    }\n  },\n\n  hasParam: function(key) {\n    if(key) {\n      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;\n    }\n  },\n\n  deleteParam: function(parameter) {\n    var value;\n    parameter = parameter.toLowerCase();\n    if (this.parameters.hasOwnProperty(parameter)) {\n      value = this.parameters[parameter];\n      delete this.parameters[parameter];\n      return value;\n    }\n  },\n\n  clearParams: function() {\n    this.parameters = {};\n  },\n\n  setHeader: function(name, value) {\n    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n  },\n\n  getHeader: function(name) {\n    if(name) {\n      return this.headers[SIP.Utils.headerize(name)];\n    }\n  },\n\n  hasHeader: function(name) {\n    if(name) {\n      return (this.headers.hasOwnProperty(SIP.Utils.headerize(name)) && true) || false;\n    }\n  },\n\n  deleteHeader: function(header) {\n    var value;\n    header = SIP.Utils.headerize(header);\n    if(this.headers.hasOwnProperty(header)) {\n      value = this.headers[header];\n      delete this.headers[header];\n      return value;\n    }\n  },\n\n  clearHeaders: function() {\n    this.headers = {};\n  },\n\n  clone: function() {\n    return new URI(\n      this.scheme,\n      this.user,\n      this.host,\n      this.port,\n      JSON.parse(JSON.stringify(this.parameters)),\n      JSON.parse(JSON.stringify(this.headers)));\n  },\n\n  toString: function(){\n    var header, parameter, idx, uri,\n      headers = [];\n\n    uri  = this.scheme + ':';\n    // add slashes if it's not a sip(s) URI\n    if (!this.scheme.match(\"^sips?$\")) {\n      uri += \"//\";\n    }\n    if (this.user) {\n      uri += SIP.Utils.escapeUser(this.user) + '@';\n    }\n    uri += this.host;\n    if (this.port || this.port === 0) {\n      uri += ':' + this.port;\n    }\n\n    for (parameter in this.parameters) {\n      uri += ';' + parameter;\n\n      if (this.parameters[parameter] !== null) {\n        uri += '='+ this.parameters[parameter];\n      }\n    }\n\n    for(header in this.headers) {\n      for(idx in this.headers[header]) {\n        headers.push(header + '=' + this.headers[header][idx]);\n      }\n    }\n\n    if (headers.length > 0) {\n      uri += '?' + headers.join('&');\n    }\n\n    return uri;\n  }\n};\n\n\n/**\n  * Parse the given string and returns a SIP.URI instance or undefined if\n  * it is an invalid URI.\n  * @public\n  * @param {String} uri\n  */\nURI.parse = function(uri) {\n  uri = SIP.Grammar.parse(uri,'SIP_URI');\n\n  if (uri !== -1) {\n    return uri;\n  } else {\n    return undefined;\n  }\n};\n\nSIP.URI = URI;\n};\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview SIP NameAddrHeader\n */\n\n/**\n * @augments SIP\n * @class Class creating a Name Address SIP header.\n *\n * @param {SIP.URI} uri\n * @param {String} [displayName]\n * @param {Object} [parameters]\n *\n */\nmodule.exports = function (SIP) {\nvar NameAddrHeader;\n\nNameAddrHeader = function(uri, displayName, parameters) {\n  var param;\n\n  // Checks\n  if(!uri || !(uri instanceof SIP.URI)) {\n    throw new TypeError('missing or invalid \"uri\" parameter');\n  }\n\n  // Initialize parameters\n  this.uri = uri;\n  this.parameters = {};\n\n  for (param in parameters) {\n    this.setParam(param, parameters[param]);\n  }\n\n  Object.defineProperties(this, {\n    displayName: {\n      get: function() { return displayName; },\n      set: function(value) {\n        displayName = (value === 0) ? '0' : value;\n      }\n    }\n  });\n};\nNameAddrHeader.prototype = {\n  setParam: function (key, value) {\n    if(key) {\n      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();\n    }\n  },\n  getParam: SIP.URI.prototype.getParam,\n  hasParam: SIP.URI.prototype.hasParam,\n  deleteParam: SIP.URI.prototype.deleteParam,\n  clearParams: SIP.URI.prototype.clearParams,\n\n  clone: function() {\n    return new NameAddrHeader(\n      this.uri.clone(),\n      this.displayName,\n      JSON.parse(JSON.stringify(this.parameters)));\n  },\n\n  toString: function() {\n    var body, parameter;\n\n    body  = (this.displayName || this.displayName === 0) ? '\"' + this.displayName + '\" ' : '';\n    body += '<' + this.uri.toString() + '>';\n\n    for (parameter in this.parameters) {\n      body += ';' + parameter;\n\n      if (this.parameters[parameter] !== null) {\n        body += '='+ this.parameters[parameter];\n      }\n    }\n\n    return body;\n  }\n};\n\n\n/**\n  * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if\n  * it is an invalid NameAddrHeader.\n  * @public\n  * @param {String} name_addr_header\n  */\nNameAddrHeader.parse = function(name_addr_header) {\n  name_addr_header = SIP.Grammar.parse(name_addr_header,'Name_Addr_Header');\n\n  if (name_addr_header !== -1) {\n    return name_addr_header;\n  } else {\n    return undefined;\n  }\n};\n\nSIP.NameAddrHeader = NameAddrHeader;\n};\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview SIP Transactions\n */\n\n/**\n * SIP Transactions module.\n * @augments SIP\n */\nmodule.exports = function (SIP) {\nvar\n  C = {\n    // Transaction states\n    STATUS_TRYING:     1,\n    STATUS_PROCEEDING: 2,\n    STATUS_CALLING:    3,\n    STATUS_ACCEPTED:   4,\n    STATUS_COMPLETED:  5,\n    STATUS_TERMINATED: 6,\n    STATUS_CONFIRMED:  7,\n\n    // Transaction types\n    NON_INVITE_CLIENT: 'nict',\n    NON_INVITE_SERVER: 'nist',\n    INVITE_CLIENT: 'ict',\n    INVITE_SERVER: 'ist'\n  };\n\n/**\n* @augments SIP.Transactions\n* @class Non Invite Client Transaction\n* @param {SIP.RequestSender} request_sender\n* @param {SIP.OutgoingRequest} request\n* @param {SIP.Transport} transport\n*/\nvar NonInviteClientTransaction = function(request_sender, request, transport) {\n  var via,\n    events = ['stateChanged'];\n\n  this.type = C.NON_INVITE_CLIENT;\n  this.transport = transport;\n  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n  this.request_sender = request_sender;\n  this.request = request;\n\n  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n\n  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);\n  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + this.id;\n\n  this.request.setHeader('via', via);\n\n  this.request_sender.ua.newTransaction(this);\n\n  this.initEvents(events);\n};\nNonInviteClientTransaction.prototype = new SIP.EventEmitter();\n\nNonInviteClientTransaction.prototype.stateChanged = function(state) {\n  this.state = state;\n  this.emit('stateChanged');\n};\n\nNonInviteClientTransaction.prototype.send = function() {\n  var tr = this;\n\n  this.stateChanged(C.STATUS_TRYING);\n  this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);\n\n  if(!this.transport.send(this.request)) {\n    this.onTransportError();\n  }\n};\n\nNonInviteClientTransaction.prototype.onTransportError = function() {\n  this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);\n  SIP.Timers.clearTimeout(this.F);\n  SIP.Timers.clearTimeout(this.K);\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.request_sender.ua.destroyTransaction(this);\n  this.request_sender.onTransportError();\n};\n\nNonInviteClientTransaction.prototype.timer_F = function() {\n  this.logger.log('Timer F expired for non-INVITE client transaction ' + this.id);\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.request_sender.ua.destroyTransaction(this);\n  this.request_sender.onRequestTimeout();\n};\n\nNonInviteClientTransaction.prototype.timer_K = function() {\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.request_sender.ua.destroyTransaction(this);\n};\n\nNonInviteClientTransaction.prototype.receiveResponse = function(response) {\n  var\n    tr = this,\n    status_code = response.status_code;\n\n  if(status_code < 200) {\n    switch(this.state) {\n      case C.STATUS_TRYING:\n      case C.STATUS_PROCEEDING:\n        this.stateChanged(C.STATUS_PROCEEDING);\n        this.request_sender.receiveResponse(response);\n        break;\n    }\n  } else {\n    switch(this.state) {\n      case C.STATUS_TRYING:\n      case C.STATUS_PROCEEDING:\n        this.stateChanged(C.STATUS_COMPLETED);\n        SIP.Timers.clearTimeout(this.F);\n\n        if(status_code === 408) {\n          this.request_sender.onRequestTimeout();\n        } else {\n          this.request_sender.receiveResponse(response);\n        }\n\n        this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);\n        break;\n      case C.STATUS_COMPLETED:\n        break;\n    }\n  }\n};\n\n\n\n/**\n* @augments SIP.Transactions\n* @class Invite Client Transaction\n* @param {SIP.RequestSender} request_sender\n* @param {SIP.OutgoingRequest} request\n* @param {SIP.Transport} transport\n*/\nvar InviteClientTransaction = function(request_sender, request, transport) {\n  var via,\n    tr = this,\n    events = ['stateChanged'];\n\n  this.type = C.INVITE_CLIENT;\n  this.transport = transport;\n  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n  this.request_sender = request_sender;\n  this.request = request;\n\n  this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);\n\n  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);\n  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + this.id;\n\n  this.request.setHeader('via', via);\n\n  this.request_sender.ua.newTransaction(this);\n\n  // Add the cancel property to the request.\n  //Will be called from the request instance, not the transaction itself.\n  this.request.cancel = function(reason) {\n    tr.cancel_request(tr, reason);\n  };\n\n  this.initEvents(events);\n};\nInviteClientTransaction.prototype = new SIP.EventEmitter();\n\nInviteClientTransaction.prototype.stateChanged = function(state) {\n  this.state = state;\n  this.emit('stateChanged');\n};\n\nInviteClientTransaction.prototype.send = function() {\n  var tr = this;\n  this.stateChanged(C.STATUS_CALLING);\n  this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);\n\n  if(!this.transport.send(this.request)) {\n    this.onTransportError();\n  }\n};\n\nInviteClientTransaction.prototype.onTransportError = function() {\n  this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);\n  SIP.Timers.clearTimeout(this.B);\n  SIP.Timers.clearTimeout(this.D);\n  SIP.Timers.clearTimeout(this.M);\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.request_sender.ua.destroyTransaction(this);\n\n  if (this.state !== C.STATUS_ACCEPTED) {\n    this.request_sender.onTransportError();\n  }\n};\n\n// RFC 6026 7.2\nInviteClientTransaction.prototype.timer_M = function() {\n  this.logger.log('Timer M expired for INVITE client transaction ' + this.id);\n\n  if(this.state === C.STATUS_ACCEPTED) {\n    SIP.Timers.clearTimeout(this.B);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.request_sender.ua.destroyTransaction(this);\n  }\n};\n\n// RFC 3261 17.1.1\nInviteClientTransaction.prototype.timer_B = function() {\n  this.logger.log('Timer B expired for INVITE client transaction ' + this.id);\n  if(this.state === C.STATUS_CALLING) {\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.request_sender.ua.destroyTransaction(this);\n    this.request_sender.onRequestTimeout();\n  }\n};\n\nInviteClientTransaction.prototype.timer_D = function() {\n  this.logger.log('Timer D expired for INVITE client transaction ' + this.id);\n  SIP.Timers.clearTimeout(this.B);\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.request_sender.ua.destroyTransaction(this);\n};\n\nInviteClientTransaction.prototype.sendACK = function(response) {\n  var tr = this;\n\n  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\\r\\n';\n  this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\\r\\n';\n\n  if(this.request.headers['Route']) {\n    this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\\r\\n';\n  }\n\n  this.ack += 'To: ' + response.getHeader('to') + '\\r\\n';\n  this.ack += 'From: ' + this.request.headers['From'].toString() + '\\r\\n';\n  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\\r\\n';\n  this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];\n  this.ack += ' ACK\\r\\n\\r\\n';\n\n  this.D = SIP.Timers.setTimeout(tr.timer_D.bind(tr), SIP.Timers.TIMER_D);\n\n  this.transport.send(this.ack);\n};\n\nInviteClientTransaction.prototype.cancel_request = function(tr, reason) {\n  var request = tr.request;\n\n  this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\\r\\n';\n  this.cancel += 'Via: ' + request.headers['Via'].toString() + '\\r\\n';\n\n  if(this.request.headers['Route']) {\n    this.cancel += 'Route: ' + request.headers['Route'].toString() + '\\r\\n';\n  }\n\n  this.cancel += 'To: ' + request.headers['To'].toString() + '\\r\\n';\n  this.cancel += 'From: ' + request.headers['From'].toString() + '\\r\\n';\n  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\\r\\n';\n  this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +\n  ' CANCEL\\r\\n';\n\n  if(reason) {\n    this.cancel += 'Reason: ' + reason + '\\r\\n';\n  }\n\n  this.cancel += 'Content-Length: 0\\r\\n\\r\\n';\n\n  // Send only if a provisional response (>100) has been received.\n  if(this.state === C.STATUS_PROCEEDING) {\n    this.transport.send(this.cancel);\n  }\n};\n\nInviteClientTransaction.prototype.receiveResponse = function(response) {\n  var\n  tr = this,\n  status_code = response.status_code;\n\n  if(status_code >= 100 && status_code <= 199) {\n    switch(this.state) {\n      case C.STATUS_CALLING:\n        this.stateChanged(C.STATUS_PROCEEDING);\n        this.request_sender.receiveResponse(response);\n        if(this.cancel) {\n          this.transport.send(this.cancel);\n        }\n        break;\n      case C.STATUS_PROCEEDING:\n        this.request_sender.receiveResponse(response);\n        break;\n    }\n  } else if(status_code >= 200 && status_code <= 299) {\n    switch(this.state) {\n      case C.STATUS_CALLING:\n      case C.STATUS_PROCEEDING:\n        this.stateChanged(C.STATUS_ACCEPTED);\n        this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);\n        this.request_sender.receiveResponse(response);\n        break;\n      case C.STATUS_ACCEPTED:\n        this.request_sender.receiveResponse(response);\n        break;\n    }\n  } else if(status_code >= 300 && status_code <= 699) {\n    switch(this.state) {\n      case C.STATUS_CALLING:\n      case C.STATUS_PROCEEDING:\n        this.stateChanged(C.STATUS_COMPLETED);\n        this.sendACK(response);\n        this.request_sender.receiveResponse(response);\n        break;\n      case C.STATUS_COMPLETED:\n        this.sendACK(response);\n        break;\n    }\n  }\n};\n\n\n/**\n * @augments SIP.Transactions\n * @class ACK Client Transaction\n * @param {SIP.RequestSender} request_sender\n * @param {SIP.OutgoingRequest} request\n * @param {SIP.Transport} transport\n */\nvar AckClientTransaction = function(request_sender, request, transport) {\n  var via;\n\n  this.transport = transport;\n  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n  this.request_sender = request_sender;\n  this.request = request;\n\n  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n\n  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);\n  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + this.id;\n\n  this.request.setHeader('via', via);\n};\nAckClientTransaction.prototype = new SIP.EventEmitter();\n\nAckClientTransaction.prototype.send = function() {\n  if(!this.transport.send(this.request)) {\n    this.onTransportError();\n  }\n};\n\nAckClientTransaction.prototype.onTransportError = function() {\n  this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);\n  this.request_sender.onTransportError();\n};\n\n\n/**\n* @augments SIP.Transactions\n* @class Non Invite Server Transaction\n* @param {SIP.IncomingRequest} request\n* @param {SIP.UA} ua\n*/\nvar NonInviteServerTransaction = function(request, ua) {\n  var events = ['stateChanged'];\n\n  this.type = C.NON_INVITE_SERVER;\n  this.id = request.via_branch;\n  this.request = request;\n  this.transport = request.transport;\n  this.ua = ua;\n  this.last_response = '';\n  request.server_transaction = this;\n\n  this.logger = ua.getLogger('sip.transaction.nist', this.id);\n\n  this.state = C.STATUS_TRYING;\n\n  ua.newTransaction(this);\n\n  this.initEvents(events);\n};\nNonInviteServerTransaction.prototype = new SIP.EventEmitter();\n\nNonInviteServerTransaction.prototype.stateChanged = function(state) {\n  this.state = state;\n  this.emit('stateChanged');\n};\n\nNonInviteServerTransaction.prototype.timer_J = function() {\n  this.logger.log('Timer J expired for non-INVITE server transaction ' + this.id);\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.ua.destroyTransaction(this);\n};\n\nNonInviteServerTransaction.prototype.onTransportError = function() {\n  if (!this.transportError) {\n    this.transportError = true;\n\n    this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);\n\n    SIP.Timers.clearTimeout(this.J);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n};\n\nNonInviteServerTransaction.prototype.receiveResponse = function(status_code, response, onSuccess, onFailure) {\n  var tr = this;\n\n  if(status_code === 100) {\n    /* RFC 4320 4.1\n     * 'A SIP element MUST NOT\n     * send any provisional response with a\n     * Status-Code other than 100 to a non-INVITE request.'\n     */\n    switch(this.state) {\n      case C.STATUS_TRYING:\n        this.stateChanged(C.STATUS_PROCEEDING);\n        if(!this.transport.send(response))  {\n          this.onTransportError();\n        }\n        break;\n      case C.STATUS_PROCEEDING:\n        this.last_response = response;\n        if(!this.transport.send(response)) {\n          this.onTransportError();\n          if (onFailure) {\n            onFailure();\n          }\n        } else if (onSuccess) {\n          onSuccess();\n        }\n        break;\n    }\n  } else if(status_code >= 200 && status_code <= 699) {\n    switch(this.state) {\n      case C.STATUS_TRYING:\n      case C.STATUS_PROCEEDING:\n        this.stateChanged(C.STATUS_COMPLETED);\n        this.last_response = response;\n        this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);\n        if(!this.transport.send(response)) {\n          this.onTransportError();\n          if (onFailure) {\n            onFailure();\n          }\n        } else if (onSuccess) {\n          onSuccess();\n        }\n        break;\n      case C.STATUS_COMPLETED:\n        break;\n    }\n  }\n};\n\n/**\n* @augments SIP.Transactions\n* @class Invite Server Transaction\n* @param {SIP.IncomingRequest} request\n* @param {SIP.UA} ua\n*/\nvar InviteServerTransaction = function(request, ua) {\n  var events = ['stateChanged'];\n\n  this.type = C.INVITE_SERVER;\n  this.id = request.via_branch;\n  this.request = request;\n  this.transport = request.transport;\n  this.ua = ua;\n  this.last_response = '';\n  request.server_transaction = this;\n\n  this.logger = ua.getLogger('sip.transaction.ist', this.id);\n\n  this.state = C.STATUS_PROCEEDING;\n\n  ua.newTransaction(this);\n\n  this.resendProvisionalTimer = null;\n\n  request.reply(100);\n\n  this.initEvents(events);\n};\nInviteServerTransaction.prototype = new SIP.EventEmitter();\n\nInviteServerTransaction.prototype.stateChanged = function(state) {\n  this.state = state;\n  this.emit('stateChanged');\n};\n\nInviteServerTransaction.prototype.timer_H = function() {\n  this.logger.log('Timer H expired for INVITE server transaction ' + this.id);\n\n  if(this.state === C.STATUS_COMPLETED) {\n    this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');\n  }\n\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.ua.destroyTransaction(this);\n};\n\nInviteServerTransaction.prototype.timer_I = function() {\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.ua.destroyTransaction(this);\n};\n\n// RFC 6026 7.1\nInviteServerTransaction.prototype.timer_L = function() {\n  this.logger.log('Timer L expired for INVITE server transaction ' + this.id);\n\n  if(this.state === C.STATUS_ACCEPTED) {\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n};\n\nInviteServerTransaction.prototype.onTransportError = function() {\n  if (!this.transportError) {\n    this.transportError = true;\n\n    this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);\n\n    if (this.resendProvisionalTimer !== null) {\n      SIP.Timers.clearInterval(this.resendProvisionalTimer);\n      this.resendProvisionalTimer = null;\n    }\n\n    SIP.Timers.clearTimeout(this.L);\n    SIP.Timers.clearTimeout(this.H);\n    SIP.Timers.clearTimeout(this.I);\n\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n};\n\nInviteServerTransaction.prototype.resend_provisional = function() {\n  if(!this.transport.send(this.last_response)) {\n    this.onTransportError();\n  }\n};\n\n// INVITE Server Transaction RFC 3261 17.2.1\nInviteServerTransaction.prototype.receiveResponse = function(status_code, response, onSuccess, onFailure) {\n  var tr = this;\n\n  if(status_code >= 100 && status_code <= 199) {\n    switch(this.state) {\n      case C.STATUS_PROCEEDING:\n        if(!this.transport.send(response)) {\n          this.onTransportError();\n        }\n        this.last_response = response;\n        break;\n    }\n  }\n\n  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {\n    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.\n    if(this.resendProvisionalTimer === null) {\n      this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr),\n        SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);\n    }\n  } else if(status_code >= 200 && status_code <= 299) {\n    switch(this.state) {\n      case C.STATUS_PROCEEDING:\n        this.stateChanged(C.STATUS_ACCEPTED);\n        this.last_response = response;\n        this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);\n\n        if (this.resendProvisionalTimer !== null) {\n          SIP.Timers.clearInterval(this.resendProvisionalTimer);\n          this.resendProvisionalTimer = null;\n        }\n        /* falls through */\n        case C.STATUS_ACCEPTED:\n          // Note that this point will be reached for proceeding tr.state also.\n          if(!this.transport.send(response)) {\n            this.onTransportError();\n            if (onFailure) {\n              onFailure();\n            }\n          } else if (onSuccess) {\n            onSuccess();\n          }\n          break;\n    }\n  } else if(status_code >= 300 && status_code <= 699) {\n    switch(this.state) {\n      case C.STATUS_PROCEEDING:\n        if (this.resendProvisionalTimer !== null) {\n          SIP.Timers.clearInterval(this.resendProvisionalTimer);\n          this.resendProvisionalTimer = null;\n        }\n\n        if(!this.transport.send(response)) {\n          this.onTransportError();\n          if (onFailure) {\n            onFailure();\n          }\n        } else {\n          this.stateChanged(C.STATUS_COMPLETED);\n          this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);\n          if (onSuccess) {\n            onSuccess();\n          }\n        }\n        break;\n    }\n  }\n};\n\n/**\n * @function\n * @param {SIP.UA} ua\n * @param {SIP.IncomingRequest} request\n *\n * @return {boolean}\n * INVITE:\n *  _true_ if retransmission\n *  _false_ new request\n *\n * ACK:\n *  _true_  ACK to non2xx response\n *  _false_ ACK must be passed to TU (accepted state)\n *          ACK to 2xx response\n *\n * CANCEL:\n *  _true_  no matching invite transaction\n *  _false_ matching invite transaction and no final response sent\n *\n * OTHER:\n *  _true_  retransmission\n *  _false_ new request\n */\nvar checkTransaction = function(ua, request) {\n  var tr;\n\n  switch(request.method) {\n    case SIP.C.INVITE:\n      tr = ua.transactions.ist[request.via_branch];\n      if(tr) {\n        switch(tr.state) {\n          case C.STATUS_PROCEEDING:\n            tr.transport.send(tr.last_response);\n            break;\n\n            // RFC 6026 7.1 Invite retransmission\n            //received while in C.STATUS_ACCEPTED state. Absorb it.\n          case C.STATUS_ACCEPTED:\n            break;\n        }\n        return true;\n      }\n      break;\n    case SIP.C.ACK:\n      tr = ua.transactions.ist[request.via_branch];\n\n      // RFC 6026 7.1\n      if(tr) {\n        if(tr.state === C.STATUS_ACCEPTED) {\n          return false;\n        } else if(tr.state === C.STATUS_COMPLETED) {\n          tr.state = C.STATUS_CONFIRMED;\n          tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);\n          return true;\n        }\n      }\n\n      // ACK to 2XX Response.\n      else {\n        return false;\n      }\n      break;\n    case SIP.C.CANCEL:\n      tr = ua.transactions.ist[request.via_branch];\n      if(tr) {\n        request.reply_sl(200);\n        if(tr.state === C.STATUS_PROCEEDING) {\n          return false;\n        } else {\n          return true;\n        }\n      } else {\n        request.reply_sl(481);\n        return true;\n      }\n      break;\n    default:\n\n      // Non-INVITE Server Transaction RFC 3261 17.2.2\n      tr = ua.transactions.nist[request.via_branch];\n      if(tr) {\n        switch(tr.state) {\n          case C.STATUS_TRYING:\n            break;\n          case C.STATUS_PROCEEDING:\n          case C.STATUS_COMPLETED:\n            tr.transport.send(tr.last_response);\n            break;\n        }\n        return true;\n      }\n      break;\n  }\n};\n\nSIP.Transactions = {\n  C: C,\n  checkTransaction: checkTransaction,\n  NonInviteClientTransaction: NonInviteClientTransaction,\n  InviteClientTransaction: InviteClientTransaction,\n  AckClientTransaction: AckClientTransaction,\n  NonInviteServerTransaction: NonInviteServerTransaction,\n  InviteServerTransaction: InviteServerTransaction\n};\n\n};\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\n/**\n * @fileoverview In-Dialog Request Sender\n */\n\n/**\n * @augments SIP.Dialog\n * @class Class creating an In-dialog request sender.\n * @param {SIP.Dialog} dialog\n * @param {Object} applicant\n * @param {SIP.OutgoingRequest} request\n */\n/**\n * @fileoverview in-Dialog Request Sender\n */\n\nmodule.exports = function (SIP) {\nvar RequestSender;\n\nRequestSender = function(dialog, applicant, request) {\n\n  this.dialog = dialog;\n  this.applicant = applicant;\n  this.request = request;\n\n  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.\n  this.reattempt = false;\n  this.reattemptTimer = null;\n};\n\nRequestSender.prototype = {\n  send: function() {\n    var self = this,\n      request_sender = new SIP.RequestSender(this, this.dialog.owner.ua);\n\n      request_sender.send();\n\n    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-\n    if (this.request.method === SIP.C.INVITE && request_sender.clientTransaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n      this.dialog.uac_pending_reply = true;\n      request_sender.clientTransaction.on('stateChanged', function stateChanged(){\n        if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n            this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n            this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n\n          this.off('stateChanged', stateChanged);\n          self.dialog.uac_pending_reply = false;\n\n          if (self.dialog.uas_pending_reply === false) {\n            self.dialog.owner.onReadyToReinvite();\n          }\n        }\n      });\n    }\n  },\n\n  onRequestTimeout: function() {\n    this.applicant.onRequestTimeout();\n  },\n\n  onTransportError: function() {\n    this.applicant.onTransportError();\n  },\n\n  receiveResponse: function(response) {\n    var self = this;\n\n    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.\n    if (response.status_code === 408 || response.status_code === 481) {\n      this.applicant.onDialogError(response);\n    } else if (response.method === SIP.C.INVITE && response.status_code === 491) {\n      if (this.reattempt) {\n        this.applicant.receiveResponse(response);\n      } else {\n        this.request.cseq.value = this.dialog.local_seqnum += 1;\n        this.reattemptTimer = SIP.Timers.setTimeout(\n          function() {\n            if (self.applicant.owner.status !== SIP.Session.C.STATUS_TERMINATED) {\n              self.reattempt = true;\n              self.request_sender.send();\n            }\n          },\n          this.getReattemptTimeout()\n        );\n      }\n    } else {\n      this.applicant.receiveResponse(response);\n    }\n  }\n};\n\nreturn RequestSender;\n};\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview SIP Dialog\n */\n\n/**\n * @augments SIP\n * @class Class creating a SIP dialog.\n * @param {SIP.RTCSession} owner\n * @param {SIP.IncomingRequest|SIP.IncomingResponse} message\n * @param {Enum} type UAC / UAS\n * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED\n */\nmodule.exports = function (SIP, RequestSender) {\n\nvar Dialog,\n  C = {\n    // Dialog states\n    STATUS_EARLY:       1,\n    STATUS_CONFIRMED:   2\n  };\n\n// RFC 3261 12.1\nDialog = function(owner, message, type, state) {\n  var contact;\n\n  this.uac_pending_reply = false;\n  this.uas_pending_reply = false;\n\n  if(!message.hasHeader('contact')) {\n    return {\n      error: 'unable to create a Dialog without Contact header field'\n    };\n  }\n\n  if(message instanceof SIP.IncomingResponse) {\n    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;\n  } else {\n    // Create confirmed dialog if state is not defined\n    state = state || C.STATUS_CONFIRMED;\n  }\n\n  contact = message.parseHeader('contact');\n\n  // RFC 3261 12.1.1\n  if(type === 'UAS') {\n    this.id = {\n      call_id: message.call_id,\n      local_tag: message.to_tag,\n      remote_tag: message.from_tag,\n      toString: function() {\n        return this.call_id + this.local_tag + this.remote_tag;\n      }\n    };\n    this.state = state;\n    this.remote_seqnum = message.cseq;\n    this.local_uri = message.parseHeader('to').uri;\n    this.remote_uri = message.parseHeader('from').uri;\n    this.remote_target = contact.uri;\n    this.route_set = message.getHeaders('record-route');\n    this.invite_seqnum = message.cseq;\n    this.local_seqnum = message.cseq;\n  }\n  // RFC 3261 12.1.2\n  else if(type === 'UAC') {\n    this.id = {\n      call_id: message.call_id,\n      local_tag: message.from_tag,\n      remote_tag: message.to_tag,\n      toString: function() {\n        return this.call_id + this.local_tag + this.remote_tag;\n      }\n    };\n    this.state = state;\n    this.invite_seqnum = message.cseq;\n    this.local_seqnum = message.cseq;\n    this.local_uri = message.parseHeader('from').uri;\n    this.pracked = [];\n    this.remote_uri = message.parseHeader('to').uri;\n    this.remote_target = contact.uri;\n    this.route_set = message.getHeaders('record-route').reverse();\n\n    //RENDERBODY\n    if (this.state === C.STATUS_EARLY && (!owner.hasOffer)) {\n      this.mediaHandler = owner.mediaHandlerFactory(owner);\n    }\n  }\n\n  this.logger = owner.ua.getLogger('sip.dialog', this.id.toString());\n  this.owner = owner;\n  owner.ua.dialogs[this.id.toString()] = this;\n  this.logger.log('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));\n};\n\nDialog.prototype = {\n  /**\n   * @param {SIP.IncomingMessage} message\n   * @param {Enum} UAC/UAS\n   */\n  update: function(message, type) {\n    this.state = C.STATUS_CONFIRMED;\n\n    this.logger.log('dialog '+ this.id.toString() +'  changed to CONFIRMED state');\n\n    if(type === 'UAC') {\n      // RFC 3261 13.2.2.4\n      this.route_set = message.getHeaders('record-route').reverse();\n    }\n  },\n\n  terminate: function() {\n    this.logger.log('dialog ' + this.id.toString() + ' deleted');\n    if (this.mediaHandler && this.state !== C.STATUS_CONFIRMED) {\n      this.mediaHandler.peerConnection.close();\n    }\n    delete this.owner.ua.dialogs[this.id.toString()];\n  },\n\n  /**\n  * @param {String} method request method\n  * @param {Object} extraHeaders extra headers\n  * @returns {SIP.OutgoingRequest}\n  */\n\n  // RFC 3261 12.2.1.1\n  createRequest: function(method, extraHeaders, body) {\n    var cseq, request;\n    extraHeaders = (extraHeaders || []).slice();\n\n    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }\n\n    cseq = (method === SIP.C.CANCEL || method === SIP.C.ACK) ? this.invite_seqnum : this.local_seqnum += 1;\n\n    request = new SIP.OutgoingRequest(\n      method,\n      this.remote_target,\n      this.owner.ua, {\n        'cseq': cseq,\n        'call_id': this.id.call_id,\n        'from_uri': this.local_uri,\n        'from_tag': this.id.local_tag,\n        'to_uri': this.remote_uri,\n        'to_tag': this.id.remote_tag,\n        'route_set': this.route_set\n      }, extraHeaders, body);\n\n    request.dialog = this;\n\n    return request;\n  },\n\n  /**\n  * @param {SIP.IncomingRequest} request\n  * @returns {Boolean}\n  */\n\n  // RFC 3261 12.2.2\n  checkInDialogRequest: function(request) {\n    var self = this;\n\n    if(!this.remote_seqnum) {\n      this.remote_seqnum = request.cseq;\n    } else if(request.cseq < this.remote_seqnum) {\n        //Do not try to reply to an ACK request.\n        if (request.method !== SIP.C.ACK) {\n          request.reply(500);\n        }\n        if (request.cseq === this.invite_seqnum) {\n          return true;\n        }\n        return false;\n    } else if(request.cseq > this.remote_seqnum) {\n      this.remote_seqnum = request.cseq;\n    }\n\n    switch(request.method) {\n      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-\n      case SIP.C.INVITE:\n        if (this.uac_pending_reply === true) {\n          request.reply(491);\n        } else if (this.uas_pending_reply === true) {\n          var retryAfter = (Math.random() * 10 | 0) + 1;\n          request.reply(500, null, ['Retry-After:' + retryAfter]);\n          return false;\n        } else {\n          this.uas_pending_reply = true;\n          request.server_transaction.on('stateChanged', function stateChanged(){\n            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n                this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n                this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n\n              this.off('stateChanged', stateChanged);\n              self.uas_pending_reply = false;\n\n              if (self.uac_pending_reply === false) {\n                self.owner.onReadyToReinvite();\n              }\n            }\n          });\n        }\n\n        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted\n        if(request.hasHeader('contact')) {\n          request.server_transaction.on('stateChanged', function(){\n            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED) {\n              self.remote_target = request.parseHeader('contact').uri;\n            }\n          });\n        }\n        break;\n      case SIP.C.NOTIFY:\n        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted\n        if(request.hasHeader('contact')) {\n          request.server_transaction.on('stateChanged', function(){\n            if (this.state === SIP.Transactions.C.STATUS_COMPLETED) {\n              self.remote_target = request.parseHeader('contact').uri;\n            }\n          });\n        }\n        break;\n    }\n\n    return true;\n  },\n\n  sendRequest: function(applicant, method, options) {\n    options = options || {};\n\n    var\n      extraHeaders = (options.extraHeaders || []).slice(),\n      body = options.body || null,\n      request = this.createRequest(method, extraHeaders, body),\n      request_sender = new RequestSender(this, applicant, request);\n\n    request_sender.send();\n\n    return request;\n  },\n\n  /**\n  * @param {SIP.IncomingRequest} request\n  */\n  receiveRequest: function(request) {\n    //Check in-dialog request\n    if(!this.checkInDialogRequest(request)) {\n      return;\n    }\n\n    this.owner.receiveRequest(request);\n  }\n};\n\nDialog.C = C;\nSIP.Dialog = Dialog;\n};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\n/**\n * @fileoverview Request Sender\n */\n\n/**\n * @augments SIP\n * @class Class creating a request sender.\n * @param {Object} applicant\n * @param {SIP.UA} ua\n */\nmodule.exports = function (SIP) {\nvar RequestSender;\n\nRequestSender = function(applicant, ua) {\n  this.logger = ua.getLogger('sip.requestsender');\n  this.ua = ua;\n  this.applicant = applicant;\n  this.method = applicant.request.method;\n  this.request = applicant.request;\n  this.credentials = null;\n  this.challenged = false;\n  this.staled = false;\n\n  // If ua is in closing process or even closed just allow sending Bye and ACK\n  if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {\n    this.onTransportError();\n  }\n};\n\n/**\n* Create the client transaction and send the message.\n*/\nRequestSender.prototype = {\n  send: function() {\n    switch(this.method) {\n      case \"INVITE\":\n        this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);\n        break;\n      case \"ACK\":\n        this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);\n        break;\n      default:\n        this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);\n    }\n    this.clientTransaction.send();\n\n    return this.clientTransaction;\n  },\n\n  /**\n  * Callback fired when receiving a request timeout error from the client transaction.\n  * To be re-defined by the applicant.\n  * @event\n  */\n  onRequestTimeout: function() {\n    this.applicant.onRequestTimeout();\n  },\n\n  /**\n  * Callback fired when receiving a transport error from the client transaction.\n  * To be re-defined by the applicant.\n  * @event\n  */\n  onTransportError: function() {\n    this.applicant.onTransportError();\n  },\n\n  /**\n  * Called from client transaction when receiving a correct response to the request.\n  * Authenticate request if needed or pass the response back to the applicant.\n  * @param {SIP.IncomingResponse} response\n  */\n  receiveResponse: function(response) {\n    var cseq, challenge, authorization_header_name,\n      status_code = response.status_code;\n\n    /*\n    * Authentication\n    * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n    */\n    if ((status_code === 401 || status_code === 407) && this.ua.configuration.password !== null) {\n\n      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n      if (response.status_code === 401) {\n        challenge = response.parseHeader('www-authenticate');\n        authorization_header_name = 'authorization';\n      } else {\n        challenge = response.parseHeader('proxy-authenticate');\n        authorization_header_name = 'proxy-authorization';\n      }\n\n      // Verify it seems a valid challenge.\n      if (! challenge) {\n        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');\n        this.applicant.receiveResponse(response);\n        return;\n      }\n\n      if (!this.challenged || (!this.staled && challenge.stale === true)) {\n        if (!this.credentials) {\n          this.credentials = new SIP.DigestAuthentication(this.ua);\n        }\n\n        // Verify that the challenge is really valid.\n        if (!this.credentials.authenticate(this.request, challenge)) {\n          this.applicant.receiveResponse(response);\n          return;\n        }\n        this.challenged = true;\n\n        if (challenge.stale) {\n          this.staled = true;\n        }\n\n        if (response.method === SIP.C.REGISTER) {\n          cseq = this.applicant.cseq += 1;\n        } else if (this.request.dialog){\n          cseq = this.request.dialog.local_seqnum += 1;\n        } else {\n          cseq = this.request.cseq + 1;\n          this.request.cseq = cseq;\n        }\n        this.request.setHeader('cseq', cseq +' '+ this.method);\n\n        this.request.setHeader(authorization_header_name, this.credentials.toString());\n        this.send();\n      } else {\n        this.applicant.receiveResponse(response);\n      }\n    } else {\n      this.applicant.receiveResponse(response);\n    }\n  }\n};\n\nSIP.RequestSender = RequestSender;\n};\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\nmodule.exports = function (SIP) {\n\nvar RegisterContext;\n\nRegisterContext = function (ua) {\n  var params = {},\n      regId = 1,\n      events = [\n        'registered',\n        'unregistered'\n      ];\n\n  this.registrar = ua.configuration.registrarServer;\n  this.expires = ua.configuration.registerExpires;\n\n\n  // Contact header\n  this.contact = ua.contact.toString();\n\n  if(regId) {\n    this.contact += ';reg-id='+ regId;\n    this.contact += ';+sip.instance=\"<urn:uuid:'+ ua.configuration.instanceId+'>\"';\n  }\n\n  // Call-ID and CSeq values RFC3261 10.2\n  this.call_id = SIP.Utils.createRandomToken(22);\n  this.cseq = 80;\n\n  this.to_uri = ua.configuration.uri;\n\n  params.to_uri = this.to_uri;\n  params.call_id = this.call_id;\n  params.cseq = this.cseq;\n\n  // Extends ClientContext\n  SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, {params: params}]);\n\n  this.registrationTimer = null;\n  this.registrationExpiredTimer = null;\n\n  // Set status\n  this.registered = false;\n\n  this.logger = ua.getLogger('sip.registercontext');\n  this.initMoreEvents(events);\n};\n\nRegisterContext.prototype = {\n  register: function (options) {\n    var self = this, extraHeaders;\n\n    // Handle Options\n    options = options || {};\n    extraHeaders = (options.extraHeaders || []).slice();\n    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);\n    extraHeaders.push('Allow: ' + SIP.Utils.getAllowedMethods(this.ua));\n\n    this.receiveResponse = function(response) {\n      var contact, expires,\n        contacts = response.getHeaders('contact').length,\n        cause;\n\n      // Discard responses to older REGISTER/un-REGISTER requests.\n      if(response.cseq !== this.cseq) {\n        return;\n      }\n\n      // Clear registration timer\n      if (this.registrationTimer !== null) {\n        SIP.Timers.clearTimeout(this.registrationTimer);\n        this.registrationTimer = null;\n      }\n\n      switch(true) {\n        case /^1[0-9]{2}$/.test(response.status_code):\n          this.emit('progress', response);\n          break;\n        case /^2[0-9]{2}$/.test(response.status_code):\n          this.emit('accepted', response);\n\n          if(response.hasHeader('expires')) {\n            expires = response.getHeader('expires');\n          }\n\n          if (this.registrationExpiredTimer !== null) {\n            SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n            this.registrationExpiredTimer = null;\n          }\n\n          // Search the Contact pointing to us and update the expires value accordingly.\n          if (!contacts) {\n            this.logger.warn('no Contact header in response to REGISTER, response ignored');\n            break;\n          }\n\n          while(contacts--) {\n            contact = response.parseHeader('contact', contacts);\n            if(contact.uri.user === this.ua.contact.uri.user) {\n              expires = contact.getParam('expires');\n              break;\n            } else {\n              contact = null;\n            }\n          }\n\n          if (!contact) {\n            this.logger.warn('no Contact header pointing to us, response ignored');\n            break;\n          }\n\n          if(!expires) {\n            expires = this.expires;\n          }\n\n          // Re-Register before the expiration interval has elapsed.\n          // For that, decrease the expires value. ie: 3 seconds\n          this.registrationTimer = SIP.Timers.setTimeout(function() {\n            self.registrationTimer = null;\n            self.register(options);\n          }, (expires * 1000) - 3000);\n          this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {\n            self.logger.warn('registration expired');\n            if (self.registered) {\n              self.unregistered(null, SIP.C.causes.EXPIRES);\n            }\n          }, expires * 1000);\n\n          //Save gruu values\n          if (contact.hasParam('temp-gruu')) {\n            this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/\"/g,''));\n          }\n          if (contact.hasParam('pub-gruu')) {\n            this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/\"/g,''));\n          }\n\n          this.registered = true;\n          this.emit('registered', response || null);\n          break;\n        // Interval too brief RFC3261 10.2.8\n        case /^423$/.test(response.status_code):\n          if(response.hasHeader('min-expires')) {\n            // Increase our registration interval to the suggested minimum\n            this.expires = response.getHeader('min-expires');\n            // Attempt the registration again immediately\n            this.register(options);\n          } else { //This response MUST contain a Min-Expires header field\n            this.logger.warn('423 response received for REGISTER without Min-Expires');\n            this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);\n          }\n          break;\n        default:\n          cause = SIP.Utils.sipErrorCause(response.status_code);\n          this.registrationFailure(response, cause);\n      }\n    };\n\n    this.onRequestTimeout = function() {\n      this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);\n    };\n\n    this.onTransportError = function() {\n      this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);\n    };\n\n    this.cseq++;\n    this.request.cseq = this.cseq;\n    this.request.setHeader('cseq', this.cseq + ' REGISTER');\n    this.request.extraHeaders = extraHeaders;\n    this.send();\n  },\n\n  registrationFailure: function (response, cause) {\n    this.emit('failed', response || null, cause || null);\n  },\n\n  onTransportClosed: function() {\n    this.registered_before = this.registered;\n    if (this.registrationTimer !== null) {\n      SIP.Timers.clearTimeout(this.registrationTimer);\n      this.registrationTimer = null;\n    }\n\n    if (this.registrationExpiredTimer !== null) {\n      SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n      this.registrationExpiredTimer = null;\n    }\n\n    if(this.registered) {\n      this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n    }\n  },\n\n  onTransportConnected: function() {\n    this.register();\n  },\n\n  close: function() {\n    this.registered_before = this.registered;\n    this.unregister();\n  },\n\n  unregister: function(options) {\n    var extraHeaders;\n\n    if(!this.registered) {\n      this.logger.warn('already unregistered');\n      return;\n    }\n\n    options = options || {};\n    extraHeaders = (options.extraHeaders || []).slice();\n\n    this.registered = false;\n\n    // Clear the registration timer.\n    if (this.registrationTimer !== null) {\n      SIP.Timers.clearTimeout(this.registrationTimer);\n      this.registrationTimer = null;\n    }\n\n    if(options.all) {\n      extraHeaders.push('Contact: *');\n      extraHeaders.push('Expires: 0');\n    } else {\n      extraHeaders.push('Contact: '+ this.contact + ';expires=0');\n    }\n\n\n    this.receiveResponse = function(response) {\n      var cause;\n\n      switch(true) {\n        case /^1[0-9]{2}$/.test(response.status_code):\n          this.emit('progress', response);\n          break;\n        case /^2[0-9]{2}$/.test(response.status_code):\n          this.emit('accepted', response);\n          if (this.registrationExpiredTimer !== null) {\n            SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n            this.registrationExpiredTimer = null;\n          }\n          this.unregistered(response);\n          break;\n        default:\n          cause = SIP.Utils.sipErrorCause(response.status_code);\n          this.unregistered(response,cause);\n      }\n    };\n\n    this.onRequestTimeout = function() {\n      // Not actually unregistered...\n      //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);\n    };\n\n    this.onTransportError = function() {\n      // Not actually unregistered...\n      //this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n    };\n\n    this.cseq++;\n    this.request.cseq = this.cseq;\n    this.request.setHeader('cseq', this.cseq + ' REGISTER');\n    this.request.extraHeaders = extraHeaders;\n\n    this.send();\n  },\n\n  unregistered: function(response, cause) {\n    this.registered = false;\n    this.emit('unregistered', response || null, cause || null);\n  }\n\n};\n\n\nSIP.RegisterContext = RegisterContext;\n};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview MediaHandler\n */\n\n/* MediaHandler\n * @class PeerConnection helper Class.\n * @param {SIP.Session} session\n * @param {Object} [options]\n */\nmodule.exports = function (EventEmitter) {\nvar MediaHandler = function(session, options) {\n  // keep jshint happy\n  session = session;\n  options = options;\n};\n\nMediaHandler.prototype = Object.create(EventEmitter.prototype, {\n  isReady: {value: function isReady () {}},\n\n  close: {value: function close () {}},\n\n  /**\n   * @param {Function} onSuccess called with the obtained local media description\n   * @param {Function} onFailure\n   * @param {Object} [mediaHint] A custom object describing the media to be used during this session.\n   */\n  getDescription: {value: function getDescription (onSuccess, onFailure, mediaHint) {\n    // keep jshint happy\n    onSuccess = onSuccess;\n    onFailure = onFailure;\n    mediaHint = mediaHint;\n  }},\n\n  /**\n  * Message reception.\n  * @param {String} type\n  * @param {String} description\n  * @param {Function} onSuccess\n  * @param {Function} onFailure\n  */\n  setDescription: {value: function setDescription (description, onSuccess, onFailure) {\n    // keep jshint happy\n    description = description;\n    onSuccess = onSuccess;\n    onFailure = onFailure;\n  }}\n});\n\nreturn MediaHandler;\n};\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\nmodule.exports = function (SIP) {\nvar ClientContext;\n\nClientContext = function (ua, method, target, options) {\n  var params, extraHeaders,\n      originalTarget = target,\n      events = [\n        'progress',\n        'accepted',\n        'rejected',\n        'failed',\n        'cancel'\n      ];\n\n  if (target === undefined) {\n    throw new TypeError('Not enough arguments');\n  }\n\n  // Check target validity\n  target = ua.normalizeTarget(target);\n  if (!target) {\n    throw new TypeError('Invalid target: ' + originalTarget);\n  }\n\n  this.ua = ua;\n  this.logger = ua.getLogger('sip.clientcontext');\n  this.method = method;\n\n  params = options && options.params;\n  extraHeaders = (options && options.extraHeaders || []).slice();\n\n  if (options && options.body) {\n    this.body = options.body;\n  }\n  if (options && options.contentType) {\n    this.contentType = options.contentType;\n    extraHeaders.push('Content-Type: ' + this.contentType);\n  }\n\n  this.request = new SIP.OutgoingRequest(this.method, target, this.ua, params, extraHeaders);\n\n  this.localIdentity = this.request.from;\n  this.remoteIdentity = this.request.to;\n\n  if (this.body) {\n    this.request.body = this.body;\n  }\n\n  this.data = {};\n\n  this.initEvents(events);\n};\nClientContext.prototype = new SIP.EventEmitter();\n\nClientContext.prototype.send = function () {\n  (new SIP.RequestSender(this, this.ua)).send();\n  return this;\n};\n\nClientContext.prototype.cancel = function (options) {\n  options = options || {};\n\n  var\n  status_code = options.status_code,\n  reason_phrase = options.reason_phrase,\n  cancel_reason;\n\n  if (status_code && status_code < 200 || status_code > 699) {\n    throw new TypeError('Invalid status_code: ' + status_code);\n  } else if (status_code) {\n    reason_phrase = reason_phrase || SIP.C.REASON_PHRASE[status_code] || '';\n    cancel_reason = 'SIP ;cause=' + status_code + ' ;text=\"' + reason_phrase + '\"';\n  }\n  this.request.cancel(cancel_reason);\n\n  this.emit('cancel');\n};\n\nClientContext.prototype.receiveResponse = function (response) {\n  var cause = SIP.C.REASON_PHRASE[response.status_code] || '';\n\n  switch(true) {\n    case /^1[0-9]{2}$/.test(response.status_code):\n      this.emit('progress', response, cause);\n      break;\n\n    case /^2[0-9]{2}$/.test(response.status_code):\n      if(this.ua.applicants[this]) {\n        delete this.ua.applicants[this];\n      }\n      this.emit('accepted', response, cause);\n      break;\n\n    default:\n      if(this.ua.applicants[this]) {\n        delete this.ua.applicants[this];\n      }\n      this.emit('rejected', response, cause);\n      this.emit('failed', response, cause);\n      break;\n  }\n\n};\n\nClientContext.prototype.onRequestTimeout = function () {\n  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n};\n\nClientContext.prototype.onTransportError = function () {\n  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n};\n\nSIP.ClientContext = ClientContext;\n};\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\nmodule.exports = function (SIP) {\nvar ServerContext;\n\nServerContext = function (ua, request) {\n  var events = [\n      'progress',\n      'accepted',\n      'rejected',\n      'failed'\n    ];\n  this.ua = ua;\n  this.logger = ua.getLogger('sip.servercontext');\n  this.request = request;\n  if (request.method === SIP.C.INVITE) {\n    this.transaction = new SIP.Transactions.InviteServerTransaction(request, ua);\n  } else {\n    this.transaction = new SIP.Transactions.NonInviteServerTransaction(request, ua);\n  }\n\n  if (request.body) {\n    this.body = request.body;\n  }\n  if (request.hasHeader('Content-Type')) {\n    this.contentType = request.getHeader('Content-Type');\n  }\n  this.method = request.method;\n\n  this.data = {};\n\n  this.localIdentity = request.to;\n  this.remoteIdentity = request.from;\n\n  this.initEvents(events);\n};\n\nServerContext.prototype = new SIP.EventEmitter();\n\nServerContext.prototype.progress = function (options) {\n  options = options || {};\n  var\n    statusCode = options.statusCode || 180,\n    reasonPhrase = options.reasonPhrase || SIP.C.REASON_PHRASE[statusCode],\n    extraHeaders = (options.extraHeaders || []).slice(),\n    body = options.body,\n    response;\n\n  if (statusCode < 100 || statusCode > 199) {\n    throw new TypeError('Invalid statusCode: ' + statusCode);\n  }\n  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n  this.emit('progress', response, reasonPhrase);\n\n  return this;\n};\n\nServerContext.prototype.accept = function (options) {\n  options = options || {};\n  var\n    statusCode = options.statusCode || 200,\n    reasonPhrase = options.reasonPhrase || SIP.C.REASON_PHRASE[statusCode],\n    extraHeaders = (options.extraHeaders || []).slice(),\n    body = options.body,\n    response;\n\n  if (statusCode < 200 || statusCode > 299) {\n    throw new TypeError('Invalid statusCode: ' + statusCode);\n  }\n  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n  this.emit('accepted', response, reasonPhrase);\n\n  return this;\n};\n\nServerContext.prototype.reject = function (options) {\n  options = options || {};\n  var\n    statusCode = options.statusCode || 480,\n    reasonPhrase = options.reasonPhrase || SIP.C.REASON_PHRASE[statusCode],\n    extraHeaders = (options.extraHeaders || []).slice(),\n    body = options.body,\n    response;\n\n  if (statusCode < 300 || statusCode > 699) {\n    throw new TypeError('Invalid statusCode: ' + statusCode);\n  }\n  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n  this.emit('rejected', response, reasonPhrase);\n  this.emit('failed', response, reasonPhrase);\n\n  return this;\n};\n\nServerContext.prototype.reply = function (options) {\n  options = options || {};\n  var\n    statusCode = options.statusCode,\n    reasonPhrase = options.reasonPhrase,\n    extraHeaders = (options.extraHeaders || []).slice(),\n    body = options.body;\n\n  this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n\n  return this;\n};\n\nServerContext.prototype.onRequestTimeout = function () {\n  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n};\n\nServerContext.prototype.onTransportError = function () {\n  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n};\n\nSIP.ServerContext = ServerContext;\n};\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview DTMF\n */\n\n/**\n * @class DTMF\n * @param {SIP.Session} session\n */\nmodule.exports = function (SIP) {\n\nvar DTMF,\n  C = {\n    MIN_DURATION:            70,\n    MAX_DURATION:            6000,\n    DEFAULT_DURATION:        100,\n    MIN_INTER_TONE_GAP:      50,\n    DEFAULT_INTER_TONE_GAP:  500\n  };\n\nDTMF = function(session, tone, options) {\n  var events = [\n  'succeeded',\n  'failed'\n  ], duration, interToneGap;\n\n  if (tone === undefined) {\n    throw new TypeError('Not enough arguments');\n  }\n\n  this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);\n  this.owner = session;\n  this.direction = null;\n\n  options = options || {};\n  duration = options.duration || null;\n  interToneGap = options.interToneGap || null;\n\n  // Check tone type\n  if (typeof tone === 'string' ) {\n    tone = tone.toUpperCase();\n  } else if (typeof tone === 'number') {\n    tone = tone.toString();\n  } else {\n    throw new TypeError('Invalid tone: '+ tone);\n  }\n\n  // Check tone value\n  if (!tone.match(/^[0-9A-D#*]$/)) {\n    throw new TypeError('Invalid tone: '+ tone);\n  } else {\n    this.tone = tone;\n  }\n\n  // Check duration\n  if (duration && !SIP.Utils.isDecimal(duration)) {\n    throw new TypeError('Invalid tone duration: '+ duration);\n  } else if (!duration) {\n    duration = DTMF.C.DEFAULT_DURATION;\n  } else if (duration < DTMF.C.MIN_DURATION) {\n    this.logger.warn('\"duration\" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_DURATION+ ' milliseconds');\n    duration = DTMF.C.MIN_DURATION;\n  } else if (duration > DTMF.C.MAX_DURATION) {\n    this.logger.warn('\"duration\" value is greater than the maximum allowed, setting it to '+ DTMF.C.MAX_DURATION +' milliseconds');\n    duration = DTMF.C.MAX_DURATION;\n  } else {\n    duration = Math.abs(duration);\n  }\n  this.duration = duration;\n\n  // Check interToneGap\n  if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {\n    throw new TypeError('Invalid interToneGap: '+ interToneGap);\n  } else if (!interToneGap) {\n    interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;\n  } else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {\n    this.logger.warn('\"interToneGap\" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_INTER_TONE_GAP +' milliseconds');\n    interToneGap = DTMF.C.MIN_INTER_TONE_GAP;\n  } else {\n    interToneGap = Math.abs(interToneGap);\n  }\n  this.interToneGap = interToneGap;\n\n  this.initEvents(events);\n};\nDTMF.prototype = new SIP.EventEmitter();\n\n\nDTMF.prototype.send = function(options) {\n  var extraHeaders, body;\n\n  this.direction = 'outgoing';\n\n  // Check RTCSession Status\n  if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED &&\n    this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n    throw new SIP.Exceptions.InvalidStateError(this.owner.status);\n  }\n\n  // Get DTMF options\n  options = options || {};\n  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];\n\n  extraHeaders.push('Content-Type: application/dtmf-relay');\n\n  body = \"Signal= \" + this.tone + \"\\r\\n\";\n  body += \"Duration= \" + this.duration;\n\n  this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {\n    extraHeaders: extraHeaders,\n    body: body\n  });\n\n  this.owner.emit('dtmf', this.request, this);\n};\n\n/**\n * @private\n */\nDTMF.prototype.receiveResponse = function(response) {\n  var cause;\n\n  switch(true) {\n    case /^1[0-9]{2}$/.test(response.status_code):\n      // Ignore provisional responses.\n      break;\n\n    case /^2[0-9]{2}$/.test(response.status_code):\n      this.emit('succeeded', {\n        originator: 'remote',\n        response: response\n      });\n      break;\n\n    default:\n      cause = SIP.Utils.sipErrorCause(response.status_code);\n      this.emit('failed', response, cause);\n      break;\n  }\n};\n\n/**\n * @private\n */\nDTMF.prototype.onRequestTimeout = function() {\n  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n  this.owner.onRequestTimeout();\n};\n\n/**\n * @private\n */\nDTMF.prototype.onTransportError = function() {\n  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n  this.owner.onTransportError();\n};\n\n/**\n * @private\n */\nDTMF.prototype.onDialogError = function(response) {\n  this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);\n  this.owner.onDialogError(response);\n};\n\n/**\n * @private\n */\nDTMF.prototype.init_incoming = function(request) {\n  this.direction = 'incoming';\n  this.request = request;\n\n  request.reply(200);\n\n  if (!this.tone || !this.duration) {\n    this.logger.warn('invalid INFO DTMF received, discarded');\n  } else {\n    this.owner.emit('dtmf', request, this);\n  }\n};\n\nDTMF.C = C;\nreturn DTMF;\n};\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\nmodule.exports = function (SIP, window, DTMF) {\n\nvar Session, InviteServerContext, InviteClientContext,\n C = {\n    //Session states\n    STATUS_NULL:                        0,\n    STATUS_INVITE_SENT:                 1,\n    STATUS_1XX_RECEIVED:                2,\n    STATUS_INVITE_RECEIVED:             3,\n    STATUS_WAITING_FOR_ANSWER:          4,\n    STATUS_ANSWERED:                    5,\n    STATUS_WAITING_FOR_PRACK:           6,\n    STATUS_WAITING_FOR_ACK:             7,\n    STATUS_CANCELED:                    8,\n    STATUS_TERMINATED:                  9,\n    STATUS_ANSWERED_WAITING_FOR_PRACK: 10,\n    STATUS_EARLY_MEDIA:                11,\n    STATUS_CONFIRMED:                  12\n  };\n\n/*\n * @param {function returning SIP.MediaHandler} [mediaHandlerFactory]\n *        (See the documentation for the mediaHandlerFactory argument of the UA constructor.)\n */\nSession = function (mediaHandlerFactory) {\n  var events = [\n  'connecting',\n  'terminated',\n  'dtmf',\n  'invite',\n  'cancel',\n  'refer',\n  'bye',\n  'hold',\n  'unhold',\n  'muted',\n  'unmuted'\n  ];\n\n  this.status = C.STATUS_NULL;\n  this.dialog = null;\n  this.earlyDialogs = {};\n  this.mediaHandlerFactory = mediaHandlerFactory || SIP.WebRTC.MediaHandler.defaultFactory;\n  // this.mediaHandler gets set by ICC/ISC constructors\n  this.hasOffer = false;\n  this.hasAnswer = false;\n\n  // Session Timers\n  this.timers = {\n    ackTimer: null,\n    expiresTimer: null,\n    invite2xxTimer: null,\n    userNoAnswerTimer: null,\n    rel1xxTimer: null,\n    prackTimer: null\n  };\n\n  // Session info\n  this.startTime = null;\n  this.endTime = null;\n  this.tones = null;\n\n  // Mute/Hold state\n  this.local_hold = false;\n  this.remote_hold = false;\n\n  this.pending_actions = {\n    actions: [],\n\n    length: function() {\n      return this.actions.length;\n    },\n\n    isPending: function(name){\n      var\n      idx = 0,\n      length = this.actions.length;\n\n      for (idx; idx<length; idx++) {\n        if (this.actions[idx].name === name) {\n          return true;\n        }\n      }\n      return false;\n    },\n\n    shift: function() {\n      return this.actions.shift();\n    },\n\n    push: function(name) {\n      this.actions.push({\n        name: name\n      });\n    },\n\n    pop: function(name) {\n      var\n      idx = 0,\n      length = this.actions.length;\n\n      for (idx; idx<length; idx++) {\n        if (this.actions[idx].name === name) {\n          this.actions.splice(idx,1);\n          length --;\n          idx--;\n        }\n      }\n    }\n   };\n\n  this.early_sdp = null;\n  this.rel100 = SIP.C.supported.UNSUPPORTED;\n\n  this.initMoreEvents(events);\n};\n\nSession.prototype = {\n  dtmf: function(tones, options) {\n    var tone, dtmfs = [],\n        self = this;\n\n    options = options || {};\n\n    if (tones === undefined) {\n      throw new TypeError('Not enough arguments');\n    }\n\n    // Check Session Status\n    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {\n      throw new SIP.Exceptions.InvalidStateError(this.status);\n    }\n\n    // Check tones\n    if (!tones || (typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {\n      throw new TypeError('Invalid tones: '+ tones);\n    }\n\n    tones = tones.toString().split('');\n\n    while (tones.length > 0) { dtmfs.push(new DTMF(this, tones.shift(), options)); }\n\n    if (this.tones) {\n      // Tones are already queued, just add to the queue\n      this.tones =  this.tones.concat(dtmfs);\n      return this;\n    }\n\n    var sendDTMF = function () {\n      var dtmf, timeout;\n\n      if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {\n        // Stop sending DTMF\n        self.tones = null;\n        return this;\n      }\n\n      dtmf = self.tones.shift();\n\n      if (tone === ',') {\n        timeout = 2000;\n      } else {\n        dtmf.on('failed', function(){self.tones = null;});\n        dtmf.send(options);\n        timeout = dtmf.duration + dtmf.interToneGap;\n      }\n\n      // Set timeout for the next tone\n      SIP.Timers.setTimeout(sendDTMF, timeout);\n    };\n\n    this.tones = dtmfs;\n    sendDTMF();\n    return this;\n  },\n\n  bye: function(options) {\n    options = options || {};\n    var statusCode = options.statusCode;\n\n    // Check Session Status\n    if (this.status === C.STATUS_TERMINATED) {\n      this.logger.error('Error: Attempted to send BYE in a terminated session.');\n      return this;\n    }\n\n    this.logger.log('terminating Session');\n\n    if (statusCode && (statusCode < 200 || statusCode >= 700)) {\n      throw new TypeError('Invalid statusCode: '+ statusCode);\n    }\n\n    options.receiveResponse = function () {};\n\n    return this.\n      sendRequest(SIP.C.BYE, options).\n      terminated();\n  },\n\n  refer: function(target, options) {\n    options = options || {};\n    var extraHeaders = (options.extraHeaders || []).slice(),\n        originalTarget = target;\n\n    if (target === undefined) {\n      throw new TypeError('Not enough arguments');\n    } else if (target instanceof SIP.InviteServerContext || target instanceof SIP.InviteClientContext) {\n      //Attended Transfer\n      // B.transfer(C)\n      extraHeaders.push('Contact: '+ this.contact);\n      extraHeaders.push('Allow: '+ SIP.Utils.getAllowedMethods(this.ua));\n      extraHeaders.push('Refer-To: <' + target.dialog.remote_target.toString() + '?Replaces=' + target.dialog.id.call_id + '%3Bto-tag%3D' + target.dialog.id.remote_tag + '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>');\n    } else {\n      //Blind Transfer\n\n      // Check Session Status\n      if (this.status !== C.STATUS_CONFIRMED) {\n        throw new SIP.Exceptions.InvalidStateError(this.status);\n      }\n\n      // normalizeTarget allows instances of SIP.URI to pass through unaltered,\n      // so try to make one ahead of time\n      try {\n        target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n      } catch (e) {\n        this.logger.debug(\".refer() cannot parse Refer_To from\", target);\n        this.logger.debug(\"...falling through to normalizeTarget()\");\n      }\n\n      // Check target validity\n      target = this.ua.normalizeTarget(target);\n      if (!target) {\n        throw new TypeError('Invalid target: ' + originalTarget);\n      }\n\n      extraHeaders.push('Contact: '+ this.contact);\n      extraHeaders.push('Allow: '+ SIP.Utils.getAllowedMethods(this.ua));\n      extraHeaders.push('Refer-To: '+ target);\n    }\n\n    // Send the request\n    this.sendRequest(SIP.C.REFER, {\n      extraHeaders: extraHeaders,\n      body: options.body,\n      receiveResponse: function() {}\n    });\n    // hang up only if we transferred to a SIP address\n    if (target.scheme.match(\"^sips?$\")) {\n      this.terminate();\n    }\n    return this;\n  },\n\n  followRefer: function followRefer (callback) {\n    return function referListener (callback, request) {\n      // window.open non-SIP URIs if possible and keep session open\n      var target = request.parseHeader('refer-to').uri;\n      if (!target.scheme.match(\"^sips?$\")) {\n        var targetString = target.toString();\n        if (typeof window !== \"undefined\" && typeof window.open === \"function\") {\n          window.open(targetString);\n        } else {\n          this.logger.warn(\"referred to non-SIP URI but window.open isn't a function: \" + targetString);\n        }\n        return;\n      }\n\n      SIP.Hacks.Chrome.getsConfusedAboutGUM(this);\n\n      /*\n        Harmless race condition.  Both sides of REFER\n        may send a BYE, but in the end the dialogs are destroyed.\n      */\n      var referSession = this.ua.invite(request.parseHeader('refer-to').uri, {\n        media: this.mediaHint\n      });\n\n      callback.call(this, request, referSession);\n\n      this.terminate();\n    }.bind(this, callback);\n  },\n\n  sendRequest: function(method,options) {\n    options = options || {};\n    var self = this;\n\n    var request = new SIP.OutgoingRequest(\n      method,\n      this.dialog.remote_target,\n      this.ua,\n      {\n        cseq: options.cseq || (this.dialog.local_seqnum += 1),\n        call_id: this.dialog.id.call_id,\n        from_uri: this.dialog.local_uri,\n        from_tag: this.dialog.id.local_tag,\n        to_uri: this.dialog.remote_uri,\n        to_tag: this.dialog.id.remote_tag,\n        route_set: this.dialog.route_set,\n        statusCode: options.statusCode,\n        reasonPhrase: options.reasonPhrase\n      },\n      options.extraHeaders || [],\n      options.body\n    );\n\n    new SIP.RequestSender({\n      request: request,\n      onRequestTimeout: function() {\n        self.onRequestTimeout();\n      },\n      onTransportError: function() {\n        self.onTransportError();\n      },\n      receiveResponse: options.receiveResponse || function(response) {\n        self.receiveNonInviteResponse(response);\n      }\n    }, this.ua).send();\n\n    // Emit the request event\n    if (this.checkEvent(method.toLowerCase())) {\n      this.emit(method.toLowerCase(), request);\n    }\n\n    return this;\n  },\n\n  close: function() {\n    var idx;\n\n    if(this.status === C.STATUS_TERMINATED) {\n      return this;\n    }\n\n    this.logger.log('closing INVITE session ' + this.id);\n\n    // 1st Step. Terminate media.\n    if (this.mediaHandler){\n      this.mediaHandler.close();\n    }\n\n    // 2nd Step. Terminate signaling.\n\n    // Clear session timers\n    for(idx in this.timers) {\n      SIP.Timers.clearTimeout(this.timers[idx]);\n    }\n\n    // Terminate dialogs\n\n    // Terminate confirmed dialog\n    if(this.dialog) {\n      this.dialog.terminate();\n      delete this.dialog;\n    }\n\n    // Terminate early dialogs\n    for(idx in this.earlyDialogs) {\n      this.earlyDialogs[idx].terminate();\n      delete this.earlyDialogs[idx];\n    }\n\n    this.status = C.STATUS_TERMINATED;\n\n    delete this.ua.sessions[this.id];\n    return this;\n  },\n\n  createDialog: function(message, type, early) {\n    var dialog, early_dialog,\n      local_tag = message[(type === 'UAS') ? 'to_tag' : 'from_tag'],\n      remote_tag = message[(type === 'UAS') ? 'from_tag' : 'to_tag'],\n      id = message.call_id + local_tag + remote_tag;\n\n    early_dialog = this.earlyDialogs[id];\n\n    // Early Dialog\n    if (early) {\n      if (early_dialog) {\n        return true;\n      } else {\n        early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY);\n\n        // Dialog has been successfully created.\n        if(early_dialog.error) {\n          this.logger.error(early_dialog.error);\n          this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n          return false;\n        } else {\n          this.earlyDialogs[id] = early_dialog;\n          return true;\n        }\n      }\n    }\n    // Confirmed Dialog\n    else {\n      // In case the dialog is in _early_ state, update it\n      if (early_dialog) {\n        early_dialog.update(message, type);\n        this.dialog = early_dialog;\n        delete this.earlyDialogs[id];\n        for (var dia in this.earlyDialogs) {\n          this.earlyDialogs[dia].terminate();\n          delete this.earlyDialogs[dia];\n        }\n        return true;\n      }\n\n      // Otherwise, create a _confirmed_ dialog\n      dialog = new SIP.Dialog(this, message, type);\n\n      if(dialog.error) {\n        this.logger.error(dialog.error);\n        this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n        return false;\n      } else {\n        this.to_tag = message.to_tag;\n        this.dialog = dialog;\n        return true;\n      }\n    }\n  },\n\n  /**\n  * Check if Session is ready for a re-INVITE\n  *\n  * @returns {Boolean}\n  */\n  isReadyToReinvite: function() {\n    return this.mediaHandler.isReady() &&\n      !this.dialog.uac_pending_reply &&\n      !this.dialog.uas_pending_reply;\n  },\n\n  /**\n   * Mute\n   */\n  mute: function(options) {\n    var ret = this.mediaHandler.mute(options);\n    if (ret) {\n      this.onmute(ret);\n    }\n  },\n\n  /**\n   * Unmute\n   */\n  unmute: function(options) {\n    var ret = this.mediaHandler.unmute(options);\n    if (ret) {\n      this.onunmute(ret);\n    }\n  },\n\n  /**\n   * Hold\n   */\n  hold: function() {\n\n    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n      throw new SIP.Exceptions.InvalidStateError(this.status);\n    }\n\n    this.mediaHandler.hold();\n\n    // Check if RTCSession is ready to send a reINVITE\n    if (!this.isReadyToReinvite()) {\n      /* If there is a pending 'unhold' action, cancel it and don't queue this one\n       * Else, if there isn't any 'hold' action, add this one to the queue\n       * Else, if there is already a 'hold' action, skip\n       */\n      if (this.pending_actions.isPending('unhold')) {\n        this.pending_actions.pop('unhold');\n      } else if (!this.pending_actions.isPending('hold')) {\n        this.pending_actions.push('hold');\n      }\n      return;\n    } else if (this.local_hold === true) {\n        return;\n    }\n\n    this.onhold('local');\n\n    this.sendReinvite({\n      mangle: function(body){\n\n        // Don't receive media\n        // TODO - This will break for media streams with different directions.\n        if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(body)) {\n          body = body.replace(/(m=[^\\r]*\\r\\n)/g, '$1a=sendonly\\r\\n');\n        } else {\n          body = body.replace(/a=sendrecv\\r\\n/g, 'a=sendonly\\r\\n');\n          body = body.replace(/a=recvonly\\r\\n/g, 'a=inactive\\r\\n');\n        }\n\n        return body;\n      }\n    });\n  },\n\n  /**\n   * Unhold\n   */\n  unhold: function() {\n\n    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n      throw new SIP.Exceptions.InvalidStateError(this.status);\n    }\n\n    this.mediaHandler.unhold();\n\n    if (!this.isReadyToReinvite()) {\n      /* If there is a pending 'hold' action, cancel it and don't queue this one\n       * Else, if there isn't any 'unhold' action, add this one to the queue\n       * Else, if there is already a 'unhold' action, skip\n       */\n      if (this.pending_actions.isPending('hold')) {\n        this.pending_actions.pop('hold');\n      } else if (!this.pending_actions.isPending('unhold')) {\n        this.pending_actions.push('unhold');\n      }\n      return;\n    } else if (this.local_hold === false) {\n      return;\n    }\n\n    this.onunhold('local');\n\n    this.sendReinvite();\n  },\n\n  /**\n   * isOnHold\n   */\n  isOnHold: function() {\n    return {\n      local: this.local_hold,\n      remote: this.remote_hold\n    };\n  },\n\n  /**\n   * In dialog INVITE Reception\n   * @private\n   */\n  receiveReinvite: function(request) {\n    var self = this,\n        contentType = request.getHeader('Content-Type'),\n        hold = true;\n\n    if (request.body) {\n      if (contentType !== 'application/sdp') {\n        this.logger.warn('invalid Content-Type');\n        request.reply(415);\n        return;\n      }\n\n      // Are we holding?\n      hold = (/a=(sendonly|inactive)/).test(request.body);\n\n      this.mediaHandler.setDescription(\n        request.body,\n        /*\n         * onSuccess\n         * SDP Offer is valid\n         */\n        function() {\n          self.mediaHandler.getDescription(\n            function(body) {\n              request.reply(200, null, ['Contact: ' + self.contact], body,\n                function() {\n                  self.status = C.STATUS_WAITING_FOR_ACK;\n                  self.setInvite2xxTimer(request, body);\n                  self.setACKTimer();\n\n                  if (self.remote_hold && !hold) {\n                    self.onunhold('remote');\n                  } else if (!self.remote_hold && hold) {\n                    self.onhold('remote');\n                  }\n                });\n            },\n            function() {\n              request.reply(500);\n            },\n            self.mediaHint\n          );\n        },\n        /*\n         * onFailure\n         * Bad media description\n         */\n        function(e) {\n          self.logger.error(e);\n          request.reply(488);\n        }\n      );\n    }\n  },\n\n  sendReinvite: function(options) {\n    options = options || {};\n\n    var\n      self = this,\n       extraHeaders = (options.extraHeaders || []).slice(),\n       eventHandlers = options.eventHandlers || {},\n       mangle = options.mangle || null;\n\n    if (eventHandlers.succeeded) {\n      this.reinviteSucceeded = eventHandlers.succeeded;\n    } else {\n      this.reinviteSucceeded = function(){\n        SIP.Timers.clearTimeout(self.timers.ackTimer);\n        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n        self.status = C.STATUS_CONFIRMED;\n      };\n    }\n    if (eventHandlers.failed) {\n      this.reinviteFailed = eventHandlers.failed;\n    } else {\n      this.reinviteFailed = function(){};\n    }\n\n    extraHeaders.push('Contact: ' + this.contact);\n    extraHeaders.push('Allow: '+ SIP.Utils.getAllowedMethods(this.ua));\n    extraHeaders.push('Content-Type: application/sdp');\n\n    this.receiveResponse = this.receiveReinviteResponse;\n    //REVISIT\n    this.mediaHandler.getDescription(\n      function(body){\n        if (mangle) {\n          body = mangle(body);\n        }\n\n        self.dialog.sendRequest(self, SIP.C.INVITE, {\n          extraHeaders: extraHeaders,\n          body: body\n        });\n      },\n      function() {\n        if (self.isReadyToReinvite()) {\n          self.onReadyToReinvite();\n        }\n        self.reinviteFailed();\n      },\n      self.mediaHint\n    );\n  },\n\n  receiveRequest: function (request) {\n    switch (request.method) {\n      case SIP.C.BYE:\n        request.reply(200);\n        if(this.status === C.STATUS_CONFIRMED) {\n          this.emit('bye', request);\n          this.terminated(request, SIP.C.causes.BYE);\n        }\n        break;\n      case SIP.C.INVITE:\n        if(this.status === C.STATUS_CONFIRMED) {\n          this.logger.log('re-INVITE received');\n          // Switch these two lines to try re-INVITEs:\n          //this.receiveReinvite(request);\n          request.reply(488, null, ['Warning: 399 sipjs \"Cannot update media description\"']);\n        }\n        break;\n      case SIP.C.INFO:\n        if(this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK) {\n          var body, tone, duration,\n              contentType = request.getHeader('content-type'),\n              reg_tone = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/,\n              reg_duration = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n\n          if (contentType) {\n            if (contentType.match(/^application\\/dtmf-relay/i)) {\n              if (request.body) {\n                body = request.body.split('\\r\\n', 2);\n                if (body.length === 2) {\n                  if (reg_tone.test(body[0])) {\n                    tone = body[0].replace(reg_tone,\"$2\");\n                  }\n                  if (reg_duration.test(body[1])) {\n                    duration = parseInt(body[1].replace(reg_duration,\"$2\"), 10);\n                  }\n                }\n              }\n\n              new DTMF(this, tone, {duration: duration}).init_incoming(request);\n            } else {\n              request.reply(415, null, [\"Accept: application/dtmf-relay\"]);\n            }\n          }\n        }\n        break;\n      case SIP.C.REFER:\n        if(this.status ===  C.STATUS_CONFIRMED) {\n          this.logger.log('REFER received');\n          request.reply(202, 'Accepted');\n          var\n            hasReferListener = this.checkListener('refer'),\n            notifyBody = hasReferListener ?\n              'SIP/2.0 100 Trying' :\n              // RFC 3515.2.4.2: 'the UA MAY decline the request.'\n              'SIP/2.0 603 Declined'\n          ;\n\n          this.sendRequest(SIP.C.NOTIFY, {\n            extraHeaders:[\n              'Event: refer',\n              'Subscription-State: terminated',\n              'Content-Type: message/sipfrag'\n            ],\n            body: notifyBody,\n            receiveResponse: function() {}\n          });\n\n          if (hasReferListener) {\n            this.emit('refer', request);\n          }\n        }\n        break;\n    }\n  },\n\n  /**\n   * Reception of Response for in-dialog INVITE\n   * @private\n   */\n  receiveReinviteResponse: function(response) {\n    var self = this,\n        contentType = response.getHeader('Content-Type');\n\n    if (this.status === C.STATUS_TERMINATED) {\n      return;\n    }\n\n    switch(true) {\n      case /^1[0-9]{2}$/.test(response.status_code):\n        break;\n      case /^2[0-9]{2}$/.test(response.status_code):\n        this.status = C.STATUS_CONFIRMED;\n\n        this.sendRequest(SIP.C.ACK,{cseq:response.cseq});\n\n        if(!response.body) {\n          this.reinviteFailed();\n          break;\n        } else if (contentType !== 'application/sdp') {\n          this.reinviteFailed();\n          break;\n        }\n\n        //REVISIT\n        this.mediaHandler.setDescription(\n          response.body,\n          /*\n           * onSuccess\n           * SDP Answer fits with Offer.\n           */\n          function() {\n            self.reinviteSucceeded();\n          },\n          /*\n           * onFailure\n           * SDP Answer does not fit the Offer.\n           */\n          function() {\n            self.reinviteFailed();\n          }\n        );\n        break;\n      default:\n        this.reinviteFailed();\n    }\n  },\n\n  acceptAndTerminate: function(response, status_code, reason_phrase) {\n    var extraHeaders = [];\n\n    if (status_code) {\n      reason_phrase = reason_phrase || SIP.C.REASON_PHRASE[status_code] || '';\n      extraHeaders.push('Reason: SIP ;cause=' + status_code + '; text=\"' + reason_phrase + '\"');\n    }\n\n    // An error on dialog creation will fire 'failed' event\n    if (this.dialog || this.createDialog(response, 'UAC')) {\n      this.sendRequest(SIP.C.ACK,{cseq: response.cseq});\n      this.sendRequest(SIP.C.BYE, {\n        extraHeaders: extraHeaders\n      });\n    }\n\n    return this;\n  },\n\n  /**\n   * RFC3261 13.3.1.4\n   * Response retransmissions cannot be accomplished by transaction layer\n   *  since it is destroyed when receiving the first 2xx answer\n   */\n  setInvite2xxTimer: function(request, body) {\n    var self = this,\n        timeout = SIP.Timers.T1;\n\n    this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {\n      if (self.status !== C.STATUS_WAITING_FOR_ACK) {\n        return;\n      }\n\n      self.logger.log('no ACK received, attempting to retransmit OK');\n\n      request.reply(200, null, ['Contact: ' + self.contact], body);\n\n      timeout = Math.min(timeout * 2, SIP.Timers.T2);\n\n      self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);\n    }, timeout);\n  },\n\n  /**\n   * RFC3261 14.2\n   * If a UAS generates a 2xx response and never receives an ACK,\n   *  it SHOULD generate a BYE to terminate the dialog.\n   */\n  setACKTimer: function() {\n    var self = this;\n\n    this.timers.ackTimer = SIP.Timers.setTimeout(function() {\n      if(self.status === C.STATUS_WAITING_FOR_ACK) {\n        self.logger.log('no ACK received for an extended period of time, terminating the call');\n        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n        self.sendRequest(SIP.C.BYE);\n        self.terminated(null, SIP.C.causes.NO_ACK);\n      }\n    }, SIP.Timers.TIMER_H);\n  },\n\n  /*\n   * @private\n   */\n  onReadyToReinvite: function() {\n    var action = this.pending_actions.shift();\n\n    if (!action || !this[action.name]) {\n      return;\n    }\n\n    this[action.name]();\n  },\n\n  onTransportError: function() {\n    if (this.status === C.STATUS_CONFIRMED) {\n      this.terminated(null, SIP.C.causes.CONNECTION_ERROR);\n    } else if (this.status !== C.STATUS_TERMINATED) {\n      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n    }\n  },\n\n  onRequestTimeout: function() {\n    if (this.status === C.STATUS_CONFIRMED) {\n      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n    } else if (this.status !== C.STATUS_TERMINATED) {\n      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n    }\n  },\n\n  onDialogError: function(response) {\n    if (this.status === C.STATUS_CONFIRMED) {\n      this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n    } else if (this.status !== C.STATUS_TERMINATED) {\n      this.failed(response, SIP.C.causes.DIALOG_ERROR);\n    }\n  },\n\n  /**\n   * @private\n   */\n  onhold: function(originator) {\n    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = true;\n    this.emit('hold', { originator: originator });\n  },\n\n  /**\n   * @private\n   */\n  onunhold: function(originator) {\n    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = false;\n    this.emit('unhold', { originator: originator });\n  },\n\n  /*\n   * @private\n   */\n  onmute: function(options) {\n    this.emit('muted', {\n      audio: options.audio,\n      video: options.video\n    });\n  },\n\n  /*\n   * @private\n   */\n  onunmute: function(options) {\n    this.emit('unmuted', {\n      audio: options.audio,\n      video: options.video\n    });\n  },\n\n  failed: function(response, cause) {\n    this.close();\n    return this.emit('failed', response, cause);\n  },\n\n  rejected: function(response, cause) {\n    this.close();\n    return this.emit('rejected',\n      response || null,\n      cause\n    );\n  },\n\n  canceled: function() {\n    this.close();\n    return this.emit('cancel');\n  },\n\n  accepted: function(response, cause) {\n    cause = cause || (response && SIP.C.REASON_PHRASE[response.status_code]) || '';\n\n    this.startTime = new Date();\n\n    return this.emit('accepted', response, cause);\n  },\n\n  terminated: function(message, cause) {\n    this.endTime = new Date();\n\n    this.close();\n    return this.emit('terminated', {\n      message: message || null,\n      cause: cause || null\n    });\n  },\n\n  connecting: function(request) {\n    return this.emit('connecting', { request: request });\n  }\n};\n\nSession.C = C;\nSIP.Session = Session;\n\n\nInviteServerContext = function(ua, request) {\n  var expires,\n    self = this,\n    contentType = request.getHeader('Content-Type'),\n    contentDisp = request.parseHeader('Content-Disposition');\n\n  // Check body and content type\n  if ((!contentDisp && contentType !== 'application/sdp') || (contentDisp && contentDisp.type === 'render')) {\n    this.renderbody = request.body;\n    this.rendertype = contentType;\n  } else if (contentType !== 'application/sdp' && (contentDisp && contentDisp.type === 'session')) {\n    request.reply(415);\n    //TODO: instead of 415, pass off to the media handler, who can then decide if we can use it\n    return;\n  }\n\n  //TODO: move this into media handler\n  SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);\n  SIP.Hacks.AllBrowsers.maskDtls(request);\n\n  SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);\n  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);\n\n  this.status = C.STATUS_INVITE_RECEIVED;\n  this.from_tag = request.from_tag;\n  this.id = request.call_id + this.from_tag;\n  this.request = request;\n  this.contact = this.ua.contact.toString();\n\n  this.receiveNonInviteResponse = function () {}; // intentional no-op\n\n  this.logger = ua.getLogger('sip.inviteservercontext', this.id);\n\n  //Save the session into the ua sessions collection.\n  this.ua.sessions[this.id] = this;\n\n  //Get the Expires header value if exists\n  if(request.hasHeader('expires')) {\n    expires = request.getHeader('expires') * 1000;\n  }\n\n  //Set 100rel if necessary\n  function set100rel(h,c) {\n    if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {\n      self.rel100 = c;\n    }\n  }\n  set100rel('require', SIP.C.supported.REQUIRED);\n  set100rel('supported', SIP.C.supported.SUPPORTED);\n\n  /* Set the to_tag before\n   * replying a response code that will create a dialog.\n   */\n  request.to_tag = SIP.Utils.newTag();\n\n  // An error on dialog creation will fire 'failed' event\n  if(!this.createDialog(request, 'UAS', true)) {\n    request.reply(500, 'Missing Contact header field');\n    return;\n  }\n\n  //Initialize Media Session\n  this.mediaHandler = this.mediaHandlerFactory(this, {\n    RTCConstraints: {\"optional\": [{'DtlsSrtpKeyAgreement': 'true'}]}\n  });\n\n  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n  }\n\n  function fireNewSession() {\n    var options = {extraHeaders: ['Contact: ' + self.contact]};\n\n    if (self.rel100 !== SIP.C.supported.REQUIRED) {\n      self.progress(options);\n    }\n    self.status = C.STATUS_WAITING_FOR_ANSWER;\n\n    // Set userNoAnswerTimer\n    self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function() {\n      request.reply(408);\n      self.failed(request, SIP.C.causes.NO_ANSWER);\n    }, self.ua.configuration.noAnswerTimeout);\n\n    /* Set expiresTimer\n     * RFC3261 13.3.1\n     */\n    if (expires) {\n      self.timers.expiresTimer = SIP.Timers.setTimeout(function() {\n        if(self.status === C.STATUS_WAITING_FOR_ANSWER) {\n          request.reply(487);\n          self.failed(request, SIP.C.causes.EXPIRES);\n        }\n      }, expires);\n    }\n\n    self.emit('invite',request);\n  }\n\n  if (!request.body || this.renderbody) {\n    SIP.Timers.setTimeout(fireNewSession, 0);\n  } else {\n    this.hasOffer = true;\n    this.mediaHandler.setDescription(\n      request.body,\n      /*\n       * onSuccess\n       * SDP Offer is valid. Fire UA newRTCSession\n       */\n      fireNewSession,\n      /*\n       * onFailure\n       * Bad media description\n       */\n      function(e) {\n        self.logger.warn('invalid SDP');\n        self.logger.warn(e);\n        request.reply(488);\n      }\n    );\n  }\n};\n\nInviteServerContext.prototype = {\n  reject: function(options) {\n    // Check Session Status\n    if (this.status === C.STATUS_TERMINATED) {\n      throw new SIP.Exceptions.InvalidStateError(this.status);\n    }\n\n    this.logger.log('rejecting RTCSession');\n\n    SIP.ServerContext.prototype.reject.apply(this, [options]);\n    return this.terminated();\n  },\n\n  terminate: function(options) {\n    options = options || {};\n\n    var\n    extraHeaders = (options.extraHeaders || []).slice(),\n    body = options.body,\n    dialog,\n    self = this;\n\n    if (this.status === C.STATUS_WAITING_FOR_ACK &&\n       this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n      dialog = this.dialog;\n\n      this.receiveRequest = function(request) {\n        if (request.method === SIP.C.ACK) {\n          this.request(SIP.C.BYE, {\n            extraHeaders: extraHeaders,\n            body: body\n          });\n          dialog.terminate();\n        }\n      };\n\n      this.request.server_transaction.on('stateChanged', function(){\n        if (this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n          this.request = new SIP.OutgoingRequest(\n            SIP.C.BYE,\n            this.dialog.remote_target,\n            this.ua,\n            {\n              'cseq': this.dialog.local_seqnum+=1,\n              'call_id': this.dialog.id.call_id,\n              'from_uri': this.dialog.local_uri,\n              'from_tag': this.dialog.id.local_tag,\n              'to_uri': this.dialog.remote_uri,\n              'to_tag': this.dialog.id.remote_tag,\n              'route_set': this.dialog.route_set\n            },\n            extraHeaders,\n            body\n          );\n\n          new SIP.RequestSender(\n            {\n              request: this.request,\n              onRequestTimeout: function() {\n                self.onRequestTimeout();\n              },\n              onTransportError: function() {\n                self.onTransportError();\n              },\n              receiveResponse: function() {\n                return;\n              }\n            },\n            this.ua\n          ).send();\n          dialog.terminate();\n        }\n      });\n\n      this.emit('bye', this.request);\n      this.terminated();\n\n      // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)\n      this.dialog = dialog;\n\n      // Restore the dialog into 'ua' so the ACK can reach 'this' session\n      this.ua.dialogs[dialog.id.toString()] = dialog;\n\n    } else if (this.status === C.STATUS_CONFIRMED) {\n      this.bye(options);\n    } else {\n      this.reject(options);\n    }\n\n    return this;\n  },\n\n  /*\n   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n   */\n  progress: function (options) {\n    options = options || {};\n    var\n      statusCode = options.statusCode || 180,\n      reasonPhrase = options.reasonPhrase,\n      extraHeaders = (options.extraHeaders || []).slice(),\n      body = options.body,\n      response;\n\n    if (statusCode < 100 || statusCode > 199) {\n      throw new TypeError('Invalid statusCode: ' + statusCode);\n    }\n\n    if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n      return this;\n    }\n\n    function do100rel() {\n      statusCode = options.statusCode || 183;\n\n      // Set status and add extra headers\n      this.status = C.STATUS_WAITING_FOR_PRACK;\n      extraHeaders.push('Contact: '+ this.contact);\n      extraHeaders.push('Require: 100rel');\n      extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000));\n\n      // Save media hint for later (referred sessions)\n      this.mediaHint = options.media;\n\n      // Get the session description to add to preaccept with\n      this.mediaHandler.getDescription(\n        // Success\n        function succ(body) {\n          if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n            return;\n          }\n\n          this.early_sdp = body;\n          this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true;\n\n          // Retransmit until we get a response or we time out (see prackTimer below)\n          var timeout = SIP.Timers.T1;\n          this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {\n            this.request.reply(statusCode, null, extraHeaders, body);\n            timeout *= 2;\n            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);\n          }.bind(this), timeout);\n\n          // Timeout and reject INVITE if no response\n          this.timers.prackTimer = SIP.Timers.setTimeout(function () {\n            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {\n              return;\n            }\n\n            this.logger.log('no PRACK received, rejecting the call');\n            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n            this.request.reply(504);\n            this.terminated(null, SIP.C.causes.NO_PRACK);\n          }.bind(this), SIP.Timers.T1 * 64);\n\n          // Send the initial response\n          response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n          this.emit('progress', response, reasonPhrase);\n        }.bind(this),\n\n        // Failure\n        function fail() {\n          this.failed(null, SIP.C.causes.WEBRTC_ERROR);\n        }.bind(this),\n\n        // Media hint:\n        options.media);\n    } // end do100rel\n\n    function normalReply() {\n      response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n      this.emit('progress', response, reasonPhrase);\n    }\n\n    if (options.statusCode !== 100 &&\n        (this.rel100 === SIP.C.supported.REQUIRED ||\n         (this.rel100 === SIP.C.supported.SUPPORTED && options.rel100) ||\n         (this.rel100 === SIP.C.supported.SUPPORTED && (this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)))) {\n      do100rel.apply(this);\n    } else {\n      normalReply.apply(this);\n    }\n    return this;\n  },\n\n  /*\n   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n   */\n  accept: function(options) {\n    options = options || {};\n    options = SIP.Utils.desugarSessionOptions(options);\n    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n    this.mediaHint = options.media;\n\n    // commented out now-unused hold-related variables for jshint. See below. JMF 2014-1-21\n    var\n      //idx, length, hasAudio, hasVideo,\n      self = this,\n      request = this.request,\n      extraHeaders = (options.extraHeaders || []).slice(),\n    //mediaStream = options.mediaStream || null,\n      sdpCreationSucceeded = function(body) {\n        var\n          response,\n          // run for reply success callback\n          replySucceeded = function() {\n            self.status = C.STATUS_WAITING_FOR_ACK;\n\n            self.setInvite2xxTimer(request, body);\n            self.setACKTimer();\n          },\n\n          // run for reply failure callback\n          replyFailed = function() {\n            self.failed(null, SIP.C.causes.CONNECTION_ERROR);\n          };\n\n        // Chrome might call onaddstream before accept() is called, which means\n        // mediaHandler.render() was called without a renderHint, so we need to\n        // re-render now that mediaHint.render has been set.\n        //\n        // Chrome seems to be in the right regarding this, see\n        // http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-onaddstream\n        self.mediaHandler.render();\n\n        extraHeaders.push('Contact: ' + self.contact);\n\n        if(!self.hasOffer) {\n          self.hasOffer = true;\n        } else {\n          self.hasAnswer = true;\n        }\n        response = request.reply(200, null, extraHeaders,\n                      body,\n                      replySucceeded,\n                      replyFailed\n                     );\n        if (self.status !== C.STATUS_TERMINATED) { // Didn't fail\n          self.accepted(response, SIP.C.REASON_PHRASE[200]);\n        }\n      },\n\n      sdpCreationFailed = function() {\n        if (self.status === C.STATUS_TERMINATED) {\n          return;\n        }\n        // TODO - fail out on error\n        //response = request.reply(480);\n        //self.failed(response, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n        self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n      };\n\n    // Check Session Status\n    if (this.status === C.STATUS_WAITING_FOR_PRACK) {\n      this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;\n      return this;\n    } else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {\n      this.status = C.STATUS_ANSWERED;\n    } else if (this.status !== C.STATUS_EARLY_MEDIA) {\n      throw new SIP.Exceptions.InvalidStateError(this.status);\n    }\n\n    // An error on dialog creation will fire 'failed' event\n    if(!this.createDialog(request, 'UAS')) {\n      request.reply(500, 'Missing Contact header field');\n      return this;\n    }\n\n    SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer);\n\n    // this hold-related code breaks FF accepting new calls - JMF 2014-1-21\n    /*\n    length = this.getRemoteStreams().length;\n\n    for (idx = 0; idx < length; idx++) {\n      if (this.mediaHandler.getRemoteStreams()[idx].getVideoTracks().length > 0) {\n        hasVideo = true;\n      }\n      if (this.mediaHandler.getRemoteStreams()[idx].getAudioTracks().length > 0) {\n        hasAudio = true;\n      }\n    }\n\n    if (!hasAudio && this.mediaConstraints.audio === true) {\n      this.mediaConstraints.audio = false;\n      if (mediaStream) {\n        length = mediaStream.getAudioTracks().length;\n        for (idx = 0; idx < length; idx++) {\n          mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);\n        }\n      }\n    }\n\n    if (!hasVideo && this.mediaConstraints.video === true) {\n      this.mediaConstraints.video = false;\n      if (mediaStream) {\n        length = mediaStream.getVideoTracks().length;\n        for (idx = 0; idx < length; idx++) {\n          mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);\n        }\n      }\n    }\n    */\n\n    if (this.status === C.STATUS_EARLY_MEDIA) {\n      sdpCreationSucceeded();\n    } else {\n      this.mediaHandler.getDescription(\n        sdpCreationSucceeded,\n        sdpCreationFailed,\n        self.mediaHint\n      );\n    }\n\n    return this;\n  },\n\n  receiveRequest: function(request) {\n\n    // ISC RECEIVE REQUEST\n\n    function confirmSession() {\n      var contentType;\n\n      SIP.Timers.clearTimeout(this.timers.ackTimer);\n      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n      this.status = C.STATUS_CONFIRMED;\n      this.unmute();\n\n      // TODO - this logic assumes Content-Disposition defaults\n      contentType = request.getHeader('Content-Type');\n      if (contentType !== 'application/sdp') {\n        this.renderbody = request.body;\n        this.rendertype = contentType;\n      }\n    }\n\n    switch(request.method) {\n    case SIP.C.CANCEL:\n      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL\n       * was in progress and that the UAC MAY continue with the session established by\n       * any 2xx response, or MAY terminate with BYE. SIP does continue with the\n       * established session. So the CANCEL is processed only if the session is not yet\n       * established.\n       */\n\n      /*\n       * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the\n       *request opening the session.\n       */\n      if(this.status === C.STATUS_WAITING_FOR_ANSWER ||\n         this.status === C.STATUS_WAITING_FOR_PRACK ||\n         this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||\n         this.status === C.STATUS_EARLY_MEDIA ||\n         this.status === C.STATUS_ANSWERED) {\n\n        this.status = C.STATUS_CANCELED;\n        this.request.reply(487);\n        this.canceled(request);\n        this.rejected(request, SIP.C.causes.CANCELED);\n        this.failed(request, SIP.C.causes.CANCELED);\n      }\n      break;\n    case SIP.C.ACK:\n      if(this.status === C.STATUS_WAITING_FOR_ACK) {\n        if (!this.hasAnswer) {\n          if(request.body && request.getHeader('content-type') === 'application/sdp') {\n            // ACK contains answer to an INVITE w/o SDP negotiation\n            SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);\n            SIP.Hacks.AllBrowsers.maskDtls(request);\n\n            this.hasAnswer = true;\n            this.mediaHandler.setDescription(\n              request.body,\n              /*\n               * onSuccess\n               * SDP Answer fits with Offer. Media will start\n               */\n              confirmSession.bind(this),\n              /*\n               * onFailure\n               * SDP Answer does not fit the Offer.  Terminate the call.\n               */\n              function (e) {\n                this.logger.warn(e);\n                this.terminate({\n                  statusCode: '488',\n                  reasonPhrase: 'Bad Media Description'\n                });\n                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n              }.bind(this)\n            );\n          } else if (this.early_sdp) {\n            confirmSession.apply(this);\n          } else {\n            //TODO: Pass to mediahandler\n            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n          }\n        } else {\n          confirmSession.apply(this);\n        }\n      }\n      break;\n    case SIP.C.PRACK:\n      if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n        //localMedia = session.mediaHandler.localMedia;\n        if(!this.hasAnswer) {\n          if(request.body && request.getHeader('content-type') === 'application/sdp') {\n            this.hasAnswer = true;\n            this.mediaHandler.setDescription(\n              request.body,\n              /*\n               * onSuccess\n               * SDP Answer fits with Offer. Media will start\n               */\n              function() {\n                SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n                SIP.Timers.clearTimeout(this.timers.prackTimer);\n                request.reply(200);\n                if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n                  this.status = C.STATUS_EARLY_MEDIA;\n                  this.accept();\n                }\n                this.status = C.STATUS_EARLY_MEDIA;\n                //REVISIT\n                this.mute();\n              }.bind(this),\n              function (e) {\n                //TODO: Send to media handler\n                this.logger.warn(e);\n                this.terminate({\n                  statusCode: '488',\n                  reasonPhrase: 'Bad Media Description'\n                });\n                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n              }.bind(this)\n            );\n          } else {\n            this.terminate({\n              statusCode: '488',\n              reasonPhrase: 'Bad Media Description'\n            });\n            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n          }\n        } else {\n          SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n          SIP.Timers.clearTimeout(this.timers.prackTimer);\n          request.reply(200);\n\n          if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n            this.status = C.STATUS_EARLY_MEDIA;\n            this.accept();\n          }\n          this.status = C.STATUS_EARLY_MEDIA;\n          //REVISIT\n          this.mute();\n        }\n      } else if(this.status === C.STATUS_EARLY_MEDIA) {\n        request.reply(200);\n      }\n      break;\n    default:\n      Session.prototype.receiveRequest.apply(this, [request]);\n      break;\n    }\n  }\n};\n\nSIP.InviteServerContext = InviteServerContext;\n\nInviteClientContext = function(ua, target, options) {\n  options = options || {};\n  var requestParams, iceServers,\n    extraHeaders = (options.extraHeaders || []).slice(),\n    stunServers = options.stunServers || null,\n    turnServers = options.turnServers || null,\n    isMediaSupported = ua.configuration.mediaHandlerFactory.isSupported;\n\n  // Check WebRTC support\n  if (isMediaSupported && !isMediaSupported()) {\n    throw new SIP.Exceptions.NotSupportedError('Media not supported');\n  }\n\n  this.RTCConstraints = options.RTCConstraints || {};\n  this.inviteWithoutSdp = options.inviteWithoutSdp || false;\n\n  // Set anonymous property\n  this.anonymous = options.anonymous || false;\n\n  // Custom data to be sent either in INVITE or in ACK\n  this.renderbody = options.renderbody || null;\n  this.rendertype = options.rendertype || 'text/plain';\n\n  requestParams = {from_tag: this.from_tag};\n\n  /* Do not add ;ob in initial forming dialog requests if the registration over\n   *  the current connection got a GRUU URI.\n   */\n  this.contact = ua.contact.toString({\n    anonymous: this.anonymous,\n    outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu\n  });\n\n  if (this.anonymous) {\n    requestParams.from_displayName = 'Anonymous';\n    requestParams.from_uri = 'sip:anonymous@anonymous.invalid';\n\n    extraHeaders.push('P-Preferred-Identity: '+ ua.configuration.uri.toString());\n    extraHeaders.push('Privacy: id');\n  }\n  extraHeaders.push('Contact: '+ this.contact);\n  extraHeaders.push('Allow: '+ SIP.Utils.getAllowedMethods(ua));\n  if (!this.inviteWithoutSdp) {\n    extraHeaders.push('Content-Type: application/sdp');\n  } else if (this.renderbody) {\n    extraHeaders.push('Content-Type: ' + this.rendertype);\n    extraHeaders.push('Content-Disposition: render;handling=optional');\n  }\n\n  if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {\n    extraHeaders.push('Require: 100rel');\n  }\n\n  options.extraHeaders = extraHeaders;\n  options.params = requestParams;\n\n  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);\n  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);\n\n  // Check Session Status\n  if (this.status !== C.STATUS_NULL) {\n    throw new SIP.Exceptions.InvalidStateError(this.status);\n  }\n\n  // Session parameter initialization\n  this.from_tag = SIP.Utils.newTag();\n\n  // OutgoingSession specific parameters\n  this.isCanceled = false;\n  this.received_100 = false;\n\n  this.method = SIP.C.INVITE;\n\n  this.receiveNonInviteResponse = this.receiveResponse;\n  this.receiveResponse = this.receiveInviteResponse;\n\n  this.logger = ua.getLogger('sip.inviteclientcontext');\n\n  if (stunServers) {\n    iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n    if (!iceServers) {\n      throw new TypeError('Invalid stunServers: '+ stunServers);\n    } else {\n      this.stunServers = iceServers;\n    }\n  }\n\n  if (turnServers) {\n    iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n    if (!iceServers) {\n      throw new TypeError('Invalid turnServers: '+ turnServers);\n    } else {\n      this.turnServers = iceServers;\n    }\n  }\n\n  ua.applicants[this] = this;\n\n  this.id = this.request.call_id + this.from_tag;\n\n  //Initialize Media Session\n  this.mediaHandler = this.mediaHandlerFactory(this, {\n    RTCConstraints: this.RTCConstraints,\n    stunServers: this.stunServers,\n    turnServers: this.turnServers\n  });\n\n  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n  }\n};\n\nInviteClientContext.prototype = {\n  /*\n   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n   */\n  invite: function (options) {\n    var self = this;\n    options = options || {};\n\n    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n    this.mediaHint = options.media;\n\n    //Save the session into the ua sessions collection.\n    //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway\n    this.ua.sessions[this.id] = this;\n\n    //Note: due to the way Firefox handles gUM calls, it is recommended to make the gUM call at the app level\n    // and hand sip.js a stream as the mediaHint\n    if (this.inviteWithoutSdp) {\n      //just send an invite with no sdp...\n      this.request.body = self.renderbody;\n      this.status = C.STATUS_INVITE_SENT;\n      this.send();\n    } else {\n      this.mediaHandler.getDescription(\n        function onSuccess(offer) {\n          if (self.isCanceled || self.status === C.STATUS_TERMINATED) {\n            return;\n          }\n          self.hasOffer = true;\n          self.request.body = offer;\n          self.status = C.STATUS_INVITE_SENT;\n          self.send();\n        },\n        function onFailure() {\n          if (self.status === C.STATUS_TERMINATED) {\n            return;\n          }\n          // TODO...fail out\n          //self.failed(null, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n          //self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n          self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n        },\n        self.mediaHint\n      );\n    }\n\n    return this;\n  },\n\n  receiveInviteResponse: function(response) {\n    var cause, //localMedia,\n      session = this,\n      id = response.call_id + response.from_tag + response.to_tag,\n      extraHeaders = [],\n      options = {};\n\n    if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {\n      return;\n    }\n\n    if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {\n      if (id !== this.dialog.id.toString() ) {\n        if (!this.createDialog(response, 'UAC', true)) {\n          return;\n        }\n        this.earlyDialogs[id].sendRequest(this, SIP.C.ACK,\n                                          {\n                                            body: SIP.Utils.generateFakeSDP(response.body)\n                                          });\n        this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);\n\n        /* NOTE: This fails because the forking proxy does not recognize that an unanswerable\n         * leg (due to peerConnection limitations) has been answered first. If your forking\n         * proxy does not hang up all unanswered branches on the first branch answered, remove this.\n         */\n        if(this.status !== C.STATUS_CONFIRMED) {\n          this.failed(response, SIP.C.causes.WEBRTC_ERROR);\n        }\n        return;\n      } else if (this.status === C.STATUS_CONFIRMED) {\n        this.sendRequest(SIP.C.ACK,{cseq: response.cseq});\n        return;\n      } else if (!this.hasAnswer) {\n        // invite w/o sdp is waiting for callback\n        //an invite with sdp must go on, and hasAnswer is true\n        return;\n      }\n    }\n\n    if (this.dialog && response.status_code < 200) {\n      /*\n        Early media has been set up with at least one other different branch,\n        but a final 2xx response hasn't been received\n      */\n      if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {\n        return;\n      }\n\n      extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n      this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n\n      this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n        extraHeaders: extraHeaders,\n        body: SIP.Utils.generateFakeSDP(response.body)\n      });\n      return;\n    }\n\n    // Proceed to cancellation if the user requested.\n    if(this.isCanceled) {\n      if(response.status_code >= 100 && response.status_code < 200) {\n        this.request.cancel(this.cancelReason);\n        this.canceled(null);\n      } else if(response.status_code >= 200 && response.status_code < 299) {\n        this.acceptAndTerminate(response);\n        this.emit('bye', this.request);\n      }\n      return;\n    }\n\n    switch(true) {\n      case /^100$/.test(response.status_code):\n        this.received_100 = true;\n        break;\n      case (/^1[0-9]{2}$/.test(response.status_code)):\n        // Do nothing with 1xx responses without To tag.\n        if(!response.to_tag) {\n          this.logger.warn('1xx response received without to tag');\n          break;\n        }\n\n        // Create Early Dialog if 1XX comes with contact\n        if(response.hasHeader('contact')) {\n          // An error on dialog creation will fire 'failed' event\n          if (!this.createDialog(response, 'UAC', true)) {\n            break;\n          }\n        }\n\n        this.status = C.STATUS_1XX_RECEIVED;\n\n        if(response.hasHeader('require') &&\n           response.getHeader('require').indexOf('100rel') !== -1) {\n\n          // Do nothing if this.dialog is already confirmed\n          if (this.dialog || !this.earlyDialogs[id]) {\n            break;\n          }\n\n          if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n              (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {\n            return;\n          }\n\n          SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);\n          SIP.Hacks.AllBrowsers.maskDtls(response);\n\n          if (!response.body) {\n            extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n            this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n              extraHeaders: extraHeaders\n            });\n            this.emit('progress', response);\n\n          } else if (this.hasOffer) {\n            if (!this.createDialog(response, 'UAC')) {\n              break;\n            }\n            this.hasAnswer = true;\n            this.mediaHandler.setDescription(\n              response.body,\n              /*\n               * onSuccess\n               * SDP Answer fits with Offer. Media will start\n               */\n              function () {\n                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n                session.dialog.pracked.push(response.getHeader('rseq'));\n\n                session.sendRequest(SIP.C.PRACK, {\n                  extraHeaders: extraHeaders,\n                  receiveResponse: function() {}\n                });\n                session.status = C.STATUS_EARLY_MEDIA;\n                session.mute();\n                session.emit('progress', response);\n                /*\n                if (session.status === C.STATUS_EARLY_MEDIA) {\n                  localMedia = session.mediaHandler.localMedia;\n                  if (localMedia.getAudioTracks().length > 0) {\n                    localMedia.getAudioTracks()[0].enabled = false;\n                  }\n                  if (localMedia.getVideoTracks().length > 0) {\n                    localMedia.getVideoTracks()[0].enabled = false;\n                  }\n                }*/\n              },\n              /*\n               * onFailure\n               * SDP Answer does not fit the Offer. Accept the call and Terminate.\n               */\n              function(e) {\n                session.logger.warn(e);\n                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n              }\n            );\n          } else {\n            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n            this.earlyDialogs[id].mediaHandler.setDescription(\n              response.body,\n              function onSuccess() {\n                session.earlyDialogs[id].mediaHandler.getDescription(\n                  function onSuccess(sdp) {\n                    extraHeaders.push('Content-Type: application/sdp');\n                    extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n                    session.earlyDialogs[id].sendRequest(session, SIP.C.PRACK, {\n                      extraHeaders: extraHeaders,\n                      body: sdp\n                    });\n                    session.status = C.STATUS_EARLY_MEDIA;\n                    session.emit('progress', response);\n                  },\n                  function onFailure() {\n                    session.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n                    if (session.status === C.STATUS_TERMINATED) {\n                      return;\n                    }\n                    // TODO - fail out on error\n                    // session.failed(gum error);\n                    session.failed(null, SIP.C.causes.WEBRTC_ERROR);\n                  },\n                  session.mediaHint\n                );\n              },\n              function onFailure(e) {\n                session.earlyDialogs[id].pracked.splice(session.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')), 1);\n                // Could not set remote description\n                session.logger.warn('invalid SDP');\n                session.logger.warn(e);\n              }\n            );\n          }\n        } else {\n          this.emit('progress', response);\n        }\n        break;\n      case /^2[0-9]{2}$/.test(response.status_code):\n        var cseq = this.request.cseq + ' ' + this.request.method;\n        if (cseq !== response.getHeader('cseq')) {\n          break;\n        }\n\n        if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {\n          this.status = C.STATUS_CONFIRMED;\n          this.unmute();\n          /*localMedia = this.mediaHandler.localMedia;\n          if (localMedia.getAudioTracks().length > 0) {\n            localMedia.getAudioTracks()[0].enabled = true;\n          }\n          if (localMedia.getVideoTracks().length > 0) {\n            localMedia.getVideoTracks()[0].enabled = true;\n          }*/\n          options = {};\n          if (this.renderbody) {\n            extraHeaders.push('Content-Type: ' + this.rendertype);\n            options.extraHeaders = extraHeaders;\n            options.body = this.renderbody;\n          }\n          options.cseq = response.cseq;\n          this.sendRequest(SIP.C.ACK, options);\n          this.accepted(response);\n          break;\n        }\n        // Do nothing if this.dialog is already confirmed\n        if (this.dialog) {\n          break;\n        }\n\n        SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);\n        SIP.Hacks.AllBrowsers.maskDtls(response);\n\n        // This is an invite without sdp\n        if (!this.hasOffer) {\n          if (this.earlyDialogs[id] && this.earlyDialogs[id].mediaHandler.localMedia) {\n            //REVISIT\n            this.hasOffer = true;\n            this.hasAnswer = true;\n            this.mediaHandler = this.earlyDialogs[id].mediaHandler;\n            if (!this.createDialog(response, 'UAC')) {\n              break;\n            }\n            this.status = C.STATUS_CONFIRMED;\n            this.sendRequest(SIP.C.ACK, {cseq:response.cseq});\n\n            this.unmute();\n            /*\n            localMedia = session.mediaHandler.localMedia;\n            if (localMedia.getAudioTracks().length > 0) {\n              localMedia.getAudioTracks()[0].enabled = true;\n            }\n            if (localMedia.getVideoTracks().length > 0) {\n              localMedia.getVideoTracks()[0].enabled = true;\n            }*/\n            this.accepted(response);\n          } else {\n            if(!response.body) {\n              this.acceptAndTerminate(response, 400, 'Missing session description');\n              this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n              break;\n            }\n            if (!this.createDialog(response, 'UAC')) {\n              break;\n            }\n            this.hasOffer = true;\n            this.mediaHandler.setDescription(\n              response.body,\n              function onSuccess() {\n                session.mediaHandler.getDescription(\n                  function onSuccess(sdp) {\n                    //var localMedia;\n                    if(session.isCanceled || session.status === C.STATUS_TERMINATED) {\n                      return;\n                    }\n\n                    sdp = SIP.Hacks.Firefox.hasMissingCLineInSDP(sdp);\n\n                    session.status = C.STATUS_CONFIRMED;\n                    session.hasAnswer = true;\n\n                    session.unmute();\n                    /*localMedia = session.mediaHandler.localMedia;\n                    if (localMedia.getAudioTracks().length > 0) {\n                      localMedia.getAudioTracks()[0].enabled = true;\n                    }\n                    if (localMedia.getVideoTracks().length > 0) {\n                      localMedia.getVideoTracks()[0].enabled = true;\n                    }*/\n                    session.sendRequest(SIP.C.ACK,{\n                      body: sdp,\n                      extraHeaders:['Content-Type: application/sdp'],\n                      cseq:response.cseq\n                    });\n                    session.accepted(response);\n                  },\n                  function onFailure() {\n                    // TODO do something here\n                    session.logger.warn(\"there was a problem\");\n                  },\n                  session.mediaHint\n                );\n              },\n              function onFailure(e) {\n                session.logger.warn('invalid SDP');\n                session.logger.warn(e);\n                response.reply(488);\n              }\n            );\n          }\n        } else if (this.hasAnswer){\n          if (this.renderbody) {\n            extraHeaders.push('Content-Type: ' + session.rendertype);\n            options.extraHeaders = extraHeaders;\n            options.body = this.renderbody;\n          }\n          this.sendRequest(SIP.C.ACK, options);\n        } else {\n          if(!response.body) {\n            this.acceptAndTerminate(response, 400, 'Missing session description');\n            this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n            break;\n          }\n          if (!this.createDialog(response, 'UAC')) {\n            break;\n          }\n          this.hasAnswer = true;\n          this.mediaHandler.setDescription(\n            response.body,\n            /*\n             * onSuccess\n             * SDP Answer fits with Offer. Media will start\n             */\n            function() {\n              var options = {};//,localMedia;\n              session.status = C.STATUS_CONFIRMED;\n              session.unmute();\n              /*localMedia = session.mediaHandler.localMedia;\n              if (localMedia.getAudioTracks().length > 0) {\n                localMedia.getAudioTracks()[0].enabled = true;\n              }\n              if (localMedia.getVideoTracks().length > 0) {\n                localMedia.getVideoTracks()[0].enabled = true;\n              }*/\n              if (session.renderbody) {\n                extraHeaders.push('Content-Type: ' + session.rendertype);\n                options.extraHeaders = extraHeaders;\n                options.body = session.renderbody;\n              }\n              options.cseq = response.cseq;\n              session.sendRequest(SIP.C.ACK, options);\n              session.accepted(response);\n            },\n            /*\n             * onFailure\n             * SDP Answer does not fit the Offer. Accept the call and Terminate.\n             */\n            function(e) {\n              session.logger.warn(e);\n              session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n              session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n            }\n          );\n        }\n        break;\n      default:\n        cause = SIP.Utils.sipErrorCause(response.status_code);\n        this.failed(response, cause);\n        this.rejected(response, cause);\n    }\n  },\n\n  cancel: function(options) {\n    options = options || {};\n\n    var\n    statusCode = options.status_code,\n    reasonPhrase = options.reasonPhrase,\n    cancel_reason;\n\n    // Check Session Status\n    if (this.status === C.STATUS_TERMINATED) {\n      throw new SIP.Exceptions.InvalidStateError(this.status);\n    }\n\n    this.logger.log('canceling RTCSession');\n\n    if (statusCode && (statusCode < 200 || statusCode >= 700)) {\n      throw new TypeError('Invalid status_code: '+ statusCode);\n    } else if (statusCode) {\n      reasonPhrase = reasonPhrase || SIP.C.REASON_PHRASE[statusCode] || '';\n      cancel_reason = 'SIP ;cause=' + statusCode + ' ;text=\"' + reasonPhrase + '\"';\n    }\n\n    // Check Session Status\n    if (this.status === C.STATUS_NULL ||\n        (this.status === C.STATUS_INVITE_SENT && !this.received_100)) {\n      this.isCanceled = true;\n      this.cancelReason = cancel_reason;\n    } else if (this.status === C.STATUS_INVITE_SENT ||\n               this.status === C.STATUS_1XX_RECEIVED ||\n               this.status === C.STATUS_EARLY_MEDIA) {\n      this.request.cancel(cancel_reason);\n    }\n\n    return this.canceled();\n  },\n\n  terminate: function(options) {\n    if (this.status === C.STATUS_TERMINATED) {\n      return this;\n    }\n\n    if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {\n      this.bye(options);\n    } else {\n      this.cancel(options);\n    }\n\n    return this.terminated();\n  },\n\n  receiveRequest: function(request) {\n    // ICC RECEIVE REQUEST\n\n    // Reject CANCELs\n    if (request.method === SIP.C.CANCEL) {\n      // TODO; make this a switch when it gets added\n    }\n\n    if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {\n      SIP.Timers.clearTimeout(this.timers.ackTimer);\n      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n      this.status = C.STATUS_CONFIRMED;\n      this.unmute();\n\n      this.accepted();\n    }\n\n    return Session.prototype.receiveRequest.apply(this, [request]);\n  }\n};\n\nSIP.InviteClientContext = InviteClientContext;\n\n};\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\n/**\n * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)\n */\n\n/**\n * @augments SIP\n * @class Class creating a SIP Subscription.\n */\nmodule.exports = function (SIP) {\nSIP.Subscription = function (ua, target, event, options) {\n  var events;\n\n  options = options || {};\n  options.extraHeaders = (options.extraHeaders || []).slice();\n\n  events = ['notify'];\n  this.id = null;\n  this.state = 'init';\n\n  if (!event) {\n    throw new TypeError('Event necessary to create a subscription.');\n  } else {\n    //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?\n    //The check may need to/should probably occur on the other side,\n    this.event = event;\n  }\n\n  if(typeof options.expires !== 'number'){\n    ua.logger.warn('expires must be a number. Using default of 3600.');\n    this.expires = 3600;\n  } else {\n    this.expires = options.expires;\n  }\n\n  options.extraHeaders.push('Event: ' + this.event);\n  options.extraHeaders.push('Expires: ' + this.expires);\n\n  if (options.body) {\n    this.body = options.body;\n  }\n\n  this.contact = ua.contact.toString();\n\n  options.extraHeaders.push('Contact: '+ this.contact);\n  options.extraHeaders.push('Allow: '+ SIP.Utils.getAllowedMethods(ua));\n\n  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);\n\n  this.logger = ua.getLogger('sip.subscription');\n\n  this.dialog = null;\n  this.timers = {N: null, sub_duration: null};\n  this.errorCodes  = [404,405,410,416,480,481,482,483,484,485,489,501,604];\n\n  this.initMoreEvents(events);\n};\n\nSIP.Subscription.prototype = {\n  subscribe: function() {\n    var sub = this;\n\n    SIP.Timers.clearTimeout(this.timers.sub_duration);\n    SIP.Timers.clearTimeout(this.timers.N);\n    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n\n    this.send();\n\n    this.state = 'notify_wait';\n\n    return this;\n  },\n\n  receiveResponse: function(response) {\n    var expires, sub = this,\n        cause = SIP.C.REASON_PHRASE[response.status_code] || '';\n\n    if (this.errorCodes.indexOf(response.status_code) !== -1) {\n      this.failed(response, null);\n    } else if (/^2[0-9]{2}$/.test(response.status_code)){\n      expires = response.getHeader('Expires');\n      SIP.Timers.clearTimeout(this.timers.N);\n\n      if (this.createConfirmedDialog(response,'UAC')) {\n        this.id = this.dialog.id.toString();\n        this.ua.subscriptions[this.id] = this;\n        this.emit('accepted', response, cause);\n        // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?\n      }\n\n      if (expires && expires <= this.expires) {\n        this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), expires * 1000);\n      } else {\n        if (!expires) {\n          this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');\n          this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);\n        } else {\n          this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');\n          this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);\n        }\n      }\n    } //Used to just ignore provisional responses; now ignores everything except errorCodes and 2xx\n  },\n\n  unsubscribe: function() {\n    var extraHeaders = [], sub = this;\n\n    this.state = 'terminated';\n\n    extraHeaders.push('Event: ' + this.event);\n    extraHeaders.push('Expires: 0');\n\n    extraHeaders.push('Contact: '+ this.contact);\n    extraHeaders.push('Allow: '+ SIP.Utils.getAllowedMethods(this.ua));\n\n    this.request = new SIP.OutgoingRequest(this.method, this.request.to.uri.toString(), this.ua, null, extraHeaders);\n\n    //MAYBE, may want to see state\n    this.receiveResponse = function(){};\n\n    SIP.Timers.clearTimeout(this.timers.sub_duration);\n    SIP.Timers.clearTimeout(this.timers.N);\n    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n\n    this.send();\n  },\n\n  /**\n  * @private\n  */\n  timer_fire: function(){\n    if (this.state === 'terminated') {\n      this.close();\n    } else if (this.state === 'pending' || this.state === 'notify_wait') {\n      this.state = 'terminated';\n      this.close();\n    } else {\n      this.subscribe();\n    }\n  },\n\n  /**\n  * @private\n  */\n  close: function() {\n    if(this.state !== 'terminated') {\n      this.unsubscribe();\n    }\n\n    this.terminateDialog();\n    SIP.Timers.clearTimeout(this.timers.N);\n    SIP.Timers.clearTimeout(this.timers.sub_duration);\n\n    delete this.ua.subscriptions[this.id];\n  },\n\n  /**\n  * @private\n  */\n  createConfirmedDialog: function(message, type) {\n    var dialog;\n\n    this.terminateDialog();\n    dialog = new SIP.Dialog(this, message, type);\n\n    if(!dialog.error) {\n      this.dialog = dialog;\n      return true;\n    }\n    // Dialog not created due to an error\n    else {\n      return false;\n    }\n  },\n\n  /**\n  * @private\n  */\n  terminateDialog: function() {\n    if(this.dialog) {\n      delete this.ua.subscriptions[this.id];\n      this.dialog.terminate();\n      delete this.dialog;\n    }\n  },\n\n  /**\n  * @private\n  */\n  receiveRequest: function(request) {\n    var sub_state, sub = this;\n\n    function setExpiresTimeout() {\n      if (sub_state.expires) {\n        sub_state.expires = Math.min(sub.expires,\n                                     Math.max(sub_state.expires, 0));\n        sub.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub),\n                                                    sub_state.expires * 1000);\n      }\n    }\n\n    if (!this.matchEvent(request)) { //checks event and subscription_state headers\n      request.reply(489);\n      return;\n    }\n\n    sub_state = request.parseHeader('Subscription-State');\n\n    request.reply(200, SIP.C.REASON_200);\n\n    SIP.Timers.clearTimeout(this.timers.N);\n    SIP.Timers.clearTimeout(this.timers.sub_duration);\n\n    this.emit('notify', {request: request});\n\n    switch (sub_state.state) {\n      case 'active':\n        this.state = 'active';\n        setExpiresTimeout();\n        break;\n      case 'pending':\n        if (this.state === 'notify_wait') {\n          setExpiresTimeout();\n        }\n        this.state = 'pending';\n        break;\n      case 'terminated':\n        if (sub_state.reason) {\n          this.logger.log('terminating subscription with reason '+ sub_state.reason);\n          switch (sub_state.reason) {\n            case 'deactivated':\n            case 'timeout':\n              this.subscribe();\n              return;\n            case 'probation':\n            case 'giveup':\n              if(sub_state.params && sub_state.params['retry-after']) {\n                this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);\n              } else {\n                this.subscribe();\n              }\n              return;\n            case 'rejected':\n            case 'noresource':\n            case 'invariant':\n              break;\n          }\n        }\n        this.close();\n        break;\n    }\n  },\n\n  failed: function(response, cause) {\n    this.close();\n    return this.emit('failed', response, cause);\n  },\n\n  /**\n  * @private\n  */\n  matchEvent: function(request) {\n    var event;\n\n    // Check mandatory header Event\n    if (!request.hasHeader('Event')) {\n      this.logger.warn('missing Event header');\n      return false;\n    }\n    // Check mandatory header Subscription-State\n    if (!request.hasHeader('Subscription-State')) {\n      this.logger.warn('missing Subscription-State header');\n      return false;\n    }\n\n    // Check whether the event in NOTIFY matches the event in SUBSCRIBE\n    event = request.parseHeader('event').event;\n\n    if (this.event !== event) {\n      this.logger.warn('event match failed');\n      request.reply(481, 'Event Match Failed');\n      return false;\n    } else {\n      return true;\n    }\n  }\n};\n};\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview MediaHandler\n */\n\n/* MediaHandler\n * @class PeerConnection helper Class.\n * @param {SIP.Session} session\n * @param {Object} [options]\n * @param {SIP.WebRTC.MediaStreamManager} [options.mediaStreamManager]\n *        The MediaStreamManager to acquire/release streams from/to.\n *        If not provided, a default MediaStreamManager will be used.\n */\nmodule.exports = function (SIP) {\n\nvar MediaHandler = function(session, options) {\n  var events = [\n    'userMediaRequest',\n    'userMedia',\n    'userMediaFailed',\n    'iceGathering',\n    'iceCandidate',\n    'iceComplete',\n    'iceFailed',\n    'getDescription',\n    'setDescription',\n    'dataChannel',\n    'addStream'\n  ];\n  options = options || {};\n\n  this.logger = session.ua.getLogger('sip.invitecontext.mediahandler', session.id);\n  this.session = session;\n  this.localMedia = null;\n  this.ready = true;\n  this.mediaStreamManager = options.mediaStreamManager || new SIP.WebRTC.MediaStreamManager(this.logger);\n  this.audioMuted = false;\n  this.videoMuted = false;\n\n  // old init() from here on\n  var idx, length, server,\n    self = this,\n    servers = [],\n    stunServers = options.stunServers || null,\n    turnServers = options.turnServers || null,\n    config = this.session.ua.configuration;\n  this.RTCConstraints = options.RTCConstraints || {};\n\n  if (!stunServers) {\n    stunServers = config.stunServers;\n  }\n\n  if(!turnServers) {\n    turnServers = config.turnServers;\n  }\n\n  /* Change 'url' to 'urls' whenever this issue is solved:\n   * https://code.google.com/p/webrtc/issues/detail?id=2096\n   */\n  [].concat(stunServers).forEach(function (server) {\n    servers.push({'url': server});\n  });\n\n  length = turnServers.length;\n  for (idx = 0; idx < length; idx++) {\n    server = turnServers[idx];\n    servers.push({\n      'url': server.urls,\n      'username': server.username,\n      'credential': server.password\n    });\n  }\n\n  this.peerConnection = new SIP.WebRTC.RTCPeerConnection({'iceServers': servers}, this.RTCConstraints);\n\n  this.peerConnection.onaddstream = function(e) {\n    self.logger.log('stream added: '+ e.stream.id);\n    self.render();\n    self.emit('addStream', e);\n  };\n\n  this.peerConnection.onremovestream = function(e) {\n    self.logger.log('stream removed: '+ e.stream.id);\n  };\n\n  this.peerConnection.onicecandidate = function(e) {\n    self.emit('iceCandidate', e);\n    if (e.candidate) {\n      self.logger.log('ICE candidate received: '+ (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));\n    } else if (self.onIceCompleted !== undefined) {\n      self.onIceCompleted(this);\n    } else {\n      self.callOnIceCompleted = true;\n    }\n  };\n\n  this.peerConnection.onicegatheringstatechange = function () {\n    self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);\n    if (this.iceGatheringState === 'gathering') {\n      self.emit('iceGathering', this);\n    }\n    if (this.iceGatheringState === 'complete') {\n      if (self.onIceCompleted !== undefined) {\n        self.onIceCompleted(this);\n      } else {\n        self.callOnIceCompleted = true;\n      }\n    }\n  };\n\n  this.peerConnection.oniceconnectionstatechange = function() {  //need e for commented out case\n    self.logger.log('ICE connection state changed to \"'+ this.iceConnectionState +'\"');\n\n    if (this.iceConnectionState === 'failed') {\n      self.emit('iceFailed', this);\n    }\n\n    //Bria state changes are always connected -> disconnected -> connected on accept, so session gets terminated\n    //normal calls switch from failed to connected in some cases, so checking for failed and terminated\n    /*if (this.iceConnectionState === 'failed') {\n      self.session.terminate({\n        cause: SIP.C.causes.RTP_TIMEOUT,\n        status_code: 200,\n        reason_phrase: SIP.C.causes.RTP_TIMEOUT\n      });\n    } else if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {\n      self.onIceCompleted(this);\n    }*/\n  };\n\n  this.peerConnection.onstatechange = function() {\n    self.logger.log('PeerConnection state changed to \"'+ this.readyState +'\"');\n  };\n\n  this.initEvents(events);\n\n  function selfEmit(mh, event) {\n    if (mh.mediaStreamManager.on &&\n        mh.mediaStreamManager.checkEvent &&\n        mh.mediaStreamManager.checkEvent(event)) {\n      mh.mediaStreamManager.on(event, function () {\n        mh.emit.apply(mh, [event].concat(Array.prototype.slice.call(arguments)));\n      });\n    }\n  }\n\n  selfEmit(this, 'userMediaRequest');\n  selfEmit(this, 'userMedia');\n  selfEmit(this, 'userMediaFailed');\n};\n\nMediaHandler.defaultFactory = function defaultFactory (session, options) {\n  return new MediaHandler(session, options);\n};\nMediaHandler.defaultFactory.isSupported = function () {\n  return SIP.WebRTC.isSupported();\n};\n\nMediaHandler.prototype = Object.create(SIP.MediaHandler.prototype, {\n// Functions the session can use\n  isReady: {writable: true, value: function isReady () {\n    return this.ready;\n  }},\n\n  close: {writable: true, value: function close () {\n    this.logger.log('closing PeerConnection');\n    // have to check signalingState since this.close() gets called multiple times\n    // TODO figure out why that happens\n    if(this.peerConnection && this.peerConnection.signalingState !== 'closed') {\n      this.peerConnection.close();\n\n      if(this.localMedia) {\n        this.mediaStreamManager.release(this.localMedia);\n      }\n    }\n  }},\n\n  /**\n   * @param {Function} onSuccess\n   * @param {Function} onFailure\n   * @param {SIP.WebRTC.MediaStream | (getUserMedia constraints)} [mediaHint]\n   *        the MediaStream (or the constraints describing it) to be used for the session\n   */\n  getDescription: {writable: true, value: function getDescription (onSuccess, onFailure, mediaHint) {\n    var self = this;\n    mediaHint = mediaHint || {};\n    if (mediaHint.dataChannel === true) {\n      mediaHint.dataChannel = {};\n    }\n    this.mediaHint = mediaHint;\n\n    /*\n     * 1. acquire stream (skip if MediaStream passed in)\n     * 2. addStream\n     * 3. createOffer/createAnswer\n     * 4. call onSuccess()\n     */\n\n    /* Last functions first, to quiet JSLint */\n    function streamAdditionSucceeded() {\n      if (self.hasOffer('remote')) {\n        self.peerConnection.ondatachannel = function (evt) {\n          self.dataChannel = evt.channel;\n          self.emit('dataChannel', self.dataChannel);\n        };\n      } else if (mediaHint.dataChannel &&\n                 self.peerConnection.createDataChannel) {\n        self.dataChannel = self.peerConnection.createDataChannel(\n          'sipjs',\n          mediaHint.dataChannel\n        );\n        self.emit('dataChannel', self.dataChannel);\n      }\n\n      self.render();\n      self.createOfferOrAnswer(onSuccess, onFailure, self.RTCConstraints);\n    }\n\n    function acquireSucceeded(stream) {\n      self.logger.log('acquired local media stream');\n      self.localMedia = stream;\n      self.session.connecting();\n      self.addStream(\n        stream,\n        streamAdditionSucceeded,\n        onFailure\n      );\n    }\n\n    if (self.localMedia) {\n      self.logger.log('already have local media');\n      streamAdditionSucceeded();\n      return;\n    }\n\n    self.logger.log('acquiring local media');\n    self.mediaStreamManager.acquire(\n      acquireSucceeded,\n      function acquireFailed(err) {\n        self.logger.error('unable to acquire stream');\n        self.logger.error(err);\n        self.session.connecting();\n        onFailure(err);\n      },\n      mediaHint\n    );\n  }},\n\n  /**\n  * Message reception.\n  * @param {String} type\n  * @param {String} sdp\n  * @param {Function} onSuccess\n  * @param {Function} onFailure\n  */\n  setDescription: {writable: true, value: function setDescription (sdp, onSuccess, onFailure) {\n    var rawDescription = {\n      type: this.hasOffer('local') ? 'answer' : 'offer',\n      sdp: sdp\n    };\n\n    this.emit('setDescription', rawDescription);\n\n    var description = new SIP.WebRTC.RTCSessionDescription(rawDescription);\n    this.peerConnection.setRemoteDescription(description, onSuccess, onFailure);\n  }},\n\n// Functions the session can use, but only because it's convenient for the application\n  isMuted: {writable: true, value: function isMuted () {\n    return {\n      audio: this.audioMuted,\n      video: this.videoMuted\n    };\n  }},\n\n  mute: {writable: true, value: function mute (options) {\n    if (this.getLocalStreams().length === 0) {\n      return;\n    }\n\n    options = options || {\n      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n      video: this.getLocalStreams()[0].getVideoTracks().length > 0\n    };\n\n    var audioMuted = false,\n        videoMuted = false;\n\n    if (options.audio && !this.audioMuted) {\n      audioMuted = true;\n      this.audioMuted = true;\n      this.toggleMuteAudio(true);\n    }\n\n    if (options.video && !this.videoMuted) {\n      videoMuted = true;\n      this.videoMuted = true;\n      this.toggleMuteVideo(true);\n    }\n\n    //REVISIT\n    if (audioMuted || videoMuted) {\n      return {\n        audio: audioMuted,\n        video: videoMuted\n      };\n      /*this.session.onmute({\n        audio: audioMuted,\n        video: videoMuted\n      });*/\n    }\n  }},\n\n  unmute: {writable: true, value: function unmute (options) {\n    if (this.getLocalStreams().length === 0) {\n      return;\n    }\n\n    options = options || {\n      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n      video: this.getLocalStreams()[0].getVideoTracks().length > 0\n    };\n\n    var audioUnMuted = false,\n        videoUnMuted = false;\n\n    if (options.audio && this.audioMuted) {\n      audioUnMuted = true;\n      this.audioMuted = false;\n      this.toggleMuteAudio(false);\n    }\n\n    if (options.video && this.videoMuted) {\n      videoUnMuted = true;\n      this.videoMuted = false;\n      this.toggleMuteVideo(false);\n    }\n\n    //REVISIT\n    if (audioUnMuted || videoUnMuted) {\n      return {\n        audio: audioUnMuted,\n        video: videoUnMuted\n      };\n      /*this.session.onunmute({\n        audio: audioUnMuted,\n        video: videoUnMuted\n      });*/\n    }\n  }},\n\n  hold: {writable: true, value: function hold () {\n    this.toggleMuteAudio(true);\n    this.toggleMuteVideo(true);\n  }},\n\n  unhold: {writable: true, value: function unhold () {\n    if (!this.audioMuted) {\n      this.toggleMuteAudio(false);\n    }\n\n    if (!this.videoMuted) {\n      this.toggleMuteVideo(false);\n    }\n  }},\n\n// Functions the application can use, but not the session\n  getLocalStreams: {writable: true, value: function getLocalStreams () {\n    var pc = this.peerConnection;\n    if (pc && pc.signalingState === 'closed') {\n      this.logger.warn('peerConnection is closed, getLocalStreams returning []');\n      return [];\n    }\n    return (pc.getLocalStreams && pc.getLocalStreams()) ||\n      pc.localStreams || [];\n  }},\n\n  getRemoteStreams: {writable: true, value: function getRemoteStreams () {\n    var pc = this.peerConnection;\n    if (pc && pc.signalingState === 'closed') {\n      this.logger.warn('peerConnection is closed, getRemoteStreams returning []');\n      return [];\n    }\n    return(pc.getRemoteStreams && pc.getRemoteStreams()) ||\n      pc.remoteStreams || [];\n  }},\n\n  render: {writable: true, value: function render (renderHint) {\n    renderHint = renderHint || (this.mediaHint && this.mediaHint.render);\n    if (!renderHint) {\n      return false;\n    }\n    var streamGetters = {\n      local: 'getLocalStreams',\n      remote: 'getRemoteStreams'\n    };\n    Object.keys(streamGetters).forEach(function (loc) {\n      var streamGetter = streamGetters[loc];\n      var streams = this[streamGetter]();\n      if (streams.length) {\n        SIP.WebRTC.MediaStreamManager.render(streams[0], renderHint[loc]);\n      }\n    }.bind(this));\n  }},\n\n// Internal functions\n  hasOffer: {writable: true, value: function hasOffer (where) {\n    var offerState = 'have-' + where + '-offer';\n    return this.peerConnection.signalingState === offerState;\n    // TODO consider signalingStates with 'pranswer'?\n  }},\n\n  createOfferOrAnswer: {writable: true, value: function createOfferOrAnswer (onSuccess, onFailure, constraints) {\n    var self = this;\n    var methodName;\n\n    function readySuccess () {\n      var sdp = self.peerConnection.localDescription.sdp;\n\n      sdp = SIP.Hacks.Chrome.needsExplicitlyInactiveSDP(sdp);\n      sdp = SIP.Hacks.AllBrowsers.unmaskDtls(sdp);\n      sdp = SIP.Hacks.Firefox.hasIncompatibleCLineWithSomeSIPEndpoints(sdp);\n\n      var sdpWrapper = {\n        type: methodName === 'createOffer' ? 'offer' : 'answer',\n        sdp: sdp\n      };\n\n      self.emit('getDescription', sdpWrapper);\n\n      self.ready = true;\n      onSuccess(sdpWrapper.sdp);\n    }\n\n    function onSetLocalDescriptionSuccess() {\n      if (self.peerConnection.iceGatheringState === 'complete' && (self.peerConnection.iceConnectionState === 'connected' || self.peerConnection.iceConnectionState === 'completed')) {\n        readySuccess();\n      } else {\n        self.onIceCompleted = function(pc) {\n          self.logger.log('ICE Gathering Completed');\n          self.onIceCompleted = undefined;\n          self.emit('iceComplete', pc);\n          readySuccess();\n        };\n        if (self.callOnIceCompleted) {\n          self.onIceCompleted();\n        }\n      }\n    }\n\n    function methodFailed (methodName, e) {\n      self.logger.error('peerConnection.' + methodName + ' failed');\n      self.logger.error(e);\n      self.ready = true;\n      onFailure(e);\n    }\n\n    self.ready = false;\n\n    methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';\n\n    self.peerConnection[methodName](\n      function(sessionDescription){\n        self.peerConnection.setLocalDescription(\n          sessionDescription,\n          onSetLocalDescriptionSuccess,\n          methodFailed.bind(null, 'setLocalDescription')\n        );\n      },\n      methodFailed.bind(null, methodName),\n      constraints\n    );\n  }},\n\n  addStream: {writable: true, value: function addStream (stream, onSuccess, onFailure) {\n    try {\n      this.peerConnection.addStream(stream);\n    } catch(e) {\n      this.logger.error('error adding stream');\n      this.logger.error(e);\n      onFailure(e);\n      return;\n    }\n\n    onSuccess();\n  }},\n\n  toggleMuteHelper: {writable: true, value: function toggleMuteHelper (trackGetter, mute) {\n    this.getLocalStreams().forEach(function (stream) {\n      stream[trackGetter]().forEach(function (track) {\n        track.enabled = !mute;\n      });\n    });\n  }},\n\n  toggleMuteAudio: {writable: true, value: function toggleMuteAudio (mute) {\n    this.toggleMuteHelper('getAudioTracks', mute);\n  }},\n\n  toggleMuteVideo: {writable: true, value: function toggleMuteVideo (mute) {\n    this.toggleMuteHelper('getVideoTracks', mute);\n  }}\n});\n\n// Return since it will be assigned to a variable.\nreturn MediaHandler;\n};\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview MediaStreamManager\n */\n\n/* MediaStreamManager\n * @class Manages the acquisition and release of MediaStreams.\n * @param {mediaHint} [defaultMediaHint] The mediaHint to use if none is provided to acquire()\n */\nmodule.exports = function (SIP) {\n\n// Default MediaStreamManager provides single-use streams created with getUserMedia\nvar MediaStreamManager = function MediaStreamManager (logger, defaultMediaHint) {\n  if (!SIP.WebRTC.isSupported()) {\n    throw new SIP.Exceptions.NotSupportedError('Media not supported');\n  }\n\n  var events = [\n    'userMediaRequest',\n    'userMedia',\n    'userMediaFailed'\n  ];\n  this.mediaHint = defaultMediaHint || {\n    constraints: {audio: true, video: true}\n  };\n\n  this.logger = logger;\n  this.initEvents(events);\n\n  // map of streams to acquisition manner:\n  // true -> passed in as mediaHint.stream\n  // false -> getUserMedia\n  this.acquisitions = {};\n};\nMediaStreamManager.streamId = function (stream) {\n  return stream.getAudioTracks().concat(stream.getVideoTracks())\n    .map(function trackId (track) {\n      return track.id;\n    })\n    .join('');\n};\n\nMediaStreamManager.render = function render (stream, elements) {\n  if (!elements) {\n    return false;\n  }\n\n  function attachAndPlay (element, stream) {\n    (window.attachMediaStream || attachMediaStream)(element, stream);\n    ensureMediaPlaying(element);\n  }\n\n  function attachMediaStream(element, stream) {\n    if (typeof element.src !== 'undefined') {\n      URL.revokeObjectURL(element.src);\n      element.src = URL.createObjectURL(stream);\n    } else if (typeof (element.srcObject || element.mozSrcObject) !== 'undefined') {\n      element.srcObject = element.mozSrcObject = stream;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  function ensureMediaPlaying (mediaElement) {\n    var interval = 100;\n    mediaElement.ensurePlayingIntervalId = SIP.Timers.setInterval(function () {\n      if (mediaElement.paused) {\n        mediaElement.play();\n      }\n      else {\n        SIP.Timers.clearInterval(mediaElement.ensurePlayingIntervalId);\n      }\n    }, interval);\n  }\n\n  if (elements.video) {\n    if (elements.audio) {\n      elements.video.volume = 0;\n    }\n    attachAndPlay(elements.video, stream);\n  }\n  if (elements.audio) {\n    attachAndPlay(elements.audio, stream);\n  }\n};\n\nMediaStreamManager.prototype = Object.create(SIP.EventEmitter.prototype, {\n  'acquire': {value: function acquire (onSuccess, onFailure, mediaHint) {\n    mediaHint = Object.keys(mediaHint || {}).length ? mediaHint : this.mediaHint;\n\n    var saveSuccess = function (onSuccess, stream, isHintStream) {\n      var streamId = MediaStreamManager.streamId(stream);\n      this.acquisitions[streamId] = !!isHintStream;\n      onSuccess(stream);\n    }.bind(this, onSuccess);\n\n    if (mediaHint.stream) {\n      saveSuccess(mediaHint.stream, true);\n    } else {\n      // Fallback to audio/video enabled if no mediaHint can be found.\n      var constraints = mediaHint.constraints ||\n        (this.mediaHint && this.mediaHint.constraints) ||\n        {audio: true, video: true};\n\n      /*\n       * Make the call asynchronous, so that ICCs have a chance\n       * to define callbacks to `userMediaRequest`\n       */\n      SIP.Timers.setTimeout(function () {\n        this.emit('userMediaRequest', constraints);\n\n        var emitThenCall = function (eventName, callback) {\n          var callbackArgs = Array.prototype.slice.call(arguments, 2);\n          // Emit with all of the arguments from the real callback.\n          var newArgs = [eventName].concat(callbackArgs);\n\n          this.emit.apply(this, newArgs);\n\n          callback.apply(null, callbackArgs);\n        }.bind(this);\n\n        SIP.WebRTC.getUserMedia(\n          constraints,\n          emitThenCall.bind(this, 'userMedia', saveSuccess),\n          emitThenCall.bind(this, 'userMediaFailed', onFailure)\n        );\n      }.bind(this), 0);\n    }\n  }},\n\n  'release': {value: function release (stream) {\n    var streamId = MediaStreamManager.streamId(stream);\n    if (this.acquisitions[streamId] === false) {\n      stream.stop();\n    }\n    delete this.acquisitions[streamId];\n  }},\n});\n\n// Return since it will be assigned to a variable.\nreturn MediaStreamManager;\n};\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview WebRTC\n */\n\nmodule.exports = function (Utils, window, MediaHandler, MediaStreamManager) {\nvar WebRTC;\n\nWebRTC = {};\n\nWebRTC.MediaHandler = MediaHandler;\nWebRTC.MediaStreamManager = MediaStreamManager;\n\nvar _isSupported;\n\nWebRTC.isSupported = function () {\n  if (_isSupported !== undefined) {\n    return _isSupported;\n  }\n\n  WebRTC.MediaStream = Utils.getPrefixedProperty(window, 'MediaStream');\n  WebRTC.getUserMedia = Utils.getPrefixedProperty(window.navigator, 'getUserMedia');\n  WebRTC.RTCPeerConnection = Utils.getPrefixedProperty(window, 'RTCPeerConnection');\n  WebRTC.RTCSessionDescription = Utils.getPrefixedProperty(window, 'RTCSessionDescription');\n\n  if (WebRTC.getUserMedia && WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {\n    WebRTC.getUserMedia = WebRTC.getUserMedia.bind(window.navigator);\n    _isSupported = true;\n  }\n  else {\n    _isSupported = false;\n  }\n  return _isSupported;\n};\n\nreturn WebRTC;\n};\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * @augments SIP\n * @class Class creating a SIP User Agent.\n * @param {function returning SIP.MediaHandler} [configuration.mediaHandlerFactory]\n *        A function will be invoked by each of the UA's Sessions to build the MediaHandler for that Session.\n *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) MediaHandler.\n *\n * @param {Object} [configuration.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n */\nmodule.exports = function (SIP) {\nvar UA,\n  C = {\n    // UA status codes\n    STATUS_INIT :                0,\n    STATUS_READY:                1,\n    STATUS_USER_CLOSED:          2,\n    STATUS_NOT_READY:            3,\n\n    // UA error codes\n    CONFIGURATION_ERROR:  1,\n    NETWORK_ERROR:        2,\n\n    /* UA events and corresponding SIP Methods.\n     * Dynamically added to 'Allow' header field if the\n     * corresponding event handler is set.\n     */\n    EVENT_METHODS: {\n      'invite': 'INVITE',\n      'message': 'MESSAGE'\n    },\n\n    ALLOWED_METHODS: [\n      'ACK',\n      'CANCEL',\n      'BYE',\n      'OPTIONS',\n      'INFO',\n      'NOTIFY'\n    ],\n\n    ACCEPTED_BODY_TYPES: [\n      'application/sdp',\n      'application/dtmf-relay'\n    ],\n\n    MAX_FORWARDS: 70,\n    TAG_LENGTH: 10\n  };\n\nUA = function(configuration) {\n  var self = this,\n  events = [\n    'connecting',\n    'connected',\n    'disconnected',\n    'newTransaction',\n    'transactionDestroyed',\n    'registered',\n    'unregistered',\n    'registrationFailed',\n    'invite',\n    'newSession',\n    'message'\n  ], i, len;\n\n  // Helper function for forwarding events\n  function selfEmit(type) {\n    //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments\n    return self.emit.bind(self, type);\n  }\n\n  for (i = 0, len = C.ALLOWED_METHODS.length; i < len; i++) {\n    events.push(C.ALLOWED_METHODS[i].toLowerCase());\n  }\n\n  // Set Accepted Body Types\n  C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();\n\n  this.log = new SIP.LoggerFactory();\n  this.logger = this.getLogger('sip.ua');\n\n  this.cache = {\n    credentials: {}\n  };\n\n  this.configuration = {};\n  this.dialogs = {};\n\n  //User actions outside any session/dialog (MESSAGE)\n  this.applicants = {};\n\n  this.data = {};\n  this.sessions = {};\n  this.subscriptions = {};\n  this.transport = null;\n  this.contact = null;\n  this.status = C.STATUS_INIT;\n  this.error = null;\n  this.transactions = {\n    nist: {},\n    nict: {},\n    ist: {},\n    ict: {}\n  };\n\n  this.transportRecoverAttempts = 0;\n  this.transportRecoveryTimer = null;\n\n  Object.defineProperties(this, {\n    transactionsCount: {\n      get: function() {\n        var type,\n          transactions = ['nist','nict','ist','ict'],\n          count = 0;\n\n        for (type in transactions) {\n          count += Object.keys(this.transactions[transactions[type]]).length;\n        }\n\n        return count;\n      }\n    },\n\n    nictTransactionsCount: {\n      get: function() {\n        return Object.keys(this.transactions['nict']).length;\n      }\n    },\n\n    nistTransactionsCount: {\n      get: function() {\n        return Object.keys(this.transactions['nist']).length;\n      }\n    },\n\n    ictTransactionsCount: {\n      get: function() {\n        return Object.keys(this.transactions['ict']).length;\n      }\n    },\n\n    istTransactionsCount: {\n      get: function() {\n        return Object.keys(this.transactions['ist']).length;\n      }\n    }\n  });\n\n  /**\n   * Load configuration\n   *\n   * @throws {SIP.Exceptions.ConfigurationError}\n   * @throws {TypeError}\n   */\n\n  if(configuration === undefined) {\n    configuration = {};\n  } else if (typeof configuration === 'string' || configuration instanceof String) {\n    configuration = {\n      uri: configuration\n    };\n  }\n\n  // Apply log configuration if present\n  if (configuration.log) {\n    if (configuration.log.hasOwnProperty('builtinEnabled')) {\n      this.log.builtinEnabled = configuration.log.builtinEnabled;\n    }\n\n    if (configuration.log.hasOwnProperty('level')) {\n      this.log.level = configuration.log.level;\n    }\n\n    if (configuration.log.hasOwnProperty('connector')) {\n      this.log.connector = configuration.log.connector;\n    }\n  }\n\n  try {\n    this.loadConfig(configuration);\n    this.initEvents(events);\n  } catch(e) {\n    this.status = C.STATUS_NOT_READY;\n    this.error = C.CONFIGURATION_ERROR;\n    throw e;\n  }\n\n  // Initialize registerContext\n  this.registerContext = new SIP.RegisterContext(this);\n  this.registerContext.on('failed', selfEmit('registrationFailed'));\n  this.registerContext.on('registered', selfEmit('registered'));\n  this.registerContext.on('unregistered', selfEmit('unregistered'));\n\n  if(this.configuration.autostart) {\n    this.start();\n  }\n\n  if (typeof global.addEventListener === 'function') {\n    global.addEventListener('unload', this.stop.bind(this));\n  }\n};\nUA.prototype = new SIP.EventEmitter();\n\n//=================\n//  High Level API\n//=================\n\nUA.prototype.register = function(options) {\n  this.configuration.register = true;\n  this.registerContext.register(options);\n\n  return this;\n};\n\n/**\n * Unregister.\n *\n * @param {Boolean} [all] unregister all user bindings.\n *\n */\nUA.prototype.unregister = function(options) {\n  this.configuration.register = false;\n  this.registerContext.unregister(options);\n\n  return this;\n};\n\nUA.prototype.isRegistered = function() {\n  return this.registerContext.registered;\n};\n\n/**\n * Connection state.\n * @param {Boolean}\n */\nUA.prototype.isConnected = function() {\n  return this.transport ? this.transport.connected : false;\n};\n\n/**\n * Make an outgoing call.\n *\n * @param {String} target\n * @param {Object} views\n * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n *\n * @throws {TypeError}\n *\n */\nUA.prototype.invite = function(target, options) {\n  options = options || {};\n  options = SIP.Utils.desugarSessionOptions(options);\n  SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger);\n\n  var context = new SIP.InviteClientContext(this, target, options);\n\n  if (this.isConnected()) {\n    context.invite({media: options.media});\n  } else {\n    this.once('connected', function() {\n      context.invite({media: options.media});\n    });\n  }\n  return context;\n};\n\nUA.prototype.subscribe = function(target, event, options) {\n  var sub = new SIP.Subscription(this, target, event, options);\n\n  if (this.isConnected()) {\n    sub.subscribe();\n  } else {\n    this.once('connected', function() {\n      sub.subscribe();\n    });\n  }\n  return sub;\n};\n\n/**\n * Send a message.\n *\n * @param {String} target\n * @param {String} body\n * @param {Object} [options]\n *\n * @throws {TypeError}\n *\n */\nUA.prototype.message = function(target, body, options) {\n  if (body === undefined) {\n    throw new TypeError('Not enough arguments');\n  }\n\n  options = options || {};\n  options.contentType = options.contentType || 'text/plain';\n  options.body = body;\n\n  var mes = new SIP.ClientContext(this, SIP.C.MESSAGE, target, options);\n\n  if (this.isConnected()) {\n    mes.send();\n  } else {\n    this.once('connected', function() {\n      mes.send();\n    });\n  }\n\n  return mes;\n};\n\nUA.prototype.request = function (method, target, options) {\n  var req = new SIP.ClientContext(this, method, target, options);\n\n  if (this.isConnected()) {\n    req.send();\n  } else {\n    this.once('connected', function() {\n      req.send();\n    });\n  }\n\n  return req;\n};\n\n/**\n * Gracefully close.\n *\n */\nUA.prototype.stop = function() {\n  var session, subscription, applicant,\n    ua = this;\n\n  function transactionsListener() {\n    if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {\n        ua.off('transactionDestroyed', transactionsListener);\n        ua.transport.disconnect();\n    }\n  }\n\n  this.logger.log('user requested closure...');\n\n  if(this.status === C.STATUS_USER_CLOSED) {\n    this.logger.warn('UA already closed');\n    return this;\n  }\n\n  // Clear transportRecoveryTimer\n  SIP.Timers.clearTimeout(this.transportRecoveryTimer);\n\n  // Close registerContext\n  this.logger.log('closing registerContext');\n  this.registerContext.close();\n\n  // Run  _terminate_ on every Session\n  for(session in this.sessions) {\n    this.logger.log('closing session ' + session);\n    this.sessions[session].terminate();\n  }\n\n  //Run _close_ on every Subscription\n  for(subscription in this.subscriptions) {\n    this.logger.log('unsubscribing from subscription ' + subscription);\n    this.subscriptions[subscription].close();\n  }\n\n  // Run  _close_ on every applicant\n  for(applicant in this.applicants) {\n    this.applicants[applicant].close();\n  }\n\n  this.status = C.STATUS_USER_CLOSED;\n\n  /*\n   * If the remaining transactions are all INVITE transactions, there is no need to\n   * wait anymore because every session has already been closed by this method.\n   * - locally originated sessions where terminated (CANCEL or BYE)\n   * - remotely originated sessions where rejected (4XX) or terminated (BYE)\n   * Remaining INVITE transactions belong tho sessions that where answered. This are in\n   * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]\n   */\n  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {\n    this.transport.disconnect();\n  } else {\n    this.on('transactionDestroyed', transactionsListener);\n  }\n\n  return this;\n};\n\n/**\n * Connect to the WS server if status = STATUS_INIT.\n * Resume UA after being closed.\n *\n */\nUA.prototype.start = function() {\n  var server;\n\n  this.logger.log('user requested startup...');\n  if (this.status === C.STATUS_INIT) {\n    server = this.getNextWsServer();\n    new SIP.Transport(this, server);\n  } else if(this.status === C.STATUS_USER_CLOSED) {\n    this.logger.log('resuming');\n    this.status = C.STATUS_READY;\n    this.transport.connect();\n  } else if (this.status === C.STATUS_READY) {\n    this.logger.log('UA is in READY status, not resuming');\n  } else {\n    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');\n  }\n\n  return this;\n};\n\n/**\n * Normalize a string into a valid SIP request URI\n *\n * @param {String} target\n *\n * @returns {SIP.URI|undefined}\n */\nUA.prototype.normalizeTarget = function(target) {\n  return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);\n};\n\n\n//===============================\n//  Private (For internal use)\n//===============================\n\nUA.prototype.saveCredentials = function(credentials) {\n  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};\n  this.cache.credentials[credentials.realm][credentials.uri] = credentials;\n\n  return this;\n};\n\nUA.prototype.getCredentials = function(request) {\n  var realm, credentials;\n\n  realm = request.ruri.host;\n\n  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {\n    credentials = this.cache.credentials[realm][request.ruri];\n    credentials.method = request.method;\n  }\n\n  return credentials;\n};\n\nUA.prototype.getLogger = function(category, label) {\n  return this.log.getLogger(category, label);\n};\n\n\n//==============================\n// Event Handlers\n//==============================\n\n/**\n * Transport Close event\n * @private\n * @event\n * @param {SIP.Transport} transport.\n */\nUA.prototype.onTransportClosed = function(transport) {\n  // Run _onTransportError_ callback on every client transaction using _transport_\n  var type, idx, length,\n    client_transactions = ['nict', 'ict', 'nist', 'ist'];\n\n  transport.server.status = SIP.Transport.C.STATUS_DISCONNECTED;\n  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_DISCONNECTED);\n\n  length = client_transactions.length;\n  for (type = 0; type < length; type++) {\n    for(idx in this.transactions[client_transactions[type]]) {\n      this.transactions[client_transactions[type]][idx].onTransportError();\n    }\n  }\n\n  // Close sessions if GRUU is not being used\n  if (!this.contact.pub_gruu) {\n    this.closeSessionsOnTransportError();\n  }\n\n};\n\n/**\n * Unrecoverable transport event.\n * Connection reattempt logic has been done and didn't success.\n * @private\n * @event\n * @param {SIP.Transport} transport.\n */\nUA.prototype.onTransportError = function(transport) {\n  var server;\n\n  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to '+ SIP.Transport.C.STATUS_ERROR);\n\n  // Close sessions.\n  //Mark this transport as 'down'\n  transport.server.status = SIP.Transport.C.STATUS_ERROR;\n\n  this.emit('disconnected', {\n    transport: transport\n  });\n\n  // try the next transport if the UA isn't closed\n  if(this.status === C.STATUS_USER_CLOSED) {\n    return;\n  }\n\n  server = this.getNextWsServer();\n\n  if(server) {\n    new SIP.Transport(this, server);\n  }else {\n    this.closeSessionsOnTransportError();\n    if (!this.error || this.error !== C.NETWORK_ERROR) {\n      this.status = C.STATUS_NOT_READY;\n      this.error = C.NETWORK_ERROR;\n    }\n    // Transport Recovery process\n    this.recoverTransport();\n  }\n};\n\n/**\n * Transport connection event.\n * @private\n * @event\n * @param {SIP.Transport} transport.\n */\nUA.prototype.onTransportConnected = function(transport) {\n  this.transport = transport;\n\n  // Reset transport recovery counter\n  this.transportRecoverAttempts = 0;\n\n  transport.server.status = SIP.Transport.C.STATUS_READY;\n  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_READY);\n\n  if(this.status === C.STATUS_USER_CLOSED) {\n    return;\n  }\n\n  this.status = C.STATUS_READY;\n  this.error = null;\n\n  if(this.configuration.register) {\n    this.registerContext.onTransportConnected();\n  }\n\n  this.emit('connected', {\n    transport: transport\n  });\n};\n\n\n/**\n * Transport connecting event\n * @private\n * @param {SIP.Transport} transport.\n * #param {Integer} attempts.\n */\n  UA.prototype.onTransportConnecting = function(transport, attempts) {\n    this.emit('connecting', {\n      transport: transport,\n      attempts: attempts\n    });\n  };\n\n\n/**\n * new Transaction\n * @private\n * @param {SIP.Transaction} transaction.\n */\nUA.prototype.newTransaction = function(transaction) {\n  this.transactions[transaction.type][transaction.id] = transaction;\n  this.emit('newTransaction', {transaction: transaction});\n};\n\n\n/**\n * destroy Transaction\n * @private\n * @param {SIP.Transaction} transaction.\n */\nUA.prototype.destroyTransaction = function(transaction) {\n  delete this.transactions[transaction.type][transaction.id];\n  this.emit('transactionDestroyed', {\n    transaction: transaction\n  });\n};\n\n\n//=========================\n// receiveRequest\n//=========================\n\n/**\n * Request reception\n * @private\n * @param {SIP.IncomingRequest} request.\n */\nUA.prototype.receiveRequest = function(request) {\n  var dialog, session, message,\n    method = request.method,\n    transaction,\n    methodLower = request.method.toLowerCase(),\n    self = this;\n\n  function ruriMatches (uri) {\n    return uri && uri.user === request.ruri.user;\n  }\n\n  // Check that request URI points to us\n  if(!(ruriMatches(this.configuration.uri) ||\n       ruriMatches(this.contact.uri) ||\n       ruriMatches(this.contact.pub_gruu) ||\n       ruriMatches(this.contact.temp_gruu))) {\n    this.logger.warn('Request-URI does not point to us');\n    if (request.method !== SIP.C.ACK) {\n      request.reply_sl(404);\n    }\n    return;\n  }\n\n  // Check request URI scheme\n  if(request.ruri.scheme === SIP.C.SIPS) {\n    request.reply_sl(416);\n    return;\n  }\n\n  // Check transaction\n  if(SIP.Transactions.checkTransaction(this, request)) {\n    return;\n  }\n\n  /* RFC3261 12.2.2\n   * Requests that do not change in any way the state of a dialog may be\n   * received within a dialog (for example, an OPTIONS request).\n   * They are processed as if they had been received outside the dialog.\n   */\n  if(method === SIP.C.OPTIONS) {\n    new SIP.Transactions.NonInviteServerTransaction(request, this);\n    request.reply(200, null, [\n      'Allow: '+ SIP.Utils.getAllowedMethods(this),\n      'Accept: '+ C.ACCEPTED_BODY_TYPES\n    ]);\n  } else if (method === SIP.C.MESSAGE) {\n    if (!this.checkListener(methodLower)) {\n      // UA is not listening for this.  Reject immediately.\n      new SIP.Transactions.NonInviteServerTransaction(request, this);\n      request.reply(405, null, ['Allow: '+ SIP.Utils.getAllowedMethods(this)]);\n      return;\n    }\n    message = new SIP.ServerContext(this, request);\n    message.body = request.body;\n    message.content_type = request.getHeader('Content-Type') || 'text/plain';\n\n    request.reply(200, null);\n    this.emit('message', message);\n  } else if (method !== SIP.C.INVITE &&\n             method !== SIP.C.ACK) {\n    // Let those methods pass through to normal processing for now.\n    transaction = new SIP.ServerContext(this, request);\n  }\n\n  // Initial Request\n  if(!request.to_tag) {\n    switch(method) {\n      case SIP.C.INVITE:\n        var isMediaSupported = this.configuration.mediaHandlerFactory.isSupported;\n        if(!isMediaSupported || isMediaSupported()) {\n          session = new SIP.InviteServerContext(this, request)\n            .on('invite', function() {\n              self.emit('invite', this);\n            });\n        } else {\n          this.logger.warn('INVITE received but WebRTC is not supported');\n          request.reply(488);\n        }\n        break;\n      case SIP.C.BYE:\n        // Out of dialog BYE received\n        request.reply(481);\n        break;\n      case SIP.C.CANCEL:\n        session = this.findSession(request);\n        if(session) {\n          session.receiveRequest(request);\n        } else {\n          this.logger.warn('received CANCEL request for a non existent session');\n        }\n        break;\n      case SIP.C.ACK:\n        /* Absorb it.\n         * ACK request without a corresponding Invite Transaction\n         * and without To tag.\n         */\n        break;\n      default:\n        request.reply(405);\n        break;\n    }\n  }\n  // In-dialog request\n  else {\n    dialog = this.findDialog(request);\n\n    if(dialog) {\n      if (method === SIP.C.INVITE) {\n        new SIP.Transactions.InviteServerTransaction(request, this);\n      }\n      dialog.receiveRequest(request);\n    } else if (method === SIP.C.NOTIFY) {\n      session = this.findSession(request);\n      if(session) {\n        session.receiveRequest(request);\n      } else {\n        this.logger.warn('received NOTIFY request for a non existent session');\n        request.reply(481, 'Subscription does not exist');\n      }\n    }\n    /* RFC3261 12.2.2\n     * Request with to tag, but no matching dialog found.\n     * Exception: ACK for an Invite request for which a dialog has not\n     * been created.\n     */\n    else {\n      if(method !== SIP.C.ACK) {\n        request.reply(481);\n      }\n    }\n  }\n};\n\n//=================\n// Utils\n//=================\n\n/**\n * Get the session to which the request belongs to, if any.\n * @private\n * @param {SIP.IncomingRequest} request.\n * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}\n */\nUA.prototype.findSession = function(request) {\n  return this.sessions[request.call_id + request.from_tag] ||\n          this.sessions[request.call_id + request.to_tag] ||\n          null;\n};\n\n/**\n * Get the dialog to which the request belongs to, if any.\n * @private\n * @param {SIP.IncomingRequest}\n * @returns {SIP.Dialog|null}\n */\nUA.prototype.findDialog = function(request) {\n  return this.dialogs[request.call_id + request.from_tag + request.to_tag] ||\n          this.dialogs[request.call_id + request.to_tag + request.from_tag] ||\n          null;\n};\n\n/**\n * Retrieve the next server to which connect.\n * @private\n * @returns {Object} ws_server\n */\nUA.prototype.getNextWsServer = function() {\n  // Order servers by weight\n  var idx, length, ws_server,\n    candidates = [];\n\n  length = this.configuration.wsServers.length;\n  for (idx = 0; idx < length; idx++) {\n    ws_server = this.configuration.wsServers[idx];\n\n    if (ws_server.status === SIP.Transport.C.STATUS_ERROR) {\n      continue;\n    } else if (candidates.length === 0) {\n      candidates.push(ws_server);\n    } else if (ws_server.weight > candidates[0].weight) {\n      candidates = [ws_server];\n    } else if (ws_server.weight === candidates[0].weight) {\n      candidates.push(ws_server);\n    }\n  }\n\n  idx = Math.floor(Math.random() * candidates.length);\n\n  return candidates[idx];\n};\n\n/**\n * Close all sessions on transport error.\n * @private\n */\nUA.prototype.closeSessionsOnTransportError = function() {\n  var idx;\n\n  // Run _transportError_ for every Session\n  for(idx in this.sessions) {\n    this.sessions[idx].onTransportError();\n  }\n  // Call registerContext _onTransportClosed_\n  this.registerContext.onTransportClosed();\n};\n\nUA.prototype.recoverTransport = function(ua) {\n  var idx, length, k, nextRetry, count, server;\n\n  ua = ua || this;\n  count = ua.transportRecoverAttempts;\n\n  length = ua.configuration.wsServers.length;\n  for (idx = 0; idx < length; idx++) {\n    ua.configuration.wsServers[idx].status = 0;\n  }\n\n  server = ua.getNextWsServer();\n\n  k = Math.floor((Math.random() * Math.pow(2,count)) +1);\n  nextRetry = k * ua.configuration.connectionRecoveryMinInterval;\n\n  if (nextRetry > ua.configuration.connectionRecoveryMaxInterval) {\n    this.logger.log('time for next connection attempt exceeds connectionRecoveryMaxInterval, resetting counter');\n    nextRetry = ua.configuration.connectionRecoveryMinInterval;\n    count = 0;\n  }\n\n  this.logger.log('next connection attempt in '+ nextRetry +' seconds');\n\n  this.transportRecoveryTimer = SIP.Timers.setTimeout(\n    function(){\n      ua.transportRecoverAttempts = count + 1;\n      new SIP.Transport(ua, server);\n    }, nextRetry * 1000);\n};\n\n/**\n * Configuration load.\n * @private\n * returns {Boolean}\n */\nUA.prototype.loadConfig = function(configuration) {\n  // Settings and default values\n  var parameter, value, checked_value, hostportParams, registrarServer,\n    settings = {\n      /* Host address\n      * Value to be set in Via sent_by and host part of Contact FQDN\n      */\n      viaHost: SIP.Utils.createRandomToken(12) + '.invalid',\n\n      uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),\n      wsServers: [{\n        scheme: 'WSS',\n        sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',\n        status: 0,\n        weight: 0,\n        ws_uri: 'wss://edge.sip.onsip.com'\n      }],\n\n      // Password\n      password: null,\n\n      // Registration parameters\n      registerExpires: 600,\n      register: true,\n      registrarServer: null,\n\n      // Transport related parameters\n      wsServerMaxReconnection: 3,\n      wsServerReconnectionTimeout: 4,\n\n      connectionRecoveryMinInterval: 2,\n      connectionRecoveryMaxInterval: 30,\n\n      usePreloadedRoute: false,\n\n      //string to be inserted into User-Agent request header\n      userAgentString: SIP.C.USER_AGENT,\n\n      // Session parameters\n      noAnswerTimeout: 60,\n      stunServers: ['stun:stun.l.google.com:19302'],\n      turnServers: [],\n\n      // Logging parameters\n      traceSip: false,\n\n      // Hacks\n      hackViaTcp: false,\n      hackIpInContact: false,\n      hackWssInTransport: false,\n\n      //autostarting\n      autostart: true,\n\n      //Reliable Provisional Responses\n      rel100: SIP.C.supported.UNSUPPORTED,\n\n      mediaHandlerFactory: SIP.WebRTC.MediaHandler.defaultFactory\n    };\n\n  // Pre-Configuration\n  function aliasUnderscored (parameter, logger) {\n    var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {\n      return m[0] + '_' + m[1].toLowerCase();\n    });\n\n    if (parameter === underscored) {\n      return;\n    }\n\n    var hasParameter = configuration.hasOwnProperty(parameter);\n    if (configuration.hasOwnProperty(underscored)) {\n      logger.warn(underscored + ' is deprecated, please use ' + parameter);\n      if (hasParameter) {\n        logger.warn(parameter + ' overriding ' + underscored);\n      }\n    }\n\n    configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];\n  }\n\n  // Check Mandatory parameters\n  for(parameter in UA.configuration_check.mandatory) {\n    aliasUnderscored(parameter, this.logger);\n    if(!configuration.hasOwnProperty(parameter)) {\n      throw new SIP.Exceptions.ConfigurationError(parameter);\n    } else {\n      value = configuration[parameter];\n      checked_value = UA.configuration_check.mandatory[parameter](value);\n      if (checked_value !== undefined) {\n        settings[parameter] = checked_value;\n      } else {\n        throw new SIP.Exceptions.ConfigurationError(parameter, value);\n      }\n    }\n  }\n\n  SIP.Utils.optionsOverride(configuration, 'rel100', 'reliable', true, this.logger, SIP.C.supported.UNSUPPORTED);\n\n  var emptyArraysAllowed = ['stunServers', 'turnServers'];\n\n  // Check Optional parameters\n  for(parameter in UA.configuration_check.optional) {\n    aliasUnderscored(parameter, this.logger);\n    if(configuration.hasOwnProperty(parameter)) {\n      value = configuration[parameter];\n\n      // If the parameter value is an empty array, but shouldn't be, apply its default value.\n      if (value instanceof Array && value.length === 0 && emptyArraysAllowed.indexOf(parameter) < 0) { continue; }\n\n      // If the parameter value is null, empty string, or undefined then apply its default value.\n      if(value === null || value === \"\" || value === undefined) { continue; }\n      // If it's a number with NaN value then also apply its default value.\n      // NOTE: JS does not allow \"value === NaN\", the following does the work:\n      else if(typeof(value) === 'number' && isNaN(value)) { continue; }\n\n      checked_value = UA.configuration_check.optional[parameter](value);\n      if (checked_value !== undefined) {\n        settings[parameter] = checked_value;\n      } else {\n        throw new SIP.Exceptions.ConfigurationError(parameter, value);\n      }\n    }\n  }\n\n  // Sanity Checks\n\n  // Connection recovery intervals\n  if(settings.connectionRecoveryMaxInterval < settings.connectionRecoveryMinInterval) {\n    throw new SIP.Exceptions.ConfigurationError('connectionRecoveryMaxInterval', settings.connectionRecoveryMaxInterval);\n  }\n\n  // Post Configuration Process\n\n  // Allow passing 0 number as displayName.\n  if (settings.displayName === 0) {\n    settings.displayName = '0';\n  }\n\n  // Instance-id for GRUU\n  if (!settings.instanceId) {\n    settings.instanceId = SIP.Utils.newUUID();\n  }\n\n  // sipjsId instance parameter. Static random tag of length 5\n  settings.sipjsId = SIP.Utils.createRandomToken(5);\n\n  // String containing settings.uri without scheme and user.\n  hostportParams = settings.uri.clone();\n  hostportParams.user = null;\n  settings.hostportParams = hostportParams.toString().replace(/^sip:/i, '');\n\n  /* Check whether authorizationUser is explicitly defined.\n   * Take 'settings.uri.user' value if not.\n   */\n  if (!settings.authorizationUser) {\n    settings.authorizationUser = settings.uri.user;\n  }\n\n  /* If no 'registrarServer' is set use the 'uri' value without user portion. */\n  if (!settings.registrarServer) {\n    registrarServer = settings.uri.clone();\n    registrarServer.user = null;\n    settings.registrarServer = registrarServer;\n  }\n\n  // User noAnswerTimeout\n  settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;\n\n  // Via Host\n  if (settings.hackIpInContact) {\n    settings.viaHost = SIP.Utils.getRandomTestNetIP();\n  }\n\n  this.contact = {\n    pub_gruu: null,\n    temp_gruu: null,\n    uri: new SIP.URI('sip', SIP.Utils.createRandomToken(8), settings.viaHost, null, {transport: ((settings.hackWssInTransport)?'wss':'ws')}),\n    toString: function(options){\n      options = options || {};\n\n      var\n        anonymous = options.anonymous || null,\n        outbound = options.outbound || null,\n        contact = '<';\n\n      if (anonymous) {\n        contact += (this.temp_gruu || ( true?'wss':'ws')).toString();\n      } else {\n        contact += (this.pub_gruu || this.uri).toString();\n      }\n\n      if (outbound) {\n        contact += ';ob';\n      }\n\n      contact += '>';\n\n      return contact;\n    }\n  };\n\n  // media overrides mediaConstraints\n  SIP.Utils.optionsOverride(settings, 'media', 'mediaConstraints', true, this.logger);\n\n  // Fill the value of the configuration_skeleton\n  for(parameter in settings) {\n    UA.configuration_skeleton[parameter].value = settings[parameter];\n  }\n\n  Object.defineProperties(this.configuration, UA.configuration_skeleton);\n\n  // Clean UA.configuration_skeleton\n  for(parameter in settings) {\n    UA.configuration_skeleton[parameter].value = '';\n  }\n\n  this.logger.log('configuration parameters after validation:');\n  for(parameter in settings) {\n    switch(parameter) {\n      case 'uri':\n      case 'registrarServer':\n      case 'mediaHandlerFactory':\n        this.logger.log('· ' + parameter + ': ' + settings[parameter]);\n        break;\n      case 'password':\n        this.logger.log('· ' + parameter + ': ' + 'NOT SHOWN');\n        break;\n      default:\n        this.logger.log('· ' + parameter + ': ' + JSON.stringify(settings[parameter]));\n    }\n  }\n\n  return;\n};\n\n/**\n * Configuration Object skeleton.\n * @private\n */\nUA.configuration_skeleton = (function() {\n  var idx,  parameter,\n    skeleton = {},\n    parameters = [\n      // Internal parameters\n      \"sipjsId\",\n      \"hostportParams\",\n\n      // Optional user configurable parameters\n      \"uri\",\n      \"wsServers\",\n      \"authorizationUser\",\n      \"connectionRecoveryMaxInterval\",\n      \"connectionRecoveryMinInterval\",\n      \"displayName\",\n      \"hackViaTcp\", // false.\n      \"hackIpInContact\", //false\n      \"hackWssInTransport\", //false\n      \"instanceId\",\n      \"noAnswerTimeout\", // 30 seconds.\n      \"password\",\n      \"registerExpires\", // 600 seconds.\n      \"registrarServer\",\n      \"reliable\",\n      \"rel100\",\n      \"userAgentString\", //SIP.C.USER_AGENT\n      \"autostart\",\n      \"stunServers\",\n      \"traceSip\",\n      \"turnServers\",\n      \"usePreloadedRoute\",\n      \"wsServerMaxReconnection\",\n      \"wsServerReconnectionTimeout\",\n      \"mediaHandlerFactory\",\n      \"media\",\n      \"mediaConstraints\",\n\n      // Post-configuration generated parameters\n      \"via_core_value\",\n      \"viaHost\"\n    ];\n\n  for(idx in parameters) {\n    parameter = parameters[idx];\n    skeleton[parameter] = {\n      value: '',\n      writable: false,\n      configurable: false\n    };\n  }\n\n  skeleton['register'] = {\n    value: '',\n    writable: true,\n    configurable: false\n  };\n\n  return skeleton;\n}());\n\n/**\n * Configuration checker.\n * @private\n * @return {Boolean}\n */\nUA.configuration_check = {\n  mandatory: {\n  },\n\n  optional: {\n\n    uri: function(uri) {\n      var parsed;\n\n      if (!(/^sip:/i).test(uri)) {\n        uri = SIP.C.SIP + ':' + uri;\n      }\n      parsed = SIP.URI.parse(uri);\n\n      if(!parsed) {\n        return;\n      } else if(!parsed.user) {\n        return;\n      } else {\n        return parsed;\n      }\n    },\n\n    //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid\n    wsServers: function(wsServers) {\n      var idx, length, url;\n\n      /* Allow defining wsServers parameter as:\n       *  String: \"host\"\n       *  Array of Strings: [\"host1\", \"host2\"]\n       *  Array of Objects: [{ws_uri:\"host1\", weight:1}, {ws_uri:\"host2\", weight:0}]\n       *  Array of Objects and Strings: [{ws_uri:\"host1\"}, \"host2\"]\n       */\n      if (typeof wsServers === 'string') {\n        wsServers = [{ws_uri: wsServers}];\n      } else if (wsServers instanceof Array) {\n        length = wsServers.length;\n        for (idx = 0; idx < length; idx++) {\n          if (typeof wsServers[idx] === 'string'){\n            wsServers[idx] = {ws_uri: wsServers[idx]};\n          }\n        }\n      } else {\n        return;\n      }\n\n      if (wsServers.length === 0) {\n        return false;\n      }\n\n      length = wsServers.length;\n      for (idx = 0; idx < length; idx++) {\n        if (!wsServers[idx].ws_uri) {\n          return;\n        }\n        if (wsServers[idx].weight && !Number(wsServers[idx].weight)) {\n          return;\n        }\n\n        url = SIP.Grammar.parse(wsServers[idx].ws_uri, 'absoluteURI');\n\n        if(url === -1) {\n          return;\n        } else if(url.scheme !== 'wss' && url.scheme !== 'ws') {\n          return;\n        } else {\n          wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=ws;lr>';\n\n          if (!wsServers[idx].weight) {\n            wsServers[idx].weight = 0;\n          }\n\n          wsServers[idx].status = 0;\n          wsServers[idx].scheme = url.scheme.toUpperCase();\n        }\n      }\n      return wsServers;\n    },\n\n    authorizationUser: function(authorizationUser) {\n      if(SIP.Grammar.parse('\"'+ authorizationUser +'\"', 'quoted_string') === -1) {\n        return;\n      } else {\n        return authorizationUser;\n      }\n    },\n\n    connectionRecoveryMaxInterval: function(connectionRecoveryMaxInterval) {\n      var value;\n      if(SIP.Utils.isDecimal(connectionRecoveryMaxInterval)) {\n        value = Number(connectionRecoveryMaxInterval);\n        if(value > 0) {\n          return value;\n        }\n      }\n    },\n\n    connectionRecoveryMinInterval: function(connectionRecoveryMinInterval) {\n      var value;\n      if(SIP.Utils.isDecimal(connectionRecoveryMinInterval)) {\n        value = Number(connectionRecoveryMinInterval);\n        if(value > 0) {\n          return value;\n        }\n      }\n    },\n\n    displayName: function(displayName) {\n      if(SIP.Grammar.parse('\"' + displayName + '\"', 'displayName') === -1) {\n        return;\n      } else {\n        return displayName;\n      }\n    },\n\n    hackViaTcp: function(hackViaTcp) {\n      if (typeof hackViaTcp === 'boolean') {\n        return hackViaTcp;\n      }\n    },\n\n    hackIpInContact: function(hackIpInContact) {\n      if (typeof hackIpInContact === 'boolean') {\n        return hackIpInContact;\n      }\n    },\n\n    hackWssInTransport: function(hackWssInTransport) {\n      if (typeof hackWssInTransport === 'boolean') {\n        return hackWssInTransport;\n      }\n    },\n\n    instanceId: function(instanceId) {\n      if(typeof instanceId !== 'string') {\n        return;\n      }\n\n      if ((/^uuid:/i.test(instanceId))) {\n        instanceId = instanceId.substr(5);\n      }\n\n      if(SIP.Grammar.parse(instanceId, 'uuid') === -1) {\n        return;\n      } else {\n        return instanceId;\n      }\n    },\n\n    noAnswerTimeout: function(noAnswerTimeout) {\n      var value;\n      if (SIP.Utils.isDecimal(noAnswerTimeout)) {\n        value = Number(noAnswerTimeout);\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n\n    password: function(password) {\n      return String(password);\n    },\n\n    rel100: function(rel100) {\n      if(rel100 === SIP.C.supported.REQUIRED) {\n        return SIP.C.supported.REQUIRED;\n      } else if (rel100 === SIP.C.supported.SUPPORTED) {\n        return SIP.C.supported.SUPPORTED;\n      } else  {\n        return SIP.C.supported.UNSUPPORTED;\n      }\n    },\n\n    register: function(register) {\n      if (typeof register === 'boolean') {\n        return register;\n      }\n    },\n\n    registerExpires: function(registerExpires) {\n      var value;\n      if (SIP.Utils.isDecimal(registerExpires)) {\n        value = Number(registerExpires);\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n\n    registrarServer: function(registrarServer) {\n      var parsed;\n\n      if(typeof registrarServer !== 'string') {\n        return;\n      }\n\n      if (!/^sip:/i.test(registrarServer)) {\n        registrarServer = SIP.C.SIP + ':' + registrarServer;\n      }\n      parsed = SIP.URI.parse(registrarServer);\n\n      if(!parsed) {\n        return;\n      } else if(parsed.user) {\n        return;\n      } else {\n        return parsed;\n      }\n    },\n\n    stunServers: function(stunServers) {\n      var idx, length, stun_server;\n\n      if (typeof stunServers === 'string') {\n        stunServers = [stunServers];\n      } else if (!(stunServers instanceof Array)) {\n        return;\n      }\n\n      length = stunServers.length;\n      for (idx = 0; idx < length; idx++) {\n        stun_server = stunServers[idx];\n        if (!(/^stuns?:/.test(stun_server))) {\n          stun_server = 'stun:' + stun_server;\n        }\n\n        if(SIP.Grammar.parse(stun_server, 'stun_URI') === -1) {\n          return;\n        } else {\n          stunServers[idx] = stun_server;\n        }\n      }\n      return stunServers;\n    },\n\n    traceSip: function(traceSip) {\n      if (typeof traceSip === 'boolean') {\n        return traceSip;\n      }\n    },\n\n    turnServers: function(turnServers) {\n      var idx, length, turn_server, url;\n\n      if (turnServers instanceof Array) {\n        // Do nothing\n      } else {\n        turnServers = [turnServers];\n      }\n\n      length = turnServers.length;\n      for (idx = 0; idx < length; idx++) {\n        turn_server = turnServers[idx];\n        //Backwards compatibility: Allow defining the turn_server url with the 'server' property.\n        if (turn_server.server) {\n          turn_server.urls = [turn_server.server];\n        }\n\n        if (!turn_server.urls || !turn_server.username || !turn_server.password) {\n          return;\n        }\n\n        if (!(turn_server.urls instanceof Array)) {\n          turn_server.urls = [turn_server.urls];\n        }\n\n        length = turn_server.urls.length;\n        for (idx = 0; idx < length; idx++) {\n          url = turn_server.urls[idx];\n\n          if (!(/^turns?:/.test(url))) {\n            url = 'turn:' + url;\n          }\n\n          if(SIP.Grammar.parse(url, 'turn_URI') === -1) {\n            return;\n          }\n        }\n      }\n      return turnServers;\n    },\n\n    userAgentString: function(userAgentString) {\n      if (typeof userAgentString === 'string') {\n        return userAgentString;\n      }\n    },\n\n    usePreloadedRoute: function(usePreloadedRoute) {\n      if (typeof usePreloadedRoute === 'boolean') {\n        return usePreloadedRoute;\n      }\n    },\n\n    wsServerMaxReconnection: function(wsServerMaxReconnection) {\n      var value;\n      if (SIP.Utils.isDecimal(wsServerMaxReconnection)) {\n        value = Number(wsServerMaxReconnection);\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n\n    wsServerReconnectionTimeout: function(wsServerReconnectionTimeout) {\n      var value;\n      if (SIP.Utils.isDecimal(wsServerReconnectionTimeout)) {\n        value = Number(wsServerReconnectionTimeout);\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n\n    autostart: function(autostart) {\n      if (typeof autostart === 'boolean') {\n        return autostart;\n      }\n    },\n\n    mediaHandlerFactory: function(mediaHandlerFactory) {\n      if (mediaHandlerFactory instanceof Function) {\n        return mediaHandlerFactory;\n      }\n    }\n  }\n};\n\nUA.C = C;\nSIP.UA = UA;\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview Hacks - This file contains all of the things we\n * wish we didn't have to do, just for interop.  It is similar to\n * Utils, which provides actually useful and relevant functions for\n * a SIP library. Methods in this file are grouped by vendor, so\n * as to most easily track when particular hacks may not be necessary anymore.\n */\n\nmodule.exports = function (SIP) {\nvar Hacks = {\n  AllBrowsers: {\n    maskDtls: function (message) {\n      if (message.body) {\n        message.body = message.body.replace(/ UDP\\/TLS\\/RTP\\/SAVP/gmi, \" RTP/SAVP\");\n      }\n    },\n    unmaskDtls: function (sdp) {\n      /**\n       * Chrome does not handle DTLS correctly (Canaray does, but not production)\n       * keeping Chrome as SDES until DTLS is fixed (comment out 'is_opera' condition)\n       *\n       * UPDATE: May 21, 2014\n       * Chrome 35 now properly defaults to DTLS.  Only Opera remains using SDES\n       *\n       * UPDATE: 2014-09-24\n       * Opera now supports DTLS by default as well.\n       *\n       **/\n      return sdp.replace(/ RTP\\/SAVP/gmi, \" UDP/TLS/RTP/SAVP\");\n    }\n  },\n  Firefox: {\n    /* Condition to detect if hacks are applicable */\n    isFirefox: function () {\n      return window.mozRTCPeerConnection !== undefined;\n    },\n\n    cannotHandleExtraWhitespace: function (message) {\n      if (this.isFirefox() && message.body) {\n        message.body = message.body.replace(/ \\r\\n/g, \"\\r\\n\");\n      }\n    },\n\n    hasMissingCLineInSDP: function (sdp) {\n      /*\n       * This is a Firefox hack to insert valid sdp when getDescription is\n       * called with the constraint offerToReceiveVideo = false.\n       * We search for either a c-line at the top of the sdp above all\n       * m-lines. If that does not exist then we search for a c-line\n       * beneath each m-line. If it is missing a c-line, we insert\n       * a fake c-line with the ip address 0.0.0.0. This is then valid\n       * sdp and no media will be sent for that m-line.\n       *\n       * Valid SDP is:\n       * m=\n       * i=\n       * c=\n       */\n      var insertAt, mlines;\n      if (sdp.indexOf('c=') > sdp.indexOf('m=')) {\n\n        // Find all m= lines\n        mlines = sdp.match(/m=.*\\r\\n.*/g);\n        for (var i=0; i<mlines.length; i++) {\n\n          // If it has an i= line, check if the next line is the c= line\n          if (mlines[i].toString().search(/i=.*/) >= 0) {\n            insertAt = sdp.indexOf(mlines[i].toString())+mlines[i].toString().length;\n            if (sdp.substr(insertAt,2)!=='c=') {\n              sdp = sdp.substr(0,insertAt) + '\\r\\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);\n            }\n\n          // else add the C line if it's missing\n          } else if (mlines[i].toString().search(/c=.*/) < 0) {\n            insertAt = sdp.indexOf(mlines[i].toString().match(/.*/))+mlines[i].toString().match(/.*/).toString().length;\n            sdp = sdp.substr(0,insertAt) + '\\r\\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);\n          }\n        }\n      }\n      return sdp;\n    },\n\n    hasIncompatibleCLineWithSomeSIPEndpoints: function(sdp) {\n      /*\n       * Firefox appears to be following https://tools.ietf.org/html/rfc5245#section-9.1.1.1\n       * and using a c line IP address of 0.0.0.0. This is completely valid, however it is\n       * causing some endpoints (such as FreeSWITCH) to interpret the SDP as being on hold\n       * https://freeswitch.org/jira/browse/FS-6955. To get around this issue we pull the\n       * replace the c line with 1.1.1.1 which SIP clients do not interpret as hold.\n       * This makes the other endpoint believe that the call is not on hold and audio flows\n       * because ICE determines the media pathway (not the c line).\n       */\n      return sdp.replace(/(0\\.0\\.0\\.0)/gmi, SIP.Utils.getRandomTestNetIP());\n    }\n  },\n\n  Chrome: {\n    needsExplicitlyInactiveSDP: function (sdp) {\n      var sub, index;\n\n      if (Hacks.Firefox.isFirefox()) { // Fix this in Firefox before sending\n        index = sdp.indexOf('m=video 0');\n        if (index !== -1) {\n          sub = sdp.substr(index);\n          sub = sub.replace(/\\r\\nc=IN IP4.*\\r\\n$/,\n                            '\\r\\nc=IN IP4 0.0.0.0\\r\\na=inactive\\r\\n');\n          return sdp.substr(0, index) + sub;\n        }\n      }\n      return sdp;\n    },\n\n    getsConfusedAboutGUM: function (session) {\n      if (session.mediaHandler) {\n        session.mediaHandler.close();\n      }\n    }\n  }\n};\n\nreturn Hacks;\n};\n\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n/**\n * @fileoverview Incoming SIP Message Sanity Check\n */\n\n/**\n * SIP message sanity check.\n * @augments SIP\n * @function\n * @param {SIP.IncomingMessage} message\n * @param {SIP.UA} ua\n * @param {SIP.Transport} transport\n * @returns {Boolean}\n */\nmodule.exports = function (SIP) {\nvar sanityCheck,\n logger,\n message, ua, transport,\n requests = [],\n responses = [],\n all = [];\n\n/*\n * Sanity Check for incoming Messages\n *\n * Requests:\n *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme\n *  - _rfc3261_16_3_4_ Receive a Request already sent by us\n *   Does not look at via sent-by but at sipjsId, which is inserted as\n *   a prefix in all initial requests generated by the ua\n *  - _rfc3261_18_3_request_ Body Content-Length\n *  - _rfc3261_8_2_2_2_ Merged Requests\n *\n * Responses:\n *  - _rfc3261_8_1_3_3_ Multiple Via headers\n *  - _rfc3261_18_1_2_ sent-by mismatch\n *  - _rfc3261_18_3_response_ Body Content-Length\n *\n * All:\n *  - Minimum headers in a SIP message\n */\n\n// Sanity Check functions for requests\nfunction rfc3261_8_2_2_1() {\n  if(!message.ruri || message.ruri.scheme !== 'sip') {\n    reply(416);\n    return false;\n  }\n}\n\nfunction rfc3261_16_3_4() {\n  if(!message.to_tag) {\n    if(message.call_id.substr(0, 5) === ua.configuration.sipjsId) {\n      reply(482);\n      return false;\n    }\n  }\n}\n\nfunction rfc3261_18_3_request() {\n  var len = SIP.Utils.str_utf8_length(message.body),\n  contentLength = message.getHeader('content-length');\n\n  if(len < contentLength) {\n    reply(400);\n    return false;\n  }\n}\n\nfunction rfc3261_8_2_2_2() {\n  var tr, idx,\n    fromTag = message.from_tag,\n    call_id = message.call_id,\n    cseq = message.cseq;\n\n  if(!message.to_tag) {\n    if(message.method === SIP.C.INVITE) {\n      tr = ua.transactions.ist[message.via_branch];\n      if(tr) {\n        return;\n      } else {\n        for(idx in ua.transactions.ist) {\n          tr = ua.transactions.ist[idx];\n          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n            reply(482);\n            return false;\n          }\n        }\n      }\n    } else {\n      tr = ua.transactions.nist[message.via_branch];\n      if(tr) {\n        return;\n      } else {\n        for(idx in ua.transactions.nist) {\n          tr = ua.transactions.nist[idx];\n          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n            reply(482);\n            return false;\n          }\n        }\n      }\n    }\n  }\n}\n\n// Sanity Check functions for responses\nfunction rfc3261_8_1_3_3() {\n  if(message.getHeaders('via').length > 1) {\n    logger.warn('More than one Via header field present in the response. Dropping the response');\n    return false;\n  }\n}\n\nfunction rfc3261_18_1_2() {\n  var viaHost = ua.configuration.viaHost;\n  if(message.via.host !== viaHost || message.via.port !== undefined) {\n    logger.warn('Via sent-by in the response does not match UA Via host value. Dropping the response');\n    return false;\n  }\n}\n\nfunction rfc3261_18_3_response() {\n  var\n    len = SIP.Utils.str_utf8_length(message.body),\n    contentLength = message.getHeader('content-length');\n\n    if(len < contentLength) {\n      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');\n      return false;\n    }\n}\n\n// Sanity Check functions for requests and responses\nfunction minimumHeaders() {\n  var\n    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],\n    idx = mandatoryHeaders.length;\n\n  while(idx--) {\n    if(!message.hasHeader(mandatoryHeaders[idx])) {\n      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');\n      return false;\n    }\n  }\n}\n\n// Reply\nfunction reply(status_code) {\n  var to,\n    response = \"SIP/2.0 \" + status_code + \" \" + SIP.C.REASON_PHRASE[status_code] + \"\\r\\n\",\n    vias = message.getHeaders('via'),\n    length = vias.length,\n    idx = 0;\n\n  for(idx; idx < length; idx++) {\n    response += \"Via: \" + vias[idx] + \"\\r\\n\";\n  }\n\n  to = message.getHeader('To');\n\n  if(!message.to_tag) {\n    to += ';tag=' + SIP.Utils.newTag();\n  }\n\n  response += \"To: \" + to + \"\\r\\n\";\n  response += \"From: \" + message.getHeader('From') + \"\\r\\n\";\n  response += \"Call-ID: \" + message.call_id + \"\\r\\n\";\n  response += \"CSeq: \" + message.cseq + \" \" + message.method + \"\\r\\n\";\n  response += \"\\r\\n\";\n\n  transport.send(response);\n}\n\nrequests.push(rfc3261_8_2_2_1);\nrequests.push(rfc3261_16_3_4);\nrequests.push(rfc3261_18_3_request);\nrequests.push(rfc3261_8_2_2_2);\n\nresponses.push(rfc3261_8_1_3_3);\nresponses.push(rfc3261_18_1_2);\nresponses.push(rfc3261_18_3_response);\n\nall.push(minimumHeaders);\n\nsanityCheck = function(m, u, t) {\n  var len, pass;\n\n  message = m;\n  ua = u;\n  transport = t;\n\n  logger = ua.getLogger('sip.sanitycheck');\n\n  len = all.length;\n  while(len--) {\n    pass = all[len](message);\n    if(pass === false) {\n      return false;\n    }\n  }\n\n  if(message instanceof SIP.IncomingRequest) {\n    len = requests.length;\n    while(len--) {\n      pass = requests[len](message);\n      if(pass === false) {\n        return false;\n      }\n    }\n  }\n\n  else if(message instanceof SIP.IncomingResponse) {\n    len = responses.length;\n    while(len--) {\n      pass = responses[len](message);\n      if(pass === false) {\n        return false;\n      }\n    }\n  }\n\n  //Everything is OK\n  return true;\n};\n\nSIP.sanityCheck = sanityCheck;\n};\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\n/**\n * @fileoverview SIP Digest Authentication\n */\n\n/**\n * SIP Digest Authentication.\n * @augments SIP.\n * @function Digest Authentication\n * @param {SIP.UA} ua\n */\nmodule.exports = function (Utils) {\nvar DigestAuthentication;\n\nDigestAuthentication = function(ua) {\n  this.logger = ua.getLogger('sipjs.digestauthentication');\n  this.username = ua.configuration.authorizationUser;\n  this.password = ua.configuration.password;\n  this.cnonce = null;\n  this.nc = 0;\n  this.ncHex = '00000000';\n  this.response = null;\n};\n\n\n/**\n* Performs Digest authentication given a SIP request and the challenge\n* received in a response to that request.\n* Returns true if credentials were successfully generated, false otherwise.\n*\n* @param {SIP.OutgoingRequest} request\n* @param {Object} challenge\n*/\nDigestAuthentication.prototype.authenticate = function(request, challenge) {\n  // Inspect and validate the challenge.\n\n  this.algorithm = challenge.algorithm;\n  this.realm = challenge.realm;\n  this.nonce = challenge.nonce;\n  this.opaque = challenge.opaque;\n  this.stale = challenge.stale;\n\n  if (this.algorithm) {\n    if (this.algorithm !== 'MD5') {\n      this.logger.warn('challenge with Digest algorithm different than \"MD5\", authentication aborted');\n      return false;\n    }\n  } else {\n    this.algorithm = 'MD5';\n  }\n\n  if (! this.realm) {\n    this.logger.warn('challenge without Digest realm, authentication aborted');\n    return false;\n  }\n\n  if (! this.nonce) {\n    this.logger.warn('challenge without Digest nonce, authentication aborted');\n    return false;\n  }\n\n  // 'qop' can contain a list of values (Array). Let's choose just one.\n  if (challenge.qop) {\n    if (challenge.qop.indexOf('auth') > -1) {\n      this.qop = 'auth';\n    } else if (challenge.qop.indexOf('auth-int') > -1) {\n      this.qop = 'auth-int';\n    } else {\n      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.\n      this.logger.warn('challenge without Digest qop different than \"auth\" or \"auth-int\", authentication aborted');\n      return false;\n    }\n  } else {\n    this.qop = null;\n  }\n\n  // Fill other attributes.\n\n  this.method = request.method;\n  this.uri = request.ruri;\n  this.cnonce = Utils.createRandomToken(12);\n  this.nc += 1;\n  this.updateNcHex();\n\n  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.\n  if (this.nc === 4294967296) {\n    this.nc = 1;\n    this.ncHex = '00000001';\n  }\n\n  // Calculate the Digest \"response\" value.\n  this.calculateResponse();\n\n  return true;\n};\n\n\n/**\n* Generate Digest 'response' value.\n* @private\n*/\nDigestAuthentication.prototype.calculateResponse = function() {\n  var ha1, ha2;\n\n  // HA1 = MD5(A1) = MD5(username:realm:password)\n  ha1 = Utils.calculateMD5(this.username + \":\" + this.realm + \":\" + this.password);\n\n  if (this.qop === 'auth') {\n    // HA2 = MD5(A2) = MD5(method:digestURI)\n    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri);\n    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth:\" + ha2);\n\n  } else if (this.qop === 'auth-int') {\n    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))\n    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri + \":\" + Utils.calculateMD5(this.body ? this.body : \"\"));\n    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth-int:\" + ha2);\n\n  } else if (this.qop === null) {\n    // HA2 = MD5(A2) = MD5(method:digestURI)\n    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri);\n    // response = MD5(HA1:nonce:HA2)\n    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + ha2);\n  }\n};\n\n\n/**\n* Return the Proxy-Authorization or WWW-Authorization header value.\n*/\nDigestAuthentication.prototype.toString = function() {\n  var auth_params = [];\n\n  if (! this.response) {\n    throw new Error('response field does not exist, cannot generate Authorization header');\n  }\n\n  auth_params.push('algorithm=' + this.algorithm);\n  auth_params.push('username=\"' + this.username + '\"');\n  auth_params.push('realm=\"' + this.realm + '\"');\n  auth_params.push('nonce=\"' + this.nonce + '\"');\n  auth_params.push('uri=\"' + this.uri + '\"');\n  auth_params.push('response=\"' + this.response + '\"');\n  if (this.opaque) {\n    auth_params.push('opaque=\"' + this.opaque + '\"');\n  }\n  if (this.qop) {\n    auth_params.push('qop=' + this.qop);\n    auth_params.push('cnonce=\"' + this.cnonce + '\"');\n    auth_params.push('nc=' + this.ncHex);\n  }\n\n  return 'Digest ' + auth_params.join(', ');\n};\n\n\n/**\n* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.\n* @private\n*/\nDigestAuthentication.prototype.updateNcHex = function() {\n  var hex = Number(this.nc).toString(16);\n  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;\n};\n\nreturn DigestAuthentication;\n};\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n/* jshint ignore:start */\nmodule.exports = function(SIP) {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleIndices = { Contact: 118, Name_Addr_Header: 155, Record_Route: 175, Request_Response: 81, SIP_URI: 45, Subscription_State: 182, Via: 190, absoluteURI: 84, Call_ID: 117, Content_Disposition: 129, Content_Length: 134, Content_Type: 135, CSeq: 145, displayName: 121, Event: 148, From: 150, host: 52, Max_Forwards: 153, Proxy_Authenticate: 156, quoted_string: 40, Refer_To: 177, stun_URI: 209, To: 188, turn_URI: 216, uuid: 219, WWW_Authenticate: 205, challenge: 157 },\n        peg$startRuleIndex   = 118,\n\n        peg$consts = [\n          \"\\r\\n\",\n          { type: \"literal\", value: \"\\r\\n\", description: \"\\\"\\\\r\\\\n\\\"\" },\n          /^[0-9]/,\n          { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n          /^[a-zA-Z]/,\n          { type: \"class\", value: \"[a-zA-Z]\", description: \"[a-zA-Z]\" },\n          /^[0-9a-fA-F]/,\n          { type: \"class\", value: \"[0-9a-fA-F]\", description: \"[0-9a-fA-F]\" },\n          /^[\\0-\\xFF]/,\n          { type: \"class\", value: \"[\\\\0-\\\\xFF]\", description: \"[\\\\0-\\\\xFF]\" },\n          /^[\"]/,\n          { type: \"class\", value: \"[\\\"]\", description: \"[\\\"]\" },\n          \" \",\n          { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n          \"\\t\",\n          { type: \"literal\", value: \"\\t\", description: \"\\\"\\\\t\\\"\" },\n          /^[a-zA-Z0-9]/,\n          { type: \"class\", value: \"[a-zA-Z0-9]\", description: \"[a-zA-Z0-9]\" },\n          \";\",\n          { type: \"literal\", value: \";\", description: \"\\\";\\\"\" },\n          \"/\",\n          { type: \"literal\", value: \"/\", description: \"\\\"/\\\"\" },\n          \"?\",\n          { type: \"literal\", value: \"?\", description: \"\\\"?\\\"\" },\n          \":\",\n          { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n          \"@\",\n          { type: \"literal\", value: \"@\", description: \"\\\"@\\\"\" },\n          \"&\",\n          { type: \"literal\", value: \"&\", description: \"\\\"&\\\"\" },\n          \"=\",\n          { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n          \"+\",\n          { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\n          \"$\",\n          { type: \"literal\", value: \"$\", description: \"\\\"$\\\"\" },\n          \",\",\n          { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n          \"-\",\n          { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n          \"_\",\n          { type: \"literal\", value: \"_\", description: \"\\\"_\\\"\" },\n          \".\",\n          { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n          \"!\",\n          { type: \"literal\", value: \"!\", description: \"\\\"!\\\"\" },\n          \"~\",\n          { type: \"literal\", value: \"~\", description: \"\\\"~\\\"\" },\n          \"*\",\n          { type: \"literal\", value: \"*\", description: \"\\\"*\\\"\" },\n          \"'\",\n          { type: \"literal\", value: \"'\", description: \"\\\"'\\\"\" },\n          \"(\",\n          { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n          \")\",\n          { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n          peg$FAILED,\n          \"%\",\n          { type: \"literal\", value: \"%\", description: \"\\\"%\\\"\" },\n          function(escaped) {return escaped.join(''); },\n          null,\n          [],\n          function() {return \" \"; },\n          function() {return ':'; },\n          function() {\n                              return text(); },\n          /^[!-~]/,\n          { type: \"class\", value: \"[!-~]\", description: \"[!-~]\" },\n          /^[\\x80-\\uFFFF]/,\n          { type: \"class\", value: \"[\\\\x80-\\\\uFFFF]\", description: \"[\\\\x80-\\\\uFFFF]\" },\n          /^[\\x80-\\xBF]/,\n          { type: \"class\", value: \"[\\\\x80-\\\\xBF]\", description: \"[\\\\x80-\\\\xBF]\" },\n          /^[a-f]/,\n          { type: \"class\", value: \"[a-f]\", description: \"[a-f]\" },\n          \"`\",\n          { type: \"literal\", value: \"`\", description: \"\\\"`\\\"\" },\n          function() {\n                            return text(); },\n          \"<\",\n          { type: \"literal\", value: \"<\", description: \"\\\"<\\\"\" },\n          \">\",\n          { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n          \"\\\\\",\n          { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\n          \"[\",\n          { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n          \"]\",\n          { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n          \"{\",\n          { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\n          \"}\",\n          { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n          function() {return \"*\"; },\n          function() {return \"/\"; },\n          function() {return \"=\"; },\n          function() {return \"(\"; },\n          function() {return \")\"; },\n          function() {return \">\"; },\n          function() {return \"<\"; },\n          function() {return \",\"; },\n          function() {return \";\"; },\n          function() {return \":\"; },\n          function() {return \"\\\"\"; },\n          /^[!-']/,\n          { type: \"class\", value: \"[!-']\", description: \"[!-']\" },\n          /^[*-[]/,\n          { type: \"class\", value: \"[*-[]\", description: \"[*-[]\" },\n          /^[\\]-~]/,\n          { type: \"class\", value: \"[\\\\]-~]\", description: \"[\\\\]-~]\" },\n          function(contents) {\n                                  return contents; },\n          /^[#-[]/,\n          { type: \"class\", value: \"[#-[]\", description: \"[#-[]\" },\n          /^[\\0-\\t]/,\n          { type: \"class\", value: \"[\\\\0-\\\\t]\", description: \"[\\\\0-\\\\t]\" },\n          /^[\\x0B-\\f]/,\n          { type: \"class\", value: \"[\\\\x0B-\\\\f]\", description: \"[\\\\x0B-\\\\f]\" },\n          /^[\\x0E-]/,\n          { type: \"class\", value: \"[\\\\x0E-]\", description: \"[\\\\x0E-]\" },\n          function() {\n                                  data.uri = new SIP.URI(data.scheme, data.user, data.host, data.port);\n                                  delete data.scheme;\n                                  delete data.user;\n                                  delete data.host;\n                                  delete data.host_type;\n                                  delete data.port;\n                                },\n          function() {\n                                  data.uri = new SIP.URI(data.scheme, data.user, data.host, data.port, data.uri_params, data.uri_headers);\n                                  delete data.scheme;\n                                  delete data.user;\n                                  delete data.host;\n                                  delete data.host_type;\n                                  delete data.port;\n                                  delete data.uri_params;\n\n                                  if (options.startRule === 'SIP_URI') { data = data.uri;}\n                                },\n          \"sips\",\n          { type: \"literal\", value: \"sips\", description: \"\\\"sips\\\"\" },\n          \"sip\",\n          { type: \"literal\", value: \"sip\", description: \"\\\"sip\\\"\" },\n          function(uri_scheme) {\n                              data.scheme = uri_scheme.toLowerCase(); },\n          function() {\n                              data.user = decodeURIComponent(text().slice(0, -1));},\n          function() {\n                              data.password = text(); },\n          function() {\n                              data.host = text().toLowerCase();\n                              return data.host; },\n          function() {\n                            data.host_type = 'domain';\n                            return text(); },\n          /^[a-zA-Z0-9_\\-]/,\n          { type: \"class\", value: \"[a-zA-Z0-9_\\\\-]\", description: \"[a-zA-Z0-9_\\\\-]\" },\n          /^[a-zA-Z0-9\\-]/,\n          { type: \"class\", value: \"[a-zA-Z0-9\\\\-]\", description: \"[a-zA-Z0-9\\\\-]\" },\n          function() {\n                              data.host_type = 'IPv6';\n                              return text(); },\n          \"::\",\n          { type: \"literal\", value: \"::\", description: \"\\\"::\\\"\" },\n          function() {\n                            data.host_type = 'IPv6';\n                            return text(); },\n          function() {\n                              data.host_type = 'IPv4';\n                              return text(); },\n          \"25\",\n          { type: \"literal\", value: \"25\", description: \"\\\"25\\\"\" },\n          /^[0-5]/,\n          { type: \"class\", value: \"[0-5]\", description: \"[0-5]\" },\n          \"2\",\n          { type: \"literal\", value: \"2\", description: \"\\\"2\\\"\" },\n          /^[0-4]/,\n          { type: \"class\", value: \"[0-4]\", description: \"[0-4]\" },\n          \"1\",\n          { type: \"literal\", value: \"1\", description: \"\\\"1\\\"\" },\n          /^[1-9]/,\n          { type: \"class\", value: \"[1-9]\", description: \"[1-9]\" },\n          function(port) {\n                              port = parseInt(port.join(''));\n                              data.port = port;\n                              return port; },\n          \"transport=\",\n          { type: \"literal\", value: \"transport=\", description: \"\\\"transport=\\\"\" },\n          \"udp\",\n          { type: \"literal\", value: \"udp\", description: \"\\\"udp\\\"\" },\n          \"tcp\",\n          { type: \"literal\", value: \"tcp\", description: \"\\\"tcp\\\"\" },\n          \"sctp\",\n          { type: \"literal\", value: \"sctp\", description: \"\\\"sctp\\\"\" },\n          \"tls\",\n          { type: \"literal\", value: \"tls\", description: \"\\\"tls\\\"\" },\n          function(transport) {\n                                if(!data.uri_params) data.uri_params={};\n                                data.uri_params['transport'] = transport.toLowerCase(); },\n          \"user=\",\n          { type: \"literal\", value: \"user=\", description: \"\\\"user=\\\"\" },\n          \"phone\",\n          { type: \"literal\", value: \"phone\", description: \"\\\"phone\\\"\" },\n          \"ip\",\n          { type: \"literal\", value: \"ip\", description: \"\\\"ip\\\"\" },\n          function(user) {\n                                if(!data.uri_params) data.uri_params={};\n                                data.uri_params['user'] = user.toLowerCase(); },\n          \"method=\",\n          { type: \"literal\", value: \"method=\", description: \"\\\"method=\\\"\" },\n          function(method) {\n                                if(!data.uri_params) data.uri_params={};\n                                data.uri_params['method'] = method; },\n          \"ttl=\",\n          { type: \"literal\", value: \"ttl=\", description: \"\\\"ttl=\\\"\" },\n          function(ttl) {\n                                if(!data.params) data.params={};\n                                data.params['ttl'] = ttl; },\n          \"maddr=\",\n          { type: \"literal\", value: \"maddr=\", description: \"\\\"maddr=\\\"\" },\n          function(maddr) {\n                                if(!data.uri_params) data.uri_params={};\n                                data.uri_params['maddr'] = maddr; },\n          \"lr\",\n          { type: \"literal\", value: \"lr\", description: \"\\\"lr\\\"\" },\n          function() {\n                                if(!data.uri_params) data.uri_params={};\n                                data.uri_params['lr'] = undefined; },\n          function(param, value) {\n                                if(!data.uri_params) data.uri_params = {};\n                                if (value === null){\n                                  value = undefined;\n                                }\n                                else {\n                                  value = value[1];\n                                }\n                                data.uri_params[param.toLowerCase()] = value && value.toLowerCase();},\n          function(pname) {return pname.join(''); },\n          function(pvalue) {return pvalue.join(''); },\n          function(hname, hvalue) {\n                                hname = hname.join('').toLowerCase();\n                                hvalue = hvalue.join('');\n                                if(!data.uri_headers) data.uri_headers = {};\n                                if (!data.uri_headers[hname]) {\n                                  data.uri_headers[hname] = [hvalue];\n                                } else {\n                                  data.uri_headers[hname].push(hvalue);\n                                }},\n          function() {\n                                // lots of tests fail if this isn't guarded...\n                                if (options.startRule === 'Refer_To') {\n                                  data.uri = new SIP.URI(data.scheme, data.user, data.host, data.port, data.uri_params, data.uri_headers);\n                                  delete data.scheme;\n                                  delete data.user;\n                                  delete data.host;\n                                  delete data.host_type;\n                                  delete data.port;\n                                  delete data.uri_params;\n                                }\n                              },\n          \"//\",\n          { type: \"literal\", value: \"//\", description: \"\\\"//\\\"\" },\n          function() {\n                              data.scheme= text(); },\n          { type: \"literal\", value: \"SIP\", description: \"\\\"SIP\\\"\" },\n          function() {\n                              data.sip_version = text(); },\n          \"INVITE\",\n          { type: \"literal\", value: \"INVITE\", description: \"\\\"INVITE\\\"\" },\n          \"ACK\",\n          { type: \"literal\", value: \"ACK\", description: \"\\\"ACK\\\"\" },\n          \"VXACH\",\n          { type: \"literal\", value: \"VXACH\", description: \"\\\"VXACH\\\"\" },\n          \"OPTIONS\",\n          { type: \"literal\", value: \"OPTIONS\", description: \"\\\"OPTIONS\\\"\" },\n          \"BYE\",\n          { type: \"literal\", value: \"BYE\", description: \"\\\"BYE\\\"\" },\n          \"CANCEL\",\n          { type: \"literal\", value: \"CANCEL\", description: \"\\\"CANCEL\\\"\" },\n          \"REGISTER\",\n          { type: \"literal\", value: \"REGISTER\", description: \"\\\"REGISTER\\\"\" },\n          \"SUBSCRIBE\",\n          { type: \"literal\", value: \"SUBSCRIBE\", description: \"\\\"SUBSCRIBE\\\"\" },\n          \"NOTIFY\",\n          { type: \"literal\", value: \"NOTIFY\", description: \"\\\"NOTIFY\\\"\" },\n          \"REFER\",\n          { type: \"literal\", value: \"REFER\", description: \"\\\"REFER\\\"\" },\n          function() {\n\n                              data.method = text();\n                              return data.method; },\n          function(status_code) {\n                            data.status_code = parseInt(status_code.join('')); },\n          function() {\n                            data.reason_phrase = text(); },\n          function() {\n                        data = text(); },\n          function() {\n                                  var idx, length;\n                                  length = data.multi_header.length;\n                                  for (idx = 0; idx < length; idx++) {\n                                    if (data.multi_header[idx].parsed === null) {\n                                      data = null;\n                                      break;\n                                    }\n                                  }\n                                  if (data !== null) {\n                                    data = data.multi_header;\n                                  } else {\n                                    data = -1;\n                                  }},\n          function() {\n                                  var header;\n                                  if(!data.multi_header) data.multi_header = [];\n                                  try {\n                                    header = new SIP.NameAddrHeader(data.uri, data.displayName, data.params);\n                                    delete data.uri;\n                                    delete data.displayName;\n                                    delete data.params;\n                                  } catch(e) {\n                                    header = null;\n                                  }\n                                  data.multi_header.push( { 'position': peg$currPos,\n                                                            'offset': offset(),\n                                                            'parsed': header\n                                                          });},\n          function(displayName) {\n                                  displayName = text().trim();\n                                  if (displayName[0] === '\\\"') {\n                                    displayName = displayName.substring(1, displayName.length-1);\n                                  }\n                                  data.displayName = displayName; },\n          \"q\",\n          { type: \"literal\", value: \"q\", description: \"\\\"q\\\"\" },\n          function(q) {\n                                  if(!data.params) data.params = {};\n                                  data.params['q'] = q; },\n          \"expires\",\n          { type: \"literal\", value: \"expires\", description: \"\\\"expires\\\"\" },\n          function(expires) {\n                                  if(!data.params) data.params = {};\n                                  data.params['expires'] = expires; },\n          function(delta_seconds) {\n                                  return parseInt(delta_seconds.join('')); },\n          \"0\",\n          { type: \"literal\", value: \"0\", description: \"\\\"0\\\"\" },\n          function() {\n                                  return parseFloat(text()); },\n          function(param, value) {\n                                  if(!data.params) data.params = {};\n                                  if (value === null){\n                                    value = undefined;\n                                  }\n                                  else {\n                                    value = value[1];\n                                  }\n                                  data.params[param.toLowerCase()] = value;},\n          \"render\",\n          { type: \"literal\", value: \"render\", description: \"\\\"render\\\"\" },\n          \"session\",\n          { type: \"literal\", value: \"session\", description: \"\\\"session\\\"\" },\n          \"icon\",\n          { type: \"literal\", value: \"icon\", description: \"\\\"icon\\\"\" },\n          \"alert\",\n          { type: \"literal\", value: \"alert\", description: \"\\\"alert\\\"\" },\n          function() {\n                                      if (options.startRule === 'Content_Disposition') {\n                                        data.type = text().toLowerCase();\n                                      }\n                                    },\n          \"handling\",\n          { type: \"literal\", value: \"handling\", description: \"\\\"handling\\\"\" },\n          \"optional\",\n          { type: \"literal\", value: \"optional\", description: \"\\\"optional\\\"\" },\n          \"required\",\n          { type: \"literal\", value: \"required\", description: \"\\\"required\\\"\" },\n          function(length) {\n                                  data = parseInt(length.join('')); },\n          function() {\n                                  data = text(); },\n          \"text\",\n          { type: \"literal\", value: \"text\", description: \"\\\"text\\\"\" },\n          \"image\",\n          { type: \"literal\", value: \"image\", description: \"\\\"image\\\"\" },\n          \"audio\",\n          { type: \"literal\", value: \"audio\", description: \"\\\"audio\\\"\" },\n          \"video\",\n          { type: \"literal\", value: \"video\", description: \"\\\"video\\\"\" },\n          \"application\",\n          { type: \"literal\", value: \"application\", description: \"\\\"application\\\"\" },\n          \"message\",\n          { type: \"literal\", value: \"message\", description: \"\\\"message\\\"\" },\n          \"multipart\",\n          { type: \"literal\", value: \"multipart\", description: \"\\\"multipart\\\"\" },\n          \"x-\",\n          { type: \"literal\", value: \"x-\", description: \"\\\"x-\\\"\" },\n          function(cseq_value) {\n                            data.value=parseInt(cseq_value.join('')); },\n          function(expires) {data = expires; },\n          function(event_type) {\n                                 data.event = event_type.toLowerCase(); },\n          function() {\n                          var tag = data.tag;\n                            data = new SIP.NameAddrHeader(data.uri, data.displayName, data.params);\n                            if (tag) {data.setParam('tag',tag)}\n                          },\n          \"tag\",\n          { type: \"literal\", value: \"tag\", description: \"\\\"tag\\\"\" },\n          function(tag) {data.tag = tag; },\n          function(forwards) {\n                            data = parseInt(forwards.join('')); },\n          function(min_expires) {data = min_expires; },\n          function() {\n                                  data = new SIP.NameAddrHeader(data.uri, data.displayName, data.params);\n                                },\n          \"digest\",\n          { type: \"literal\", value: \"Digest\", description: \"\\\"Digest\\\"\" },\n          \"realm\",\n          { type: \"literal\", value: \"realm\", description: \"\\\"realm\\\"\" },\n          function(realm) { data.realm = realm; },\n          \"domain\",\n          { type: \"literal\", value: \"domain\", description: \"\\\"domain\\\"\" },\n          \"nonce\",\n          { type: \"literal\", value: \"nonce\", description: \"\\\"nonce\\\"\" },\n          function(nonce) { data.nonce=nonce; },\n          \"opaque\",\n          { type: \"literal\", value: \"opaque\", description: \"\\\"opaque\\\"\" },\n          function(opaque) { data.opaque=opaque; },\n          \"stale\",\n          { type: \"literal\", value: \"stale\", description: \"\\\"stale\\\"\" },\n          \"true\",\n          { type: \"literal\", value: \"true\", description: \"\\\"true\\\"\" },\n          function() { data.stale=true; },\n          \"false\",\n          { type: \"literal\", value: \"false\", description: \"\\\"false\\\"\" },\n          function() { data.stale=false; },\n          \"algorithm\",\n          { type: \"literal\", value: \"algorithm\", description: \"\\\"algorithm\\\"\" },\n          \"md5\",\n          { type: \"literal\", value: \"MD5\", description: \"\\\"MD5\\\"\" },\n          \"md5-sess\",\n          { type: \"literal\", value: \"MD5-sess\", description: \"\\\"MD5-sess\\\"\" },\n          function(algorithm) {\n                                data.algorithm=algorithm.toUpperCase(); },\n          \"qop\",\n          { type: \"literal\", value: \"qop\", description: \"\\\"qop\\\"\" },\n          \"auth-int\",\n          { type: \"literal\", value: \"auth-int\", description: \"\\\"auth-int\\\"\" },\n          \"auth\",\n          { type: \"literal\", value: \"auth\", description: \"\\\"auth\\\"\" },\n          function(qop_value) {\n                                  data.qop || (data.qop=[]);\n                                  data.qop.push(qop_value.toLowerCase()); },\n          function(rack_value) {\n                            data.value=parseInt(rack_value.join('')); },\n          function() {\n                            var idx, length;\n                            length = data.multi_header.length;\n                            for (idx = 0; idx < length; idx++) {\n                              if (data.multi_header[idx].parsed === null) {\n                                data = null;\n                                break;\n                              }\n                            }\n                            if (data !== null) {\n                              data = data.multi_header;\n                            } else {\n                              data = -1;\n                            }},\n          function() {\n                            var header;\n                            if(!data.multi_header) data.multi_header = [];\n                            try {\n                              header = new SIP.NameAddrHeader(data.uri, data.displayName, data.params);\n                              delete data.uri;\n                              delete data.displayName;\n                              delete data.params;\n                            } catch(e) {\n                              header = null;\n                            }\n                            data.multi_header.push( { 'position': peg$currPos,\n                                                      'offset': offset(),\n                                                      'parsed': header\n                                                    });},\n          function() {\n                        data = new SIP.NameAddrHeader(data.uri, data.displayName, data.params);\n                      },\n          function(rseq_value) {\n                            data.value=parseInt(rseq_value.join('')); },\n          \"active\",\n          { type: \"literal\", value: \"active\", description: \"\\\"active\\\"\" },\n          \"pending\",\n          { type: \"literal\", value: \"pending\", description: \"\\\"pending\\\"\" },\n          \"terminated\",\n          { type: \"literal\", value: \"terminated\", description: \"\\\"terminated\\\"\" },\n          function() {\n                                  data.state = text(); },\n          \"reason\",\n          { type: \"literal\", value: \"reason\", description: \"\\\"reason\\\"\" },\n          function(reason) {\n                                  if (typeof reason !== 'undefined') data.reason = reason; },\n          function(expires) {\n                                  if (typeof expires !== 'undefined') data.expires = expires; },\n          \"retry_after\",\n          { type: \"literal\", value: \"retry_after\", description: \"\\\"retry_after\\\"\" },\n          function(retry_after) {\n                                  if (typeof retry_after !== 'undefined') data.retry_after = retry_after; },\n          \"deactivated\",\n          { type: \"literal\", value: \"deactivated\", description: \"\\\"deactivated\\\"\" },\n          \"probation\",\n          { type: \"literal\", value: \"probation\", description: \"\\\"probation\\\"\" },\n          \"rejected\",\n          { type: \"literal\", value: \"rejected\", description: \"\\\"rejected\\\"\" },\n          \"timeout\",\n          { type: \"literal\", value: \"timeout\", description: \"\\\"timeout\\\"\" },\n          \"giveup\",\n          { type: \"literal\", value: \"giveup\", description: \"\\\"giveup\\\"\" },\n          \"noresource\",\n          { type: \"literal\", value: \"noresource\", description: \"\\\"noresource\\\"\" },\n          \"invariant\",\n          { type: \"literal\", value: \"invariant\", description: \"\\\"invariant\\\"\" },\n          function() {\n                        var tag = data.tag;\n                          data = new SIP.NameAddrHeader(data.uri, data.displayName, data.params);\n                          if (tag) {data.setParam('tag',tag)}\n                        },\n          \"ttl\",\n          { type: \"literal\", value: \"ttl\", description: \"\\\"ttl\\\"\" },\n          function(via_ttl_value) {\n                                data.ttl = via_ttl_value; },\n          \"maddr\",\n          { type: \"literal\", value: \"maddr\", description: \"\\\"maddr\\\"\" },\n          function(via_maddr) {\n                                data.maddr = via_maddr; },\n          \"received\",\n          { type: \"literal\", value: \"received\", description: \"\\\"received\\\"\" },\n          function(via_received) {\n                                data.received = via_received; },\n          \"branch\",\n          { type: \"literal\", value: \"branch\", description: \"\\\"branch\\\"\" },\n          function(via_branch) {\n                                data.branch = via_branch; },\n          \"rport\",\n          { type: \"literal\", value: \"rport\", description: \"\\\"rport\\\"\" },\n          function() {\n                                if(typeof response_port !== 'undefined')\n                                  data.rport = response_port.join(''); },\n          function(via_protocol) {\n                                data.protocol = via_protocol; },\n          { type: \"literal\", value: \"UDP\", description: \"\\\"UDP\\\"\" },\n          { type: \"literal\", value: \"TCP\", description: \"\\\"TCP\\\"\" },\n          { type: \"literal\", value: \"TLS\", description: \"\\\"TLS\\\"\" },\n          { type: \"literal\", value: \"SCTP\", description: \"\\\"SCTP\\\"\" },\n          function(via_transport) {\n                                data.transport = via_transport; },\n          function() {\n                                data.host = text(); },\n          function(via_sent_by_port) {\n                                data.port = parseInt(via_sent_by_port.join('')); },\n          function(ttl) {\n                                return parseInt(ttl.join('')); },\n          \"stuns\",\n          { type: \"literal\", value: \"stuns\", description: \"\\\"stuns\\\"\" },\n          \"stun\",\n          { type: \"literal\", value: \"stun\", description: \"\\\"stun\\\"\" },\n          function(scheme) {\n                                data.scheme = scheme; },\n          function(host) {\n                                data.host = host; },\n          function() {\n                                return text(); },\n          \"?transport=\",\n          { type: \"literal\", value: \"?transport=\", description: \"\\\"?transport=\\\"\" },\n          \"turns\",\n          { type: \"literal\", value: \"turns\", description: \"\\\"turns\\\"\" },\n          \"turn\",\n          { type: \"literal\", value: \"turn\", description: \"\\\"turn\\\"\" },\n          function() {\n                                data.transport = transport; },\n          function() {\n                            data = text(); }\n        ],\n\n        peg$bytecode = [\n          peg$decode(\". \\\"\\\"2 3!\"),\n          peg$decode(\"0\\\"\\\"\\\"1!3#\"),\n          peg$decode(\"0$\\\"\\\"1!3%\"),\n          peg$decode(\"0&\\\"\\\"1!3'\"),\n          peg$decode(\"7'*# \\\"7(\"),\n          peg$decode(\"0(\\\"\\\"1!3)\"),\n          peg$decode(\"0*\\\"\\\"1!3+\"),\n          peg$decode(\".,\\\"\\\"2,3-\"),\n          peg$decode(\"..\\\"\\\"2.3/\"),\n          peg$decode(\"00\\\"\\\"1!31\"),\n          peg$decode(\".2\\\"\\\"2233*\\x89 \\\".4\\\"\\\"2435*} \\\".6\\\"\\\"2637*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n          peg$decode(\"7)*# \\\"7,\"),\n          peg$decode(\".F\\\"\\\"2F3G*} \\\".H\\\"\\\"2H3I*q \\\".J\\\"\\\"2J3K*e \\\".L\\\"\\\"2L3M*Y \\\".N\\\"\\\"2N3O*M \\\".P\\\"\\\"2P3Q*A \\\".R\\\"\\\"2R3S*5 \\\".T\\\"\\\"2T3U*) \\\".V\\\"\\\"2V3W\"),\n          peg$decode(\"!!.Y\\\"\\\"2Y3Z+7$7#+-%7#+#%'#%$## X$\\\"# X\\\"# X+' 4!6[!! %\"),\n          peg$decode(\"!! ]7$,#&7$\\\"+-$7 +#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+@$ ]7$+&$,#&7$\\\"\\\"\\\" X+'%4\\\"6^\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"7.*# \\\" \\\\\"),\n          peg$decode(\"! ]7'*# \\\"7(,)&7'*# \\\"7(\\\"+A$.8\\\"\\\"2839+1%7/+'%4#6_# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]72+&$,#&72\\\"\\\"\\\" X+s$ ]! ]7.,#&7.\\\"+-$72+#%'\\\"%$\\\"# X\\\"# X,@&! ]7.,#&7.\\\"+-$72+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6`\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"0a\\\"\\\"1!3b*# \\\"73\"),\n          peg$decode(\"0c\\\"\\\"1!3d\"),\n          peg$decode(\"0e\\\"\\\"1!3f\"),\n          peg$decode(\"7!*) \\\"0g\\\"\\\"1!3h\"),\n          peg$decode(\"! ]7)*\\x95 \\\".F\\\"\\\"2F3G*\\x89 \\\".J\\\"\\\"2J3K*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".i\\\"\\\"2i3j*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O+\\x9E$,\\x9B&7)*\\x95 \\\".F\\\"\\\"2F3G*\\x89 \\\".J\\\"\\\"2J3K*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".i\\\"\\\"2i3j*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O\\\"\\\"\\\" X+& 4!6k! %\"),\n          peg$decode(\"! ]7)*\\x89 \\\".F\\\"\\\"2F3G*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".i\\\"\\\"2i3j*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O+\\x92$,\\x8F&7)*\\x89 \\\".F\\\"\\\"2F3G*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".i\\\"\\\"2i3j*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O\\\"\\\"\\\" X+& 4!6k! %\"),\n          peg$decode(\".T\\\"\\\"2T3U*\\xE3 \\\".V\\\"\\\"2V3W*\\xD7 \\\".l\\\"\\\"2l3m*\\xCB \\\".n\\\"\\\"2n3o*\\xBF \\\".:\\\"\\\"2:3;*\\xB3 \\\".D\\\"\\\"2D3E*\\xA7 \\\".2\\\"\\\"2233*\\x9B \\\".8\\\"\\\"2839*\\x8F \\\".p\\\"\\\"2p3q*\\x83 \\\"7&*} \\\".4\\\"\\\"2435*q \\\".r\\\"\\\"2r3s*e \\\".t\\\"\\\"2t3u*Y \\\".6\\\"\\\"2637*M \\\".>\\\"\\\"2>3?*A \\\".v\\\"\\\"2v3w*5 \\\".x\\\"\\\"2x3y*) \\\"7'*# \\\"7(\"),\n          peg$decode(\"! ]7)*\\u012B \\\".F\\\"\\\"2F3G*\\u011F \\\".J\\\"\\\"2J3K*\\u0113 \\\".L\\\"\\\"2L3M*\\u0107 \\\".Y\\\"\\\"2Y3Z*\\xFB \\\".P\\\"\\\"2P3Q*\\xEF \\\".H\\\"\\\"2H3I*\\xE3 \\\".@\\\"\\\"2@3A*\\xD7 \\\".i\\\"\\\"2i3j*\\xCB \\\".R\\\"\\\"2R3S*\\xBF \\\".N\\\"\\\"2N3O*\\xB3 \\\".T\\\"\\\"2T3U*\\xA7 \\\".V\\\"\\\"2V3W*\\x9B \\\".l\\\"\\\"2l3m*\\x8F \\\".n\\\"\\\"2n3o*\\x83 \\\".8\\\"\\\"2839*w \\\".p\\\"\\\"2p3q*k \\\"7&*e \\\".4\\\"\\\"2435*Y \\\".r\\\"\\\"2r3s*M \\\".t\\\"\\\"2t3u*A \\\".6\\\"\\\"2637*5 \\\".v\\\"\\\"2v3w*) \\\".x\\\"\\\"2x3y+\\u0134$,\\u0131&7)*\\u012B \\\".F\\\"\\\"2F3G*\\u011F \\\".J\\\"\\\"2J3K*\\u0113 \\\".L\\\"\\\"2L3M*\\u0107 \\\".Y\\\"\\\"2Y3Z*\\xFB \\\".P\\\"\\\"2P3Q*\\xEF \\\".H\\\"\\\"2H3I*\\xE3 \\\".@\\\"\\\"2@3A*\\xD7 \\\".i\\\"\\\"2i3j*\\xCB \\\".R\\\"\\\"2R3S*\\xBF \\\".N\\\"\\\"2N3O*\\xB3 \\\".T\\\"\\\"2T3U*\\xA7 \\\".V\\\"\\\"2V3W*\\x9B \\\".l\\\"\\\"2l3m*\\x8F \\\".n\\\"\\\"2n3o*\\x83 \\\".8\\\"\\\"2839*w \\\".p\\\"\\\"2p3q*k \\\"7&*e \\\".4\\\"\\\"2435*Y \\\".r\\\"\\\"2r3s*M \\\".t\\\"\\\"2t3u*A \\\".6\\\"\\\"2637*5 \\\".v\\\"\\\"2v3w*) \\\".x\\\"\\\"2x3y\\\"\\\"\\\" X+& 4!6k! %\"),\n          peg$decode(\"!7/+A$.P\\\"\\\"2P3Q+1%7/+'%4#6z# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.4\\\"\\\"2435+1%7/+'%4#6{# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.>\\\"\\\"2>3?+1%7/+'%4#6|# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.T\\\"\\\"2T3U+1%7/+'%4#6}# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.V\\\"\\\"2V3W+1%7/+'%4#6~# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!.n\\\"\\\"2n3o+1$7/+'%4\\\"6\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+7$.l\\\"\\\"2l3m+'%4\\\"6\\x80\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.D\\\"\\\"2D3E+1%7/+'%4#6\\x81# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.2\\\"\\\"2233+1%7/+'%4#6\\x82# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.8\\\"\\\"2839+1%7/+'%4#6\\x83# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+1$7&+'%4\\\"6\\x84\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7&+1$7/+'%4\\\"6\\x84\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7=+W$ ]7G*) \\\"7K*# \\\"7F,/&7G*) \\\"7K*# \\\"7F\\\"+-%7>+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"0\\x85\\\"\\\"1!3\\x86*A \\\"0\\x87\\\"\\\"1!3\\x88*5 \\\"0\\x89\\\"\\\"1!3\\x8A*) \\\"73*# \\\"7.\"),\n          peg$decode(\"!7/+Y$7&+O% ]7J*# \\\"7K,)&7J*# \\\"7K\\\"+1%7&+'%4$6k$ %$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+`$7&+V%! ]7J*# \\\"7K,)&7J*# \\\"7K\\\"+! (%+2%7&+(%4$6\\x8B$!!%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7.*G \\\".L\\\"\\\"2L3M*; \\\"0\\x8C\\\"\\\"1!3\\x8D*/ \\\"0\\x89\\\"\\\"1!3\\x8A*# \\\"73\"),\n          peg$decode(\"!.p\\\"\\\"2p3q+K$0\\x8E\\\"\\\"1!3\\x8F*5 \\\"0\\x90\\\"\\\"1!3\\x91*) \\\"0\\x92\\\"\\\"1!3\\x93+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7N+Q$.8\\\"\\\"2839+A%7O*# \\\" \\\\+1%7S+'%4$6\\x94$ %$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7N+k$.8\\\"\\\"2839+[%7O*# \\\" \\\\+K%7S+A%7_+7%7l*# \\\" \\\\+'%4&6\\x95& %$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\x96\\\"\\\"1$3\\x97*) \\\"/\\x98\\\"\\\"1#3\\x99+' 4!6\\x9A!! %\"),\n          peg$decode(\"!7P+b$!.8\\\"\\\"2839+-$7R+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+7%.:\\\"\\\"2:3;+'%4#6\\x9B# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\" ]7+*) \\\"7-*# \\\"7Q+2$,/&7+*) \\\"7-*# \\\"7Q\\\"\\\"\\\" X\"),\n          peg$decode(\".<\\\"\\\"2<3=*q \\\".>\\\"\\\"2>3?*e \\\".@\\\"\\\"2@3A*Y \\\".B\\\"\\\"2B3C*M \\\".D\\\"\\\"2D3E*A \\\".2\\\"\\\"2233*5 \\\".6\\\"\\\"2637*) \\\".4\\\"\\\"2435\"),\n          peg$decode(\"! ]7+*_ \\\"7-*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E,e&7+*_ \\\"7-*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\\\"+& 4!6\\x9C! %\"),\n          peg$decode(\"!7T+N$!.8\\\"\\\"2839+-$7^+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7U*) \\\"7\\\\*# \\\"7X+& 4!6\\x9D! %\"),\n          peg$decode(\"! ]!7V+3$.J\\\"\\\"2J3K+#%'\\\"%$\\\"# X\\\"# X,>&!7V+3$.J\\\"\\\"2J3K+#%'\\\"%$\\\"# X\\\"# X\\\"+G$7W+=%.J\\\"\\\"2J3K*# \\\" \\\\+'%4#6\\x9E# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\" ]0\\x9F\\\"\\\"1!3\\xA0+,$,)&0\\x9F\\\"\\\"1!3\\xA0\\\"\\\"\\\" X\"),\n          peg$decode(\"!0$\\\"\\\"1!3%+A$ ]0\\xA1\\\"\\\"1!3\\xA2,)&0\\xA1\\\"\\\"1!3\\xA2\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!.r\\\"\\\"2r3s+A$7Y+7%.t\\\"\\\"2t3u+'%4#6\\xA3# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!!7Z+\\xBF$.8\\\"\\\"2839+\\xAF%7Z+\\xA5%.8\\\"\\\"2839+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'-%$-# X$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0838 \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+\\xAF$7Z+\\xA5%.8\\\"\\\"2839+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%',%$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0795 \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+\\x95$7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u070C \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+{$7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u069D \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+a$7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'&%$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0648 \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+G$7Z+=%.8\\\"\\\"2839+-%7[+#%'$%$$# X$## X$\\\"# X\\\"# X*\\u060D \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+-$7[+#%'\\\"%$\\\"# X\\\"# X*\\u05EC \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+-$7Z+#%'\\\"%$\\\"# X\\\"# X*\\u05CB \\\"!7Z+\\xA5$.\\xA4\\\"\\\"2\\xA43\\xA5+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'+%$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0538 \\\"!7Z+\\xB6$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\x8B%.\\xA4\\\"\\\"2\\xA43\\xA5+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0494 \\\"!7Z+\\xC7$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\x9C%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+q%.\\xA4\\\"\\\"2\\xA43\\xA5+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%')%$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u03DF \\\"!7Z+\\xD8$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\xAD%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\x82%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+W%.\\xA4\\\"\\\"2\\xA43\\xA5+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0319 \\\"!7Z+\\xE9$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\xBE%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\x93%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+h%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+=%.\\xA4\\\"\\\"2\\xA43\\xA5+-%7[+#%''%$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0242 \\\"!7Z+\\u0114$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\xE9%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\xBE%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\x93%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+h%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+=%.\\xA4\\\"\\\"2\\xA43\\xA5+-%7Z+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0140 \\\"!7Z+\\u0135$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\u010A%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\xDF%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\xB4%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\x89%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+^%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+3%.\\xA4\\\"\\\"2\\xA43\\xA5+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X+& 4!6\\xA6! %\"),\n          peg$decode(\"!7#+S$7#*# \\\" \\\\+C%7#*# \\\" \\\\+3%7#*# \\\" \\\\+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7Z+=$.8\\\"\\\"2839+-%7Z+#%'#%$## X$\\\"# X\\\"# X*# \\\"7\\\\\"),\n          peg$decode(\"!7]+u$.J\\\"\\\"2J3K+e%7]+[%.J\\\"\\\"2J3K+K%7]+A%.J\\\"\\\"2J3K+1%7]+'%4'6\\xA7' %$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!.\\xA8\\\"\\\"2\\xA83\\xA9+3$0\\xAA\\\"\\\"1!3\\xAB+#%'\\\"%$\\\"# X\\\"# X*\\xA0 \\\"!.\\xAC\\\"\\\"2\\xAC3\\xAD+=$0\\xAE\\\"\\\"1!3\\xAF+-%7!+#%'#%$## X$\\\"# X\\\"# X*o \\\"!.\\xB0\\\"\\\"2\\xB03\\xB1+7$7!+-%7!+#%'#%$## X$\\\"# X\\\"# X*D \\\"!0\\xB2\\\"\\\"1!3\\xB3+-$7!+#%'\\\"%$\\\"# X\\\"# X*# \\\"7!\"),\n          peg$decode(\"!!7!*# \\\" \\\\+c$7!*# \\\" \\\\+S%7!*# \\\" \\\\+C%7!*# \\\" \\\\+3%7!*# \\\" \\\\+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X+' 4!6\\xB4!! %\"),\n          peg$decode(\" ]!.2\\\"\\\"2233+-$7`+#%'\\\"%$\\\"# X\\\"# X,>&!.2\\\"\\\"2233+-$7`+#%'\\\"%$\\\"# X\\\"# X\\\"\"),\n          peg$decode(\"7a*A \\\"7b*; \\\"7c*5 \\\"7d*/ \\\"7e*) \\\"7f*# \\\"7g\"),\n          peg$decode(\"!/\\xB5\\\"\\\"1*3\\xB6+b$/\\xB7\\\"\\\"1#3\\xB8*G \\\"/\\xB9\\\"\\\"1#3\\xBA*; \\\"/\\xBB\\\"\\\"1$3\\xBC*/ \\\"/\\xBD\\\"\\\"1#3\\xBE*# \\\"76+(%4\\\"6\\xBF\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\xC0\\\"\\\"1%3\\xC1+J$/\\xC2\\\"\\\"1%3\\xC3*/ \\\"/\\xC4\\\"\\\"1\\\"3\\xC5*# \\\"76+(%4\\\"6\\xC6\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\xC7\\\"\\\"1'3\\xC8+2$7\\x8F+(%4\\\"6\\xC9\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\xCA\\\"\\\"1$3\\xCB+2$7\\xEC+(%4\\\"6\\xCC\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\xCD\\\"\\\"1&3\\xCE+2$7T+(%4\\\"6\\xCF\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\xD0\\\"\\\"1\\\"3\\xD1+R$!.>\\\"\\\"2>3?+-$76+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+'%4\\\"6\\xD2\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7h+T$!.>\\\"\\\"2>3?+-$7i+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+)%4\\\"6\\xD3\\\"\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7j+&$,#&7j\\\"\\\"\\\" X+' 4!6\\xD4!! %\"),\n          peg$decode(\"! ]7j+&$,#&7j\\\"\\\"\\\" X+' 4!6\\xD5!! %\"),\n          peg$decode(\"7k*) \\\"7+*# \\\"7-\"),\n          peg$decode(\".r\\\"\\\"2r3s*e \\\".t\\\"\\\"2t3u*Y \\\".4\\\"\\\"2435*M \\\".8\\\"\\\"2839*A \\\".<\\\"\\\"2<3=*5 \\\".@\\\"\\\"2@3A*) \\\".B\\\"\\\"2B3C\"),\n          peg$decode(\"!.6\\\"\\\"2637+u$7m+k% ]!.<\\\"\\\"2<3=+-$7m+#%'\\\"%$\\\"# X\\\"# X,>&!.<\\\"\\\"2<3=+-$7m+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7n+C$.>\\\"\\\"2>3?+3%7o+)%4#6\\xD6#\\\"\\\" %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\" ]7p*) \\\"7+*# \\\"7-+2$,/&7p*) \\\"7+*# \\\"7-\\\"\\\"\\\" X\"),\n          peg$decode(\" ]7p*) \\\"7+*# \\\"7-,/&7p*) \\\"7+*# \\\"7-\\\"\"),\n          peg$decode(\".r\\\"\\\"2r3s*e \\\".t\\\"\\\"2t3u*Y \\\".4\\\"\\\"2435*M \\\".6\\\"\\\"2637*A \\\".8\\\"\\\"2839*5 \\\".@\\\"\\\"2@3A*) \\\".B\\\"\\\"2B3C\"),\n          peg$decode(\"7\\x90*# \\\"7r\"),\n          peg$decode(\"!7\\x8F+K$7'+A%7s+7%7'+-%7\\x84+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7M*# \\\"7t\"),\n          peg$decode(\"!7+G$.8\\\"\\\"2839+7%7u*# \\\"7x+'%4#6\\xD7# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7v*# \\\"7w+N$!.6\\\"\\\"2637+-$7\\x83+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!.\\xD8\\\"\\\"2\\xD83\\xD9+=$7\\x80+3%7w*# \\\" \\\\+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!.4\\\"\\\"2435+-$7{+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7z+5$ ]7y,#&7y\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"7**) \\\"7+*# \\\"7-\"),\n          peg$decode(\"7+*\\x8F \\\"7-*\\x89 \\\".2\\\"\\\"2233*} \\\".6\\\"\\\"2637*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n          peg$decode(\"!7|+k$ ]!.4\\\"\\\"2435+-$7|+#%'\\\"%$\\\"# X\\\"# X,>&!.4\\\"\\\"2435+-$7|+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7~,#&7~\\\"+k$ ]!.2\\\"\\\"2233+-$7}+#%'\\\"%$\\\"# X\\\"# X,>&!.2\\\"\\\"2233+-$7}+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\" ]7~,#&7~\\\"\"),\n          peg$decode(\"7+*w \\\"7-*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n          peg$decode(\"!7\\\"+\\x8D$ ]7\\\"*G \\\"7!*A \\\".@\\\"\\\"2@3A*5 \\\".F\\\"\\\"2F3G*) \\\".J\\\"\\\"2J3K,M&7\\\"*G \\\"7!*A \\\".@\\\"\\\"2@3A*5 \\\".F\\\"\\\"2F3G*) \\\".J\\\"\\\"2J3K\\\"+'%4\\\"6\\xDA\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\x81*# \\\"7\\x82\"),\n          peg$decode(\"!!7O+3$.:\\\"\\\"2:3;+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+-$7S+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\\"),\n          peg$decode(\" ]7+*\\x83 \\\"7-*} \\\".B\\\"\\\"2B3C*q \\\".D\\\"\\\"2D3E*e \\\".2\\\"\\\"2233*Y \\\".8\\\"\\\"2839*M \\\".:\\\"\\\"2:3;*A \\\".<\\\"\\\"2<3=*5 \\\".>\\\"\\\"2>3?*) \\\".@\\\"\\\"2@3A+\\x8C$,\\x89&7+*\\x83 \\\"7-*} \\\".B\\\"\\\"2B3C*q \\\".D\\\"\\\"2D3E*e \\\".2\\\"\\\"2233*Y \\\".8\\\"\\\"2839*M \\\".:\\\"\\\"2:3;*A \\\".<\\\"\\\"2<3=*5 \\\".>\\\"\\\"2>3?*) \\\".@\\\"\\\"2@3A\\\"\\\"\\\" X\"),\n          peg$decode(\" ]7y,#&7y\\\"\"),\n          peg$decode(\"!/\\x98\\\"\\\"1#3\\xDB+y$.4\\\"\\\"2435+i% ]7!+&$,#&7!\\\"\\\"\\\" X+P%.J\\\"\\\"2J3K+@% ]7!+&$,#&7!\\\"\\\"\\\" X+'%4%6\\xDC% %$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\".\\xDD\\\"\\\"2\\xDD3\\xDE\"),\n          peg$decode(\".\\xDF\\\"\\\"2\\xDF3\\xE0\"),\n          peg$decode(\".\\xE1\\\"\\\"2\\xE13\\xE2\"),\n          peg$decode(\".\\xE3\\\"\\\"2\\xE33\\xE4\"),\n          peg$decode(\".\\xE5\\\"\\\"2\\xE53\\xE6\"),\n          peg$decode(\".\\xE7\\\"\\\"2\\xE73\\xE8\"),\n          peg$decode(\".\\xE9\\\"\\\"2\\xE93\\xEA\"),\n          peg$decode(\".\\xEB\\\"\\\"2\\xEB3\\xEC\"),\n          peg$decode(\".\\xED\\\"\\\"2\\xED3\\xEE\"),\n          peg$decode(\".\\xEF\\\"\\\"2\\xEF3\\xF0\"),\n          peg$decode(\"!7\\x85*S \\\"7\\x86*M \\\"7\\x88*G \\\"7\\x89*A \\\"7\\x8A*; \\\"7\\x8B*5 \\\"7\\x8C*/ \\\"7\\x8D*) \\\"7\\x8E*# \\\"76+& 4!6\\xF1! %\"),\n          peg$decode(\"!7\\x84+K$7'+A%7\\x91+7%7'+-%7\\x93+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\x92+' 4!6\\xF2!! %\"),\n          peg$decode(\"!7!+7$7!+-%7!+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7**A \\\"7+*; \\\"7-*5 \\\"73*/ \\\"74*) \\\"7'*# \\\"7(,G&7**A \\\"7+*; \\\"7-*5 \\\"73*/ \\\"74*) \\\"7'*# \\\"7(\\\"+& 4!6\\xF3! %\"),\n          peg$decode(\"!7\\xB5+_$ ]!7A+-$7\\xB5+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xB5+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!79+R$!.:\\\"\\\"2:3;+-$79+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+'%4\\\"6\\xF4\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7:*j \\\"!7\\x97+_$ ]!7A+-$7\\x97+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\x97+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+& 4!6\\xF5! %\"),\n          peg$decode(\"!7L*# \\\"7\\x98+c$ ]!7B+-$7\\x9A+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9A+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\xF6\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\x99*# \\\" \\\\+A$7@+7%7M+-%7?+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!!76+_$ ]!7.+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7.+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\"7H+' 4!6\\xF7!! %\"),\n          peg$decode(\"7\\x9B*) \\\"7\\x9C*# \\\"7\\x9F\"),\n          peg$decode(\"!/\\xF8\\\"\\\"1!3\\xF9+<$7<+2%7\\x9E+(%4#6\\xFA#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\xFB\\\"\\\"1'3\\xFC+<$7<+2%7\\x9D+(%4#6\\xFD#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\xFE!! %\"),\n          peg$decode(\"!.\\xFF\\\"\\\"2\\xFF3\\u0100+x$!.J\\\"\\\"2J3K+S$7!*# \\\" \\\\+C%7!*# \\\" \\\\+3%7!*# \\\" \\\\+#%'$%$$# X$## X$\\\"# X\\\"# X*# \\\" \\\\+'%4\\\"6\\u0101\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!76+N$!7<+-$7\\xA0+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+)%4\\\"6\\u0102\\\"\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"76*) \\\"7T*# \\\"7H\"),\n          peg$decode(\"!7\\xA2+_$ ]!7B+-$7\\xA3+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xA3+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u0103\\\"\\\"1&3\\u0104*G \\\"/\\u0105\\\"\\\"1'3\\u0106*; \\\"/\\u0107\\\"\\\"1$3\\u0108*/ \\\"/\\u0109\\\"\\\"1%3\\u010A*# \\\"76+& 4!6\\u010B! %\"),\n          peg$decode(\"7\\xA4*# \\\"7\\x9F\"),\n          peg$decode(\"!/\\u010C\\\"\\\"1(3\\u010D+O$7<+E%/\\u010E\\\"\\\"1(3\\u010F*/ \\\"/\\u0110\\\"\\\"1(3\\u0111*# \\\"76+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!76+_$ ]!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u0112!! %\"),\n          peg$decode(\"!7\\xA8+& 4!6\\u0113! %\"),\n          peg$decode(\"!7\\xA9+s$7;+i%7\\xAE+_% ]!7B+-$7\\xAF+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xAF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xAA*# \\\"7\\xAB\"),\n          peg$decode(\"/\\u0114\\\"\\\"1$3\\u0115*S \\\"/\\u0116\\\"\\\"1%3\\u0117*G \\\"/\\u0118\\\"\\\"1%3\\u0119*; \\\"/\\u011A\\\"\\\"1%3\\u011B*/ \\\"/\\u011C\\\"\\\"1+3\\u011D*# \\\"7\\xAC\"),\n          peg$decode(\"/\\u011E\\\"\\\"1'3\\u011F*/ \\\"/\\u0120\\\"\\\"1)3\\u0121*# \\\"7\\xAC\"),\n          peg$decode(\"76*# \\\"7\\xAD\"),\n          peg$decode(\"!/\\u0122\\\"\\\"1\\\"3\\u0123+-$76+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xAC*# \\\"76\"),\n          peg$decode(\"!76+7$7<+-%7\\xB0+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"76*# \\\"7H\"),\n          peg$decode(\"!7\\xB2+7$7.+-%7\\x8F+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u0124!! %\"),\n          peg$decode(\"!7\\x9D+' 4!6\\u0125!! %\"),\n          peg$decode(\"!7\\xB5+d$ ]!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u0126\\\"!!%$\\\"# X\\\"# X\"),\n          peg$decode(\"!!77+k$ ]!.J\\\"\\\"2J3K+-$77+#%'\\\"%$\\\"# X\\\"# X,>&!.J\\\"\\\"2J3K+-$77+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+! (%\"),\n          peg$decode(\"!7L*# \\\"7\\x98+c$ ]!7B+-$7\\xB7+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xB7+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0127\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xB8*# \\\"7\\x9F\"),\n          peg$decode(\"!/\\u0128\\\"\\\"1#3\\u0129+<$7<+2%76+(%4#6\\u012A#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u012B!! %\"),\n          peg$decode(\"!7\\x9D+' 4!6\\u012C!! %\"),\n          peg$decode(\"! ]7\\x99,#&7\\x99\\\"+\\x81$7@+w%7M+m%7?+c% ]!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4%6\\u012D% %$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xBD\"),\n          peg$decode(\"!/\\u012E\\\"\\\"1&3\\u012F+s$7.+i%7\\xC0+_% ]!7A+-$7\\xC0+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xC0+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X*# \\\"7\\xBE\"),\n          peg$decode(\"!76+s$7.+i%7\\xBF+_% ]!7A+-$7\\xBF+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xBF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!76+=$7<+3%76*# \\\"7H+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xC1*G \\\"7\\xC3*A \\\"7\\xC5*; \\\"7\\xC7*5 \\\"7\\xC8*/ \\\"7\\xC9*) \\\"7\\xCA*# \\\"7\\xBF\"),\n          peg$decode(\"!/\\u0130\\\"\\\"1%3\\u0131+7$7<+-%7\\xC2+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7I+' 4!6\\u0132!! %\"),\n          peg$decode(\"!/\\u0133\\\"\\\"1&3\\u0134+\\xA5$7<+\\x9B%7D+\\x91%7\\xC4+\\x87% ]! ]7'+&$,#&7'\\\"\\\"\\\" X+-$7\\xC4+#%'\\\"%$\\\"# X\\\"# X,G&! ]7'+&$,#&7'\\\"\\\"\\\" X+-$7\\xC4+#%'\\\"%$\\\"# X\\\"# X\\\"+-%7E+#%'&%$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7t*# \\\"7w\"),\n          peg$decode(\"!/\\u0135\\\"\\\"1%3\\u0136+7$7<+-%7\\xC6+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7I+' 4!6\\u0137!! %\"),\n          peg$decode(\"!/\\u0138\\\"\\\"1&3\\u0139+<$7<+2%7I+(%4#6\\u013A#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u013B\\\"\\\"1%3\\u013C+_$7<+U%!/\\u013D\\\"\\\"1$3\\u013E+& 4!6\\u013F! %*4 \\\"!/\\u0140\\\"\\\"1%3\\u0141+& 4!6\\u0142! %+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u0143\\\"\\\"1)3\\u0144+T$7<+J%/\\u0145\\\"\\\"1#3\\u0146*/ \\\"/\\u0147\\\"\\\"1(3\\u0148*# \\\"76+(%4#6\\u0149#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u014A\\\"\\\"1#3\\u014B+\\x9E$7<+\\x94%7D+\\x8A%!7\\xCB+k$ ]!.D\\\"\\\"2D3E+-$7\\xCB+#%'\\\"%$\\\"# X\\\"# X,>&!.D\\\"\\\"2D3E+-$7\\xCB+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+-%7E+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u014C\\\"\\\"1(3\\u014D*/ \\\"/\\u014E\\\"\\\"1$3\\u014F*# \\\"76+' 4!6\\u0150!! %\"),\n          peg$decode(\"!76+_$ ]!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xCE+K$7.+A%7\\xCE+7%7.+-%7\\x8F+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u0151!! %\"),\n          peg$decode(\"!7\\xD0+c$ ]!7A+-$7\\xD0+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xD0+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0152\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\x98+c$ ]!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0153\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7L*) \\\"7\\x98*# \\\"7t+c$ ]!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0154\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!76+_$ ]!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xD4+_$ ]!7A+-$7\\xD4+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xD4+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\x98+_$ ]!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u0155!! %\"),\n          peg$decode(\"!7\\xD7+_$ ]!7B+-$7\\xD8+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xD8+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u0156\\\"\\\"1&3\\u0157*; \\\"/\\u0158\\\"\\\"1'3\\u0159*/ \\\"/\\u015A\\\"\\\"1*3\\u015B*# \\\"76+& 4!6\\u015C! %\"),\n          peg$decode(\"!/\\u015D\\\"\\\"1&3\\u015E+<$7<+2%7\\xD9+(%4#6\\u015F#! %$## X$\\\"# X\\\"# X*\\x83 \\\"!/\\xFB\\\"\\\"1'3\\xFC+<$7<+2%7\\x9D+(%4#6\\u0160#! %$## X$\\\"# X\\\"# X*S \\\"!/\\u0161\\\"\\\"1+3\\u0162+<$7<+2%7\\x9D+(%4#6\\u0163#! %$## X$\\\"# X\\\"# X*# \\\"7\\x9F\"),\n          peg$decode(\"/\\u0164\\\"\\\"1+3\\u0165*k \\\"/\\u0166\\\"\\\"1)3\\u0167*_ \\\"/\\u0168\\\"\\\"1(3\\u0169*S \\\"/\\u016A\\\"\\\"1'3\\u016B*G \\\"/\\u016C\\\"\\\"1&3\\u016D*; \\\"/\\u016E\\\"\\\"1*3\\u016F*/ \\\"/\\u0170\\\"\\\"1)3\\u0171*# \\\"76\"),\n          peg$decode(\"71*# \\\" \\\\\"),\n          peg$decode(\"!76+_$ ]!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\\"),\n          peg$decode(\"!7L*# \\\"7\\x98+c$ ]!7B+-$7\\xDD+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xDD+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0172\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xB8*# \\\"7\\x9F\"),\n          peg$decode(\"!7\\xDF+_$ ]!7A+-$7\\xDF+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xDF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xE6+s$7.+i%7\\xE9+_% ]!7B+-$7\\xE0+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xE0+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xE1*; \\\"7\\xE2*5 \\\"7\\xE3*/ \\\"7\\xE4*) \\\"7\\xE5*# \\\"7\\x9F\"),\n          peg$decode(\"!/\\u0173\\\"\\\"1#3\\u0174+<$7<+2%7\\xEC+(%4#6\\u0175#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u0176\\\"\\\"1%3\\u0177+<$7<+2%7T+(%4#6\\u0178#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u0179\\\"\\\"1(3\\u017A+B$7<+8%7\\\\*# \\\"7Y+(%4#6\\u017B#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u017C\\\"\\\"1&3\\u017D+<$7<+2%76+(%4#6\\u017E#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u017F\\\"\\\"1%3\\u0180+T$!7<+5$ ]7!,#&7!\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+'%4\\\"6\\u0181\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xE7+K$7;+A%76+7%7;+-%7\\xE8+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\x98\\\"\\\"1#3\\xDB*# \\\"76+' 4!6\\u0182!! %\"),\n          peg$decode(\"!/\\xB7\\\"\\\"1#3\\u0183*G \\\"/\\xB9\\\"\\\"1#3\\u0184*; \\\"/\\xBD\\\"\\\"1#3\\u0185*/ \\\"/\\xBB\\\"\\\"1$3\\u0186*# \\\"76+' 4!6\\u0187!! %\"),\n          peg$decode(\"!7\\xEA+H$!7C+-$7\\xEB+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7U*) \\\"7\\\\*# \\\"7X+& 4!6\\u0188! %\"),\n          peg$decode(\"!!7!*# \\\" \\\\+c$7!*# \\\" \\\\+S%7!*# \\\" \\\\+C%7!*# \\\" \\\\+3%7!*# \\\" \\\\+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X+' 4!6\\u0189!! %\"),\n          peg$decode(\"!!7!+C$7!*# \\\" \\\\+3%7!*# \\\" \\\\+#%'#%$## X$\\\"# X\\\"# X+' 4!6\\u018A!! %\"),\n          peg$decode(\"7\\xBD\"),\n          peg$decode(\"!76+7$70+-%7\\xEF+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\" ]72*) \\\"74*# \\\"7.,/&72*) \\\"74*# \\\"7.\\\"\"),\n          peg$decode(\" ]7%,#&7%\\\"\"),\n          peg$decode(\"!7\\xF2+=$.8\\\"\\\"2839+-%7\\xF3+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u018B\\\"\\\"1%3\\u018C*) \\\"/\\u018D\\\"\\\"1$3\\u018E+' 4!6\\u018F!! %\"),\n          peg$decode(\"!7\\xF4+N$!.8\\\"\\\"2839+-$7^+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\\\*) \\\"7X*# \\\"7\\x82+' 4!6\\u0190!! %\"),\n          peg$decode(\"! ]7\\xF6*) \\\"7-*# \\\"7\\xF7,/&7\\xF6*) \\\"7-*# \\\"7\\xF7\\\"+& 4!6\\u0191! %\"),\n          peg$decode(\"7\\\"*S \\\"7!*M \\\".F\\\"\\\"2F3G*A \\\".J\\\"\\\"2J3K*5 \\\".H\\\"\\\"2H3I*) \\\".N\\\"\\\"2N3O\"),\n          peg$decode(\".L\\\"\\\"2L3M*\\x95 \\\".B\\\"\\\"2B3C*\\x89 \\\".<\\\"\\\"2<3=*} \\\".R\\\"\\\"2R3S*q \\\".T\\\"\\\"2T3U*e \\\".V\\\"\\\"2V3W*Y \\\".P\\\"\\\"2P3Q*M \\\".@\\\"\\\"2@3A*A \\\".D\\\"\\\"2D3E*5 \\\".2\\\"\\\"2233*) \\\".>\\\"\\\"2>3?\"),\n          peg$decode(\"!7\\xF9+h$.8\\\"\\\"2839+X%7\\xF3+N%!.\\u0192\\\"\\\"2\\u01923\\u0193+-$7\\xE8+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u0194\\\"\\\"1%3\\u0195*) \\\"/\\u0196\\\"\\\"1$3\\u0197+' 4!6\\u018F!! %\"),\n          peg$decode(\"!7\\xE8+Q$/\\xB7\\\"\\\"1#3\\xB8*7 \\\"/\\xB9\\\"\\\"1#3\\xBA*+ \\\" ]7+,#&7+\\\"+'%4\\\"6\\u0198\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xFD+\\x8F$.F\\\"\\\"2F3G+%7\\xFC+u%.F\\\"\\\"2F3G+e%7\\xFC+[%.F\\\"\\\"2F3G+K%7\\xFC+A%.F\\\"\\\"2F3G+1%7\\xFE+'%4)6\\u0199) %$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7#+A$7#+7%7#+-%7#+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xFC+-$7\\xFC+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xFC+7$7\\xFC+-%7\\xFC+#%'#%$## X$\\\"# X\\\"# X\")\n        ],\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleIndices)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleIndex = peg$startRuleIndices[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$decode(s) {\n      var bc = new Array(s.length), i;\n\n      for (i = 0; i < s.length; i++) {\n        bc[i] = s.charCodeAt(i) - 32;\n      }\n\n      return bc;\n    }\n\n    function peg$parseRule(index) {\n      var bc    = peg$bytecode[index],\n          ip    = 0,\n          ips   = [],\n          end   = bc.length,\n          ends  = [],\n          stack = [],\n          params, i;\n\n      function protect(object) {\n        return Object.prototype.toString.apply(object) === \"[object Array]\" ? [] : object;\n      }\n\n      while (true) {\n        while (ip < end) {\n          switch (bc[ip]) {\n            case 0:\n              stack.push(protect(peg$consts[bc[ip + 1]]));\n              ip += 2;\n              break;\n\n            case 1:\n              stack.push(peg$currPos);\n              ip++;\n              break;\n\n            case 2:\n              stack.pop();\n              ip++;\n              break;\n\n            case 3:\n              peg$currPos = stack.pop();\n              ip++;\n              break;\n\n            case 4:\n              stack.length -= bc[ip + 1];\n              ip += 2;\n              break;\n\n            case 5:\n              stack.splice(-2, 1);\n              ip++;\n              break;\n\n            case 6:\n              stack[stack.length - 2].push(stack.pop());\n              ip++;\n              break;\n\n            case 7:\n              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));\n              ip += 2;\n              break;\n\n            case 8:\n              stack.pop();\n              stack.push(input.substring(stack[stack.length - 1], peg$currPos));\n              ip++;\n              break;\n\n            case 9:\n              ends.push(end);\n              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n              if (stack[stack.length - 1]) {\n                end = ip + 3 + bc[ip + 1];\n                ip += 3;\n              } else {\n                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                ip += 3 + bc[ip + 1];\n              }\n\n              break;\n\n            case 10:\n              ends.push(end);\n              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n              if (stack[stack.length - 1] === peg$FAILED) {\n                end = ip + 3 + bc[ip + 1];\n                ip += 3;\n              } else {\n                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                ip += 3 + bc[ip + 1];\n              }\n\n              break;\n\n            case 11:\n              ends.push(end);\n              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n              if (stack[stack.length - 1] !== peg$FAILED) {\n                end = ip + 3 + bc[ip + 1];\n                ip += 3;\n              } else {\n                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                ip += 3 + bc[ip + 1];\n              }\n\n              break;\n\n            case 12:\n              if (stack[stack.length - 1] !== peg$FAILED) {\n                ends.push(end);\n                ips.push(ip);\n\n                end = ip + 2 + bc[ip + 1];\n                ip += 2;\n              } else {\n                ip += 2 + bc[ip + 1];\n              }\n\n              break;\n\n            case 13:\n              ends.push(end);\n              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n              if (input.length > peg$currPos) {\n                end = ip + 3 + bc[ip + 1];\n                ip += 3;\n              } else {\n                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                ip += 3 + bc[ip + 1];\n              }\n\n              break;\n\n            case 14:\n              ends.push(end);\n              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {\n                end = ip + 4 + bc[ip + 2];\n                ip += 4;\n              } else {\n                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n                ip += 4 + bc[ip + 2];\n              }\n\n              break;\n\n            case 15:\n              ends.push(end);\n              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {\n                end = ip + 4 + bc[ip + 2];\n                ip += 4;\n              } else {\n                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n                ip += 4 + bc[ip + 2];\n              }\n\n              break;\n\n            case 16:\n              ends.push(end);\n              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {\n                end = ip + 4 + bc[ip + 2];\n                ip += 4;\n              } else {\n                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n                ip += 4 + bc[ip + 2];\n              }\n\n              break;\n\n            case 17:\n              stack.push(input.substr(peg$currPos, bc[ip + 1]));\n              peg$currPos += bc[ip + 1];\n              ip += 2;\n              break;\n\n            case 18:\n              stack.push(peg$consts[bc[ip + 1]]);\n              peg$currPos += peg$consts[bc[ip + 1]].length;\n              ip += 2;\n              break;\n\n            case 19:\n              stack.push(peg$FAILED);\n              if (peg$silentFails === 0) {\n                peg$fail(peg$consts[bc[ip + 1]]);\n              }\n              ip += 2;\n              break;\n\n            case 20:\n              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];\n              ip += 2;\n              break;\n\n            case 21:\n              peg$reportedPos = peg$currPos;\n              ip++;\n              break;\n\n            case 22:\n              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);\n              for (i = 0; i < bc[ip + 3]; i++) {\n                params[i] = stack[stack.length - 1 - params[i]];\n              }\n\n              stack.splice(\n                stack.length - bc[ip + 2],\n                bc[ip + 2],\n                peg$consts[bc[ip + 1]].apply(null, params)\n              );\n\n              ip += 4 + bc[ip + 3];\n              break;\n\n            case 23:\n              stack.push(peg$parseRule(bc[ip + 1]));\n              ip += 2;\n              break;\n\n            case 24:\n              peg$silentFails++;\n              ip++;\n              break;\n\n            case 25:\n              peg$silentFails--;\n              ip++;\n              break;\n\n            default:\n              throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");\n          }\n        }\n\n        if (ends.length > 0) {\n          end = ends.pop();\n          ip = ips.pop();\n        } else {\n          break;\n        }\n      }\n\n      return stack[0];\n    }\n\n    var data = {};\n\n    peg$result = peg$parseRule(peg$startRuleIndex);\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return data;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      return -1;\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       function (input, startRule) {return parse(input, {startRule: startRule});}\n  };\n};\n/* jshint ignore:end */\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\nvar EventEmitter = function() {\n    this.handlers = {};\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nEventEmitter.prototype.emit = function(name /*, args */) {\n    var self = this, args = Array.prototype.slice.call(arguments, 1);\n    if (name in this.handlers) {\n        var list = this.handlers[name];\n        for (var i = 0; i < list.length; i++) {\n            setTimeout(executeListener(list[i]), 0);\n        }\n    }\n    function executeListener(listener) {\n        return function() {\n            listener.apply(self, args);\n        }\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nEventEmitter.prototype.on = function(name, listener) {\n    if (!Array.isArray(name)) name = [name];\n    for (var i = 0; i < name.length; i++) {\n        this.handlers[name[i]] = this.handlers[name[i]] || [];\n        var list = this.handlers[name[i]];\n        list.push(listener);\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nEventEmitter.prototype.off = function(name, listener) {\n    this.handlers[name] = this.handlers[name] || [];\n    var index = this.handlers[name].indexOf(listener);\n    if (index !== -1) {\n        this.handlers[name].splice(index, 1);\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\nEventEmitter.prototype.once = function(name, listener) {\n    var self = this;\n\n    function listenOnce() {\n        listener.apply(this, arguments);\n        self.off(name, listenOnce);\n    }\n\n    self.on(name, listenOnce);\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//FIXME Remove Angular-specific\n//monkey patching emit for assuring that $apply is called\nvar __emit = EventEmitter.prototype.emit;\nEventEmitter.prototype.emit = function() {\n    var self = this, args = arguments;\n    setTimeout(function() {\n        __emit.apply(self, args);\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nmodule.exports = EventEmitter;\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar SIP = __webpack_require__(2);\nvar EventEmitter = __webpack_require__(35);\nvar PhoneLine = __webpack_require__(37);\nvar utils = __webpack_require__(38);\n\nvar extend = utils.extend;\nvar uuid = utils.uuid;\n\nvar EVENT_NAMES = __webpack_require__(39);\nvar DomAudio = __webpack_require__(40);\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n/**\n * @param options\n * @constructor\n */\nvar UserAgent = function(options) {\n    this.eventEmitter = new EventEmitter();\n    this.sipConfig = options ? (options.sipConfig || {}) : ({});\n    this.lines = {};\n    this.userAgent = undefined;\n    this.getUserMedia = undefined;\n    this.RTCPeerConnection = undefined;\n    this.RTCSessionDescription = undefined;\n    this.dom = new DomAudio();\n    this._x_userAgent = '';\n    this._client_id = '';\n    this.checkConfig();\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.checkConfig = function() {\n    // set mootools expands to non-enumerables under ES5\n    if (typeof this.sipConfig.wsServers === 'string') {\n        this.sipConfig.wsServers = [\n            {ws_uri: this.sipConfig.wsServers}\n        ];\n    }\n    var key, enums = {enumerable: false};\n    for (key in this.sipConfig.wsServers) this.sipConfig.wsServers.hasOwnProperty(key) || Object.defineProperty(Array.prototype, key, enums);\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.setSIPConfig = function(config) {\n    var wsServers = config.wsServers,\n        useSecureConnection = (document.location.protocol == 'https:');\n\n    for (var i = 0; i < wsServers.length; i++) {\n        if (\n            (useSecureConnection && /^wss:/.test(wsServers[i]))\n            ||\n            (!useSecureConnection && /^ws:/.test(wsServers[i]))\n        ) {\n            config.wsServers = [wsServers[i]];\n            break;\n        }\n    }\n\n    this.sipConfig = config;\n    this._x_userAgent = config.headers[1];\n    this._client_id =  config.headers[2]\n    this.checkConfig();\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.__createLine = function(session, type) {\n    var self = this;\n    session.data.id = uuid();\n    self.eventEmitter.emit(EVENT_NAMES.sipRTCSession, session);\n    var line = new PhoneLine({\n        session: session,\n        userAgent: self,\n        instanceId: self.sipConfig.authorizationUser,\n        eventEmitter: self.eventEmitter,\n        type: type,\n        _x_userAgent: self._x_userAgent,\n        _client_id : self._client_id\n    });\n    self.__clearInactiveLines();\n    self.lines[session.data.id] = line;\n    return line;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.getActiveLines = function() {\n    this.__clearInactiveLines();\n    return this.lines;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.getActiveLinesArray = function() {\n    var lines = this.getActiveLines();\n    var arr = [];\n    for (var id in lines) {\n        if (lines.hasOwnProperty(id)) {\n            arr.push(lines[id]);\n        }\n    }\n    return arr;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.getIncomingLinesArray = function() {\n    return this.getActiveLinesArray().filter(function(el) {\n        return el.isIncoming();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.__clearInactiveLines = function() {\n    for (var id in this.lines) {\n        if (this.lines.hasOwnProperty(id)) {\n            if (this.lines[id].isClosed()) {\n                delete this.lines[id];\n            }\n        }\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nvar __disconnectCount = 0;\n\n\nUserAgent.prototype.start = function(options) {\n    var self = this;\n\n    self.stop();\n    if (self.userAgent instanceof SIP.UA) {\n        self.userAgent.loadConfig(self.sipConfig);\n        self.userAgent.traceSip = true;\n    }\n    else {\n        self.userAgent = new SIP.UA(self.sipConfig);\n        self.__registerExtraOptions = options || {};\n        self.userAgent.on('connected', function(e) {\n            __disconnectCount = 0;\n            self.eventEmitter.emit(EVENT_NAMES.sipConnected, e);\n            self.userAgent.register({\n                extraHeaders: options.extraHeaders || []\n            });\n        });\n        self.userAgent.on('disconnected', function(e) {\n            if (++__disconnectCount >= (self.sipConfig.retryCount || 3)) {\n                __disconnectCount = 0;\n                self.stop();\n                self.eventEmitter.emit(EVENT_NAMES.sipConnectionFailed, new Error(\"Unable to connect to the WS server: exceeded number of attempts\"));\n            }\n            self.eventEmitter.emit(EVENT_NAMES.sipDisconnected, e);\n        });\n        self.userAgent.on('registered', function(e) {\n            self.eventEmitter.emit(EVENT_NAMES.sipRegistered, e);\n        });\n        self.userAgent.on('unregistered', function(e) {\n            self.eventEmitter.emit(EVENT_NAMES.sipUnRegistered, e);\n        });\n        self.userAgent.on('registrationFailed', function(e) {\n            self.eventEmitter.emit(EVENT_NAMES.sipRegistrationFailed, e);\n        });\n        //happens when call is incoming\n        self.userAgent.on('invite', function(session) {\n            var newLine;\n\n            if (session && session.request && session.request.hasHeader('replaces')) {\n                var replaces = session.request.getHeader('replaces').split(';'),\n                    callId = replaces[0],\n                    lines = self.getActiveLinesArray(),\n                    foundLine = null;\n                for (var i = 0; i < lines.length; i++) {\n                    if (lines[i].session.request.call_id) {\n                        if (callId === lines[i].session.request.call_id) {\n                            foundLine = lines[i];\n                            break;\n                        }\n                    }\n                }\n\n                if (foundLine) {\n                    var originalSessionId = foundLine.getId();\n                    newLine = self.__createLine(session, PhoneLine.types.incoming);\n                    newLine.answer().then(function() {\n                        self.eventEmitter.emit(EVENT_NAMES.callReplaced, newLine, foundLine);\n                        foundLine.cancel();\n                    });\n                }\n            }\n            else {\n                newLine = self.__createLine(session, PhoneLine.types.incoming);\n                self.eventEmitter.emit(EVENT_NAMES.sipIncomingCall, newLine);\n            }\n        });\n    }\n    //noop on transport connected (this will cause unwanted REGISTER)\n    self.userAgent.registerContext.onTransportConnected = function() {};\n    self.userAgent.start();\n\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.reregister = function(options, reconnect) {\n    var self = this, reconnect = !!reconnect;\n    options = extend(self.__registerExtraOptions, options);\n    if (!self.userAgent) {\n        self.start(options);\n    }\n    if (!reconnect) {\n        self.userAgent.register(options);\n    }\n    else {\n        if (!self.isConnected()) {\n            self.stop();\n            self.start(options);\n        }\n        else {\n            //This will be treated as abrupt disconnection and SIP.js will try to reconnect the WS\n            self.userAgent.transport.ws.close();\n        }\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.stop = function() {\n    if (this.userAgent instanceof SIP.UA) {\n        this.userAgent.stop();\n        this.userAgent = null;\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.call = function(number, inviteOptions) {\n    var self = this;\n    var options = {\n        media: {\n            constraints: {audio: true, video: false},\n            render: {\n                local: {\n                    audio: self.dom.localAudio\n                },\n                remote: {\n                    audio: self.dom.remoteAudio\n                }\n            }\n        },\n        RTCConstraints: {\n            \"optional\": [\n                {'DtlsSrtpKeyAgreement': 'true'}\n            ]\n        }\n    };\n    var fromNumber = inviteOptions.fromNumber;\n    var country = inviteOptions.country;\n\n    var headers = [];\n    if (fromNumber) {\n        headers.push('P-Asserted-Identity: sip:' + fromNumber + '@' + this.sipConfig.domain);\n    }\n    if (country) {\n        headers.push('P-rc-country-id: ' + country);\n    }\n\n    headers.push(self._x_userAgent);\n    headers.push(self._client_id);\n\n    extend(options, {\n        extraHeaders: headers\n    });\n    var session = this.userAgent.invite('' + number, options);\n    var line = self.__createLine(session, PhoneLine.types.outgoing);\n    this.eventEmitter.emit(EVENT_NAMES.outgoingCall, line);\n    return line;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.answer = function(line) {\n    return line && line.answer();\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n\nUserAgent.prototype.hangup = function(line) {\n    if (line) {\n        line.cancel();\n        delete this.lines[line.getId()];\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.on = function(eventName, cb) {\n    this.eventEmitter.on(eventName, cb);\n    return this;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.isConnected = function() {\n    return !!(this.userAgent && this.userAgent.transport && this.userAgent.transport.connected);\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.isConnecting = function() {\n    //websocket.readyState === CONNECTING (0)\n    return !this.isConnected() && !!(this.userAgent && this.userAgent.transport && this.userAgent.transport.ws && this.userAgent.transport.ws.readyState === 0);\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.forceDisconnect = function() {\n    console.warn(this.isConnecting(), this.isConnected())\n    if (this.isConnecting() || this.isConnected()) {\n        this.userAgent.transport.disconnect();\n        this.userAgent.stop();\n        this.userAgent = null;\n    }\n};\n\nmodule.exports = UserAgent;\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar SIP = __webpack_require__(2);\nvar utils = __webpack_require__(38);\nvar EVENT_NAMES = __webpack_require__(39);\n\nvar delay = utils.delay;\nvar extend = utils.extend;\n\nvar index = 0;\n\n/**\n * @param options\n * @constructor\n */\nvar PhoneLine = function(options) {\n\n    var self = this;\n    this.index = index++;\n\n    this.session = options.session;\n    this.userAgent = options.userAgent;\n    this.eventEmitter = options.eventEmitter;\n    this.instanceId = options.instanceId;\n    this.sessionId = this.session && this.session.id;\n\n    this.onCall = false;\n    this.onRecord = false;\n    this.contact = {};\n    this.muted = false;\n    this.bothMuted = false;\n    this.onHold = false;\n    this.timeCallStarted = null;\n\n    this.accepted = false;\n    this.type = options.type;\n\n    this._x_userAgent = options._x_userAgent;\n    this._client_id = options._client_id;\n\n    this.responseTimeout = 10000;\n\n    this.controlSender = {\n        messages: {\n            park: {reqid: 1, command: 'callpark'},\n            startRecord: {reqid: 2, command: 'startcallrecord'},\n            stopRecord: {reqid: 3, command: 'stopcallrecord'},\n            flip: {reqid: 3, command: 'callflip', target: ''},\n            monitor: {reqid: 4, command: 'monitor'},\n            barge: {reqid: 5, command: 'barge'},\n            whisper: {reqid: 6, command: 'whisper'},\n            takeover: {reqid: 7, command: 'takeover'}\n        },\n        send: function(command, options) {\n\n            options = options || {};\n            extend(command, options);\n\n            var cseq = null;\n\n            return new Promise(function(resolve, reject){\n\n                var headers = [];\n\n                headers.push('Content-Type: application/json;charset=utf-8');\n                headers.push(self._x_userAgent);\n                headers.push(self._client_id);\n\n                self.session.sendRequest(SIP.C.INFO, {\n                    body: JSON.stringify({\n                        request: command\n                    }),\n                    extraHeaders: headers,\n                    receiveResponse: function(response) {\n                        var timeout = null;\n                        if (response.status_code === 200) {\n                            cseq = response.cseq;\n                            function onInfo(request) {\n                                if (response.cseq === cseq) {\n                                    var body = request && request.body || '{}';\n                                    var obj;\n\n                                    try {\n                                        obj = JSON.parse(body);\n                                    }\n                                    catch (e) {\n                                        obj = {};\n                                    }\n\n                                    if (obj.response && obj.response.command === command.command) {\n                                        if (obj.response.result) {\n                                            if (obj.response.result.code == 0) {\n                                                resolve(obj.response.result);\n                                            }\n                                            else {\n                                                reject(obj.response.result);\n                                            }\n                                        }\n                                    }\n                                    timeout && clearTimeout(timeout);\n                                    self.eventEmitter.off('SIP_INFO', onInfo);\n                                    resolve(); //FIXME What to resolve\n                                }\n                            }\n\n                            timeout = setTimeout(function() {\n                                reject(new Error('Timeout: no reply'));\n                                self.eventEmitter.off('SIP_INFO', onInfo);\n                            }, self.responseTimeout);\n                            self.eventEmitter.on('SIP_INFO', onInfo);\n                        }\n                        else {\n                            reject(new Error('The INFO response status code is: ' + response.status_code + ' (waiting for 200)'));\n                        }\n                    }\n                });\n\n            });\n        }\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    var __receiveRequest = this.session.receiveRequest;\n    this.session.receiveRequest = function(request) {\n        switch (request.method) {\n            case SIP.C.INFO:\n                self.eventEmitter.emit('SIP_INFO', request);\n                //SIP.js does not support application/json content type, so we monkey override its behaviour in this case\n                if (this.status === SIP.Session.C.STATUS_CONFIRMED || this.status === SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n                    var contentType = request.getHeader('content-type');\n                    if (contentType.match(/^application\\/json/i)) {\n                        request.reply(200);\n                        return this;\n                    }\n                }\n                break;\n            //Refresh invite should not be rejected with 488\n            case SIP.C.INVITE:\n                var session = this;\n                if (session.status === SIP.Session.C.STATUS_CONFIRMED) {\n                    if (request.call_id && session.dialog && session.dialog.id && request.call_id == session.dialog.id.call_id) {\n                        //TODO: check that SDP did not change\n                        session.logger.log('re-INVITE received');\n                        var localSDP = session.mediaHandler.peerConnection.localDescription.sdp;\n                        request.reply(200, null, ['Contact: ' + self.contact], localSDP, function() {\n                            session.status = SIP.Session.C.STATUS_WAITING_FOR_ACK;\n                            session.setInvite2xxTimer(request, localSDP);\n                            session.setACKTimer();\n                        });\n                        return session;\n                    }\n                    //else will be rejected with 488 by SIP.js\n                }\n                break;\n            //We need to analize NOTIFY messages sometimes, so we fire an event\n            case SIP.C.NOTIFY:\n                self.eventEmitter.emit('SIP_NOTIFY', request);\n                break;\n        }\n        return __receiveRequest.apply(self.session, arguments);\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Fired when ICE is starting to negotiate between the peers.\n    this.session.on('connecting', function(e) {\n        self.eventEmitter.emit(EVENT_NAMES.callConnecting, self, e);\n        setTimeout(function() {\n            if (self.session.mediaHandler.onIceCompleted !== undefined) {\n                self.session.mediaHandler.onIceCompleted(self.session);\n            }\n            else {\n                self.session.mediaHandler.callOnIceCompleted = true;\n            }\n        }, self.userAgent.sipConfig['iceGatheringTimeout'] || 3000);\n    });\n\n    this.__hasEarlyMedia = false;\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n\n    //Monkey patching for handling early media and to delay ACKs\n    var __receiveInviteReponse = this.session.receiveInviteResponse,\n        __waitingForIce = false;\n    this.session.receiveResponse = this.session.receiveInviteResponse = function(response) {\n        var sessionSelf = this, args = arguments;\n        switch (true) {\n            case (/^1[0-9]{2}$/.test(response.status_code)):\n                //Let's not allow the library to send PRACK\n                if (self.hasEarlyMedia()) {\n                    this.emit('progress', response);\n                    return;\n                }\n                break;\n            case /^(2[0-9]{2})|(4\\d{2})$/.test(response.status_code):\n                if (!self.hasEarlyMedia()) break;\n\n                //Let's check the ICE connection state\n                if (self.session.mediaHandler.peerConnection.iceConnectionState === 'completed' && !__waitingForIce) {\n                    __waitingForIce = false;\n                    //if ICE is connected, then let the library to handle the ACK\n                    break;\n                }\n                else {\n                    //If ICE is not connected, then we should send ACK after it has been connected\n                    if (!__waitingForIce) {\n                        self.eventEmitter.once(EVENT_NAMES.ICECompleted, function() {\n                            //let the library handle the ACK after ICE connection is completed\n                            __waitingForIce = false;\n                            __receiveInviteReponse.apply(sessionSelf, args);\n                        });\n\n                        self.eventEmitter.once(EVENT_NAMES.ICEFailed, function() {\n                            //handle the ICE Failed situation\n                            __waitingForIce = false;\n                            self.session.acceptAndTerminate(response, null, 'ICE Connection Failed');\n                        });\n\n                        __waitingForIce = true;\n                    }\n                    return;\n                }\n                break;\n        }\n        return __receiveInviteReponse.apply(sessionSelf, args);\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Fired each time a provisional (100-199) response is received.\n    this.session.on('progress', function(e) {\n        self.onCall = true;\n\n        //Early media is supported by SIP.js library\n        //But in case it is sent without 100rel support we play it manually\n        //STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported\n        if (self.session.status !== SIP.Session.C.STATUS_EARLY_MEDIA && e.status_code === 183 && typeof(e.body) === 'string' && e.body.indexOf('\\n') !== -1) {\n            var session = self.session,\n                response = e;\n\n            if (session.hasOffer) {\n                if (!session.createDialog(response, 'UAC')) {\n                    return;\n                }\n                session.hasAnswer = true;\n                session.mediaHandler.setDescription(\n                    response.body,\n                    function() {\n                        session.dialog.pracked.push(response.getHeader('rseq'));\n                        session.status = SIP.Session.C.STATUS_EARLY_MEDIA;\n                        session.mute();\n                        self.__hasEarlyMedia = true;\n                        self.eventEmitter.emit(EVENT_NAMES.callProgress, self, e);\n                    },\n                    function(e) {\n                        session.logger.warn(e);\n                        session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n                        session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                    }\n                );\n            }\n        }\n    });\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Fired each time a successful final (200-299) response is received.\n    this.session.on('accepted', function(e) {\n        if (self.accepted === true) return;\n        self.onCall = true;\n        self.accepted = true;\n        self.timeCallStarted = new Date();\n        self.eventEmitter.emit(EVENT_NAMES.callStarted, self, e);\n    });\n\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function onEnd() {\n        self.onCall = false;\n        self.timeCallStarted = null;\n        self.accepted = true;\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n    //Fired each time an unsuccessful final (300-699) response is\n    //this will emit failed event\n    this.session.on('rejected', function(e) {\n        onEnd();\n        self.eventEmitter.emit(EVENT_NAMES.callRejected, self, e);\n        //terminated is not called by SIP.js when the call is rejected\n        //self.eventEmitter.emit(EVENT_NAMES.callTerminated, self, e);\n    });\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Fired when the session was canceled by the client\n    this.session.on('cancel', function(e) {\n        onEnd();\n        self.eventEmitter.emit(EVENT_NAMES.callEnded, self, e);\n    });\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Fired when a BYE is sent\n    this.session.on('bye', function(e) {\n        onEnd();\n        self.eventEmitter.emit(EVENT_NAMES.callEnded, self, e);\n    });\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Fired when the request fails, whether due to an unsuccessful final response or due to timeout, transport, or other error\n    this.session.on('failed', function(response, cause) {\n        this.terminated(null, cause);\n        onEnd();\n        self.eventEmitter.emit(EVENT_NAMES.callFailed, self, response, cause);\n        //SIP.js 0.6.x does not call terminated event sometimes, so we call it ourselves\n        if (cause === SIP.C.causes.REQUEST_TIMEOUT) {\n            //this === session\n            if (this.status !== SIP.Session.C.STATUS_CONFIRMED) {\n                this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n            }\n        }\n    });\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    this.session.on('terminated', function(response, cause) {\n        onEnd();\n        self.eventEmitter.emit(EVENT_NAMES.callTerminated, self, response, cause);\n    });\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function terminateCallOnDisconnected(reason) {\n        self.session.terminated(null, reason || SIP.C.causes.CONNECTION_ERROR);\n        onEnd();\n        self.eventEmitter.emit(EVENT_NAMES.callFailed, self, null, 'Connection error');\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n//FIXME: Explore if it can be replaced with ref: http://sipjs.com/api/0.7.0/mediaHandler/\n\n    //Monkey patching oniceconnectionstatechange because SIP.js 0.6.x does not have this event\n    var onStateChange = this.session.mediaHandler.peerConnection.oniceconnectionstatechange || function(){},\n        __doubleCompleted = false;\n    this.session.mediaHandler.peerConnection.oniceconnectionstatechange = function() {\n        //this === peerConnection\n        var state = this.iceConnectionState;\n        onStateChange.apply(this, arguments);\n\n        switch (state) {\n            case 'connected':\n                self.eventEmitter.emit(EVENT_NAMES.ICEConnected, self);\n                break;\n            case 'completed':\n                //this may be called twice, see: https://code.google.com/p/chromium/issues/detail?id=371804\n                if (!__doubleCompleted) {\n                    self.eventEmitter.emit(EVENT_NAMES.ICECompleted, self);\n                    __doubleCompleted = true;\n                }\n                break;\n            case 'disconnected':\n                terminateCallOnDisconnected();\n                self.eventEmitter.emit(EVENT_NAMES.ICEDisconnected, self);\n                break;\n            case 'failed':\n                self.eventEmitter.emit(EVENT_NAMES.ICEFailed, self);\n                break;\n        }\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    var __ignoreReinviteDuplicates = false;\n\n    //Monkey patching sendReinvite for better Hold handling\n    var __sendReinvite = this.session.sendReinvite;\n    this.session.sendReinvite = function() {\n        __ignoreReinviteDuplicates = false;\n        var res = __sendReinvite.apply(this, arguments);\n        var __reinviteSucceeded = this.reinviteSucceeded,\n            __reinviteFailed = this.reinviteFailed;\n        this.reinviteSucceeded = function() {\n            self.eventEmitter.emit(EVENT_NAMES.callReinviteSucceeded, self);\n            return __reinviteSucceeded.apply(this, []);\n        };\n        this.reinviteFailed = function() {\n            self.eventEmitter.emit(EVENT_NAMES.callReinviteFailed, self);\n            return __reinviteFailed.apply(this, []);\n        };\n        return res;\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Monkey patching receiveReinviteResponse to ignore duplicates which may break Hold/Unhold\n    var __receiveReinviteResponse = this.session.receiveReinviteResponse;\n    this.session.receiveReinviteResponse = function(response) {\n        switch (true) {\n            case /^2[0-9]{2}$/.test(response.status_code):\n                if (__ignoreReinviteDuplicates) {\n                    this.sendRequest(SIP.C.ACK, {cseq: response.cseq});\n                    return;\n                }\n                __ignoreReinviteDuplicates = true;\n                break;\n        }\n        return __receiveReinviteResponse.apply(this, arguments);\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //defining if the session is incoming or outgoing\n    if (this.type === PhoneLine.types.incoming) {\n        this.contact.name = this.session.request.from.uri.displayName;\n        this.contact.number = this.session.request.from.uri.user;\n\n    } else {\n        if (this.type === PhoneLine.types.outgoing) {\n            this.contact.name = this.session.request.to.uri.displayName;\n            this.contact.number = this.session.request.to.uri.user;\n        }\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.types = {\n    incoming: 'incoming',\n    outgoing: 'outgoing'\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.getId = function() {\n    return this.session.data.id;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.getSession = function() {\n    return this.session;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.cancel = function() {\n    var session = this.getSession();\n    return new Promise(function(resolve, reject) {\n        session.terminate({statusCode: 486});\n        resolve();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.record = function(val) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        if (self.onCall) {\n            var message = !!val\n                ? self.controlSender.messages.startRecord\n                : self.controlSender.messages.stopRecord;\n\n            if ((self.onRecord && !val) || (!self.onRecord && val)) {\n                return self.controlSender.send(message)\n                    .then(function(data) {\n                        self.onRecord = !!val;\n                        return data;\n                    });\n            }\n        }\n        else {\n            reject(new Error('No line or no active line'));\n        }\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.flip = function(target) {\n    var self = this;\n\n    return new Promise(function(resolve, reject){\n        if (!target) return;\n        if (self.onCall) {\n            return self.controlSender.send(self.controlSender.messages.flip, {\n                target: target\n            });\n        }\n        else {\n           reject(new Error('No line or no active line'));\n        }\n    });\n};\n\nPhoneLine.prototype.park = function() {\n\n    var self = this;\n    return new Promise(function(resolve, reject){\n        if (self.onCall) {\n            resolve(self.controlSender.send(self.controlSender.messages.park));\n        }\n        else\n            reject(new Error('No line or no active line'));\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n// Explore ref: http://sipjs.com/api/0.6.0/session/#dtmftone-options\n\nPhoneLine.prototype.sendDTMF = function(value, duration) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        if(self.onCall) {\n            duration = parseInt(duration) || 1000;\n            var peer = self.session.mediaHandler.peerConnection;\n            var stream = self.session.getLocalStreams()[0];\n            var dtmfSender = peer.createDTMFSender(stream.getAudioTracks()[0]);\n            if (dtmfSender !== undefined && dtmfSender.canInsertDTMF) {\n                dtmfSender.insertDTMF(value, duration);\n            }\n            resolve();\n        }\n        else\n            reject(new Error('No line or no active line'));\n    });\n};\n\n/*\nCurrently not supported\n */\nPhoneLine.prototype.sendInfoDTMF = function(value, duration) {\n    var session = this.session;\n    return new Promise(function(resolve, reject) {\n        duration = parseInt(duration) || 1000;\n        session.dtmf(value.toString(), {\n            duration: duration\n        });\n        resolve();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.blindTransfer = function(target, options) {\n    var session = this.session;\n    var self = this;\n    var extraHeaders = [];\n    var originalTarget = target;\n    options = options || {};\n\n    return new Promise(function(resolve, reject){\n        //Blind Transfer is taken from SIP.js source\n\n        // Check Session Status\n        if (session.status !== SIP.Session.C.STATUS_CONFIRMED) {\n            reject(new SIP.Exceptions.InvalidStateError(session.status));\n        }\n\n        // normalizeTarget allows instances of SIP.URI to pass through unaltered,\n        // so try to make one ahead of time\n        try {\n            target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n        } catch (e) {\n            session.logger.debug(\".refer() cannot parse Refer_To from\", target);\n            session.logger.debug(\"...falling through to normalizeTarget()\");\n        }\n\n        // Check target validity\n        target = session.ua.normalizeTarget(target);\n        if (!target) {\n            throw new TypeError('Invalid target: ' + originalTarget);\n        }\n\n        extraHeaders.push('Contact: ' + session.contact);\n        extraHeaders.push('Allow: ' + SIP.Utils.getAllowedMethods(session.ua));\n        extraHeaders.push('Refer-To: ' + target);\n        extraHeaders.push('x-user-agent:'+self._x_userAgent);\n        extraHeaders.push('client-id'+self._x_userAgent);\n\n\n        // Send the request\n        session.sendRequest(SIP.C.REFER, {\n            extraHeaders: extraHeaders,\n            body: options.body,\n            receiveResponse: function(response) {\n                var timeout = null;\n                if (response.status_code === 202) {\n                    var callId = response.call_id;\n\n                    function onNotify(request) {\n                        if (request.call_id === callId) {\n                            var body = request && request.body || '';\n                            switch (true) {\n                                case /1[0-9]{2}/.test(body):\n                                    request.reply(200);\n                                    break;\n                                case /2[0-9]{2}/.test(body):\n                                    self.session.terminate();\n                                    clearTimeout(timeout);\n                                    self.eventEmitter.off('SIP_NOTIFY', onNotify);\n                                    resolve();\n                                    break;\n                                default:\n                                    reject(body);\n                                    break;\n                            }\n                        }\n                    }\n\n                    timeout = setTimeout(function() {\n                        reject(new Error('Timeout: no reply'));\n                        self.eventEmitter.off('SIP_NOTIFY', onNotify);\n                    }, self.responseTimeout);\n                    self.eventEmitter.on('SIP_NOTIFY', onNotify);\n                }\n                else {\n                    reject(new Error('The response status code is: ' + response.status_code + ' (waiting for 202)'));\n                }\n            }\n        });\n\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.transfer = function(target, options) {\n    var self = this;\n    return (self.onHold ? Promise.resolve(null) : self.setHold(true)).then(function(){ return delay(300); }).then(function() {\n        return self.blindTransfer(target, options);\n    });\n};\n\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.forward = function(target, options) {\n    var self = this, interval = null;\n    return self.answer().then(function() {\n        return new Promise(function(resolve, reject){\n            interval = setInterval(function() {\n                if (self.session.status === 12) {\n                    clearInterval(interval);\n                    self.setMute(true);\n                    setTimeout(function() {\n                        self.transfer(target, options);\n                        resolve();\n                    }, 700);\n                }\n            }, 50);\n        });\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n//ref: http://sipjs.com/api/0.6.0/session/#acceptoptions\n//make var option = {}\n\nPhoneLine.prototype.answer = function() {\n    var self = this;\n\n    return new Promise(function(resolve, reject){\n\n        function onAnswered() {\n            resolve();\n            self.eventEmitter.off(EVENT_NAMES.callStarted, onAnswered);\n            self.eventEmitter.off(EVENT_NAMES.callFailed, onFail);\n        }\n\n        function onFail(e) {\n            reject(e);\n            self.eventEmitter.off(EVENT_NAMES.callStarted, onAnswered);\n            self.eventEmitter.off(EVENT_NAMES.callFailed, onFail);\n        }\n\n        self.eventEmitter.on(EVENT_NAMES.callStarted, onAnswered);\n        self.eventEmitter.on(EVENT_NAMES.callFailed, onFail);\n\n        self.eventEmitter.emit(EVENT_NAMES.callProgress, self);\n\n        self.session.accept({\n            media: {\n                constraints: {audio: true, video: false},\n                render: {\n                    local: {\n                        audio: self.userAgent.dom.localAudio\n                    },\n                    remote: {\n                        audio: self.userAgent.dom.remoteAudio\n                    }\n                }\n            }\n        });\n\n    });\n\n};\n\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//FIXME: Use SIPJS mute() and unmute() ref: http://sipjs.com/api/0.7.0/session/#muteoptions\n\nPhoneLine.prototype.setMute = function(val) {\n    var self = this;\n    return new Promise(function(resolve, reject) {\n        self.muted = !!val;\n        if (self.onCall) {\n            setStreamMute(self.session.getLocalStreams()[0], self.muted);\n            val ? self.eventEmitter.emit(EVENT_NAMES.callMute, self) : self.eventEmitter.emit(EVENT_NAMES.callUnmute, self);\n            resolve();\n        }\n        else\n            reject(new Error('No line or no active line'));\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//FIXME: Use SIPJS mute() and unmute() ref: http://sipjs.com/api/0.7.0/session/#muteoptions\n\nfunction setStreamMute(stream, val) {\n    var tracks = stream.getAudioTracks();\n    for (var i = 0; i < tracks.length; i++) {\n        tracks[i].enabled = !val;\n    }\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n////FIXME: Use SIPJS mute() and unmute() ref: http://sipjs.com/api/0.7.0/session/#muteoptions\n\nPhoneLine.prototype.setMuteBoth = function(val) {\n    var self = this;\n    return new Promise(function(resolve, reject) {\n        self.bothMuted = !!val;\n        self.muted = !!val;\n        if (self.onCall) {\n            setStreamMute(self.session.getLocalStreams()[0], self.bothMuted);\n            setStreamMute(self.session.getRemoteStreams()[0], self.bothMuted);\n            val ? self.eventEmitter.emit(EVENT_NAMES.callMute, self) : self.eventEmitter.emit(EVENT_NAMES.callUnmute, self);\n            resolve();\n        }\n        else\n            reject(new Error('No line or no active line'));\n    });\n\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//FIXME: Explore send() ref: http://sipjs.com/api/0.7.0/transport/#sendmsg\n\n/* This is a direct and very tightly coupled code. Please, try to avoid using this method if possible */\nPhoneLine.prototype.sendRequest = function(method, body, options) {\n    var self = this;\n    options = options || {};\n\n    if (!this.session.dialog) return;\n\n    var request = new SIP.OutgoingRequest(\n        method,\n        self.session.dialog.remote_target,\n        self.session.ua,\n        {\n            cseq: options.cseq || (self.session.dialog.local_seqnum += 1),\n            call_id: self.session.dialog.id.call_id,\n            from_uri: self.session.dialog.local_uri,\n            from_tag: self.session.dialog.id.local_tag,\n            to_uri: self.session.dialog.remote_uri,\n            to_tag: self.session.dialog.id.remote_tag,\n            route_set: self.session.dialog.route_set,\n            statusCode: options.statusCode,\n            reasonPhrase: options.reasonPhrase\n        },\n        options.extraHeaders || [],\n        body || undefined\n    );\n\n    new SIP.RequestSender({\n        request: request,\n        onRequestTimeout: function() {\n            self.session.onRequestTimeout();\n        },\n        onTransportError: function() {\n            self.session.onTransportError();\n        },\n        receiveResponse: options.receiveResponse || function(response) {\n        }\n    }, self.session.ua).send();\n};\n\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//FIXME: should be replaced with __hold()\n//This can be removed\n//Legacy hold uses direct in-dialog messages to trick SIP.js, try to avoid using this method if possible\nPhoneLine.prototype.__legacyHold = function(val) {\n    var self = this;\n    self.onHold = !!val;\n    return new Promise(function(resolve, reject){\n        if (self.onCall && self.session.dialog) {\n            var body = self.session.mediaHandler.peerConnection.localDescription.sdp;\n            if (self.onHold) {\n                //body = body.replace(/c=IN IP4 \\d+\\.\\d+.\\d+.\\d+/, \"c=IN IP4 0.0.0.0\");\n                body = body.replace(/a=sendrecv/, \"a=sendonly\");\n                self.session.mediaHandler.hold();\n                self.session.onhold('local');\n            }\n            else {\n                self.session.mediaHandler.unhold();\n                self.session.onunhold('local');\n            }\n\n            self.sendRequest(SIP.C.INVITE, body, {\n                extraHeaders: [\n                    \"Content-Type: application/sdp\",\n                    \"Contact: \" + self.session.contact,\n                    self._x_userAgent,\n                    self._client_id\n                ],\n                receiveResponse: function(response) {\n                    switch (true) {\n                        case /^1[0-9]{2}$/.test(response.status_code):\n                            break;\n                        case /^2[0-9]{2}$/.test(response.status_code):\n                            resolve();\n                            self.sendRequest(SIP.C.ACK, null, {\n                                cseq: response.cseq\n                            });\n                            break;\n                        default:\n                            reject('Status code is: ' + response.status_code);\n                            self.onHold = !self.onHold;\n                            break;\n                    }\n                }\n            });\n        }\n        else {\n            throw new Error('No line or no active line');\n        }\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n\nPhoneLine.prototype.__hold = function(val) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        function onSucceeded() {\n            resolve();\n            self.eventEmitter.off(EVENT_NAMES.callReinviteFailed, onFailed);\n        }\n\n        function onFailed(e) {\n            reject(e);\n            self.eventEmitter.off(EVENT_NAMES.callReinviteSucceeded, onSucceeded);\n        }\n\n        self.eventEmitter.once(EVENT_NAMES.callReinviteSucceeded, onSucceeded);\n        self.eventEmitter.once(EVENT_NAMES.callReinviteFailed, onFailed);\n\n        val ? self.session.hold() : self.session.unhold();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.setHold = function(val) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        self.onHold = !!val;\n        if (self.onCall) {\n            resolve(self.__hold(val).then(function(res) {\n                if (val) {\n                    self.eventEmitter.emit(EVENT_NAMES.callHold, self);\n                } else {\n                    self.eventEmitter.emit(EVENT_NAMES.callUnhold, self);\n                }\n                return res;\n            }).catch(function(e) {\n                self.onHold = !self.onHold;\n                throw e;\n            }));\n        }\n        else\n            reject(new Error('No line or no active line'));\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.isOnHold = function() {\n    return this.onHold;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.isOnMute = function() {\n    return this.muted || this.bothMuted;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.isOnRecord = function() {\n    return this.onRecord;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.getContact = function() {\n    return this.contact;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.getCallDuration = function() {\n    if (this.timeCallStarted) {\n        return (new Date()).getTime() - this.timeCallStarted.getTime();\n    }\n    else {\n        return 0;\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.isIncoming = function() {\n    return this.session.mediaHandler.peerConnection.signalingState !== \"closed\"\n        && !this.session.startTime;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.isClosed = function() {\n    return this.session.status === SIP.Session.C.STATUS_CANCELED || this.session.status === SIP.Session.C.STATUS_TERMINATED;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.hasEarlyMedia = function() {\n    return this.__hasEarlyMedia;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nmodule.exports = PhoneLine;\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\nmodule.exports = {\n\n    delay: function delay(ms) {\n        return new Promise(function(resolve, reject) {\n            setTimeout(resolve, ms);\n        });\n    },\n\n    defer: function defer() {\n        var deferred = {};\n        deferred.promise = new Promise(function(resolve, reject) {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n        return deferred;\n    },\n\n    extend: function extend(dst, src) {\n        src = src || {};\n        dst = dst || {};\n        Object.keys(src).forEach(function(k) {\n            dst[k] = src[k];\n        });\n        return dst;\n    },\n\n    copy: function(src){\n        return this.extend({}, src);\n    },\n\n    uuid: function uuid() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n\n};\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\nmodule.exports = {\n    'message': 'message',\n    'sipConnecting': 'sipConnecting',\n    'sipConnected': 'sipConnected',\n    'sipDisconnected': 'sipDisconnected',\n    'sipRegistered': 'sipRegistered',\n    'sipUnRegistered': 'sipUnregistered',\n    'sipRegistrationFailed': 'sipRegistrationFailed',\n    'incomingCall': 'incomingCall',                     //when incoming call is received\n    'sipIncomingCall': 'sipIncomingCall',               //same as incomingCall\n    'outgoingCall': 'outgoingCall',                     //when the outbound call is initiated\n    'callConnecting': 'callConnecting',                 //when ICE gathering is started\n    'callProgress': 'callProgress',                     //when 1xx provisional message is received (outbound only) or call is accepted, but ACK is still not sent (inbound only)\n    'callStarted': 'callStarted',                       //when ACK is sent\n    'callRejected': 'callRejected',                     //when the call is rejected by its party\n    'callEnded': 'callEnded',                           //when the call had ended without errors (BYE)\n    'callTerminated': 'callTerminated',                 //when the media is terminated, UNSTABLE in SIP.js 0.6.x\n    'callFailed': 'callFailed',                         //when the call is failed because of many different reasons (connection issues, 4xx errors, etc.)\n    'callHold': 'callHold',                             //when the call is put on hold\n    'callUnhold': 'callUnhold',                         //when the call is unholded\n    'callMute': 'callMute',                             //when the call is muted\n    'callUnmute': 'callUnmute',                         //when the call is unmuted\n    'callReplaced': 'callReplaced',                     //when the call has been replaced by an incoming invite\n    'sipRTCSession': 'sipRTCSession',\n    'sipConnectionFailed': 'sipConnectionFailed',\n    'ICEConnected': 'ICEConnected',\n    'ICECompleted': 'ICECompleted',\n    'ICEFailed': 'ICEFailed',\n    'ICEChecking': 'ICEChecking',\n    'ICEClosed': 'ICEClosed',\n    'ICEDisconnected': 'ICEDisconnected',\n    'callReinviteSucceeded': 'callReinviteSucceeded',\n    'callReinviteFailed': 'callReinviteFailed'\n};\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar uuid = __webpack_require__(38).uuid;\n\nfunction DomAudio(){\n\n    /*\n     * We create audio containers here\n     * Sorry for DOM manipulations inside a service, but it is for the good :)\n     */\n    var LOCAL_AUDIO = document.createElement('video'),\n        REMOTE_AUDIO = document.createElement('video'),\n        LOCAL_AUDIO_ID = 'local_' + uuid(),\n        REMOTE_AUDIO_ID = 'remote_' + uuid();\n\n    LOCAL_AUDIO.setAttribute('id', LOCAL_AUDIO_ID);\n    LOCAL_AUDIO.setAttribute('autoplay', 'true');\n    LOCAL_AUDIO.setAttribute('hidden', 'true');\n    LOCAL_AUDIO.setAttribute('muted', '');\n\n    REMOTE_AUDIO.setAttribute('id', REMOTE_AUDIO_ID);\n    REMOTE_AUDIO.setAttribute('autoplay', 'true');\n    REMOTE_AUDIO.setAttribute('hidden', 'true');\n\n    document.body.appendChild(LOCAL_AUDIO);\n    document.body.appendChild(REMOTE_AUDIO);\n\n    LOCAL_AUDIO.volume = 0;\n\n    this.localAudio = LOCAL_AUDIO;\n    this.remoteAudio = REMOTE_AUDIO;\n    this.localAudioId = LOCAL_AUDIO_ID;\n    this.remoteAudioId = REMOTE_AUDIO_ID;\n\n}\n\nmodule.exports = DomAudio;\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n'use strict';\n\nvar audio = __webpack_require__(42);\n\n/**\n * @param {WebPhone} rcSIPUA\n * @param options\n * @constructor\n */\nfunction AudioHelper(rcSIPUA, options) {\n\n    var self = this;\n\n    options = options || {};\n\n    this._rcSIPUA = rcSIPUA;\n    this._incoming = options.incoming || 'audio/incoming.ogg';\n    this._outgoing = options.outgoing || 'audio/outgoing.ogg';\n    this._audio = {};\n\n    rcSIPUA.on(rcSIPUA.events.incomingCall, function() {\n        self.playIncoming(true);\n    });\n\n    rcSIPUA.on(rcSIPUA.events.outgoingCall, function() {\n        self.playOutgoing(true);\n    });\n\n    rcSIPUA.on(rcSIPUA.events.callProgress, function(session) {\n        if (session.hasEarlyMedia()) {\n            self.playOutgoing(false);\n        }\n    });\n\n    rcSIPUA.on([rcSIPUA.events.callStarted, rcSIPUA.events.callRejected, rcSIPUA.events.callEnded, rcSIPUA.events.callFailed], function() {\n        self.playIncoming(false);\n        self.playOutgoing(false);\n    });\n\n}\n\nAudioHelper.prototype._playSound = function(url, val, volume) {\n\n    if (!this._audio[url]) {\n        if (val) {\n            volume !== undefined && (audio.volume = volume);\n            this._audio[url] = audio.play(url, {loop: true});\n        }\n    } else {\n        if (val) {\n            this._audio[url].reset();\n        }\n        else {\n            this._audio[url].stop();\n        }\n    }\n\n};\n\nAudioHelper.prototype.playIncoming = function(val) {\n    this._playSound(this._incoming, val, 0.5);\n};\n\nAudioHelper.prototype.playOutgoing = function(val) {\n    this._playSound(this._outgoing, val, 1);\n};\n\nmodule.exports = AudioHelper;\n\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar error = console.error;\nvar EventEmitter = __webpack_require__(35);\n\nmodule.exports = {\n\n    play: function(url, options) {\n\n        var emitter = new EventEmitter();\n\n        var audio = new Audio();\n\n        audio.volume = 1;\n\n        audio.addEventListener(\"timeupdate\", function(event) {\n            emitter.emit('progress', {\n                duration: audio.duration,\n                progress: audio.currentTime / audio.duration\n            });\n        });\n\n        audio.addEventListener(\"seeked\", function(event) {\n            emitter.emit('progress', {\n                    duration: audio.duration,\n                    progress: audio.currentTime / audio.duration\n            });\n        });\n        audio.addEventListener(\"ended\", function(event) {\n            emitter.emit('ended');\n        });\n        audio.addEventListener(\"pause\", function(event) {\n            emitter.emit('progress', {\n                    duration: audio.duration,\n                    paused: true,\n                    progress: audio.currentTime / audio.duration\n            });\n        });\n        audio.addEventListener(\"play\", function(event) {\n            emitter.emit('progress', {\n                    duration: audio.duration,\n                    resumed: true,\n                    progress: audio.currentTime / audio.duration\n            });\n        });\n        audio.addEventListener(\"error\", function() {\n            console.log(\"error\", audio.error); //FIXME\n            emitter.emit('error', audio.error);\n        });\n\n        emitter.stop = audio.pause.bind(audio);\n        emitter.pause = audio.pause.bind(audio);\n        emitter.resume = audio.play.bind(audio);\n        emitter.reset = function() {\n            audio.currentTime = 0;\n            audio.play();\n        };\n\n        emitter.duration = function() {\n            return Math.ceil(audio.duration);\n        };\n\n        audio.src = url;\n        audio.load(url);\n\n        if (options) { //FIXME angular.isObject\n            for (var prop in options) {\n                if (prop in audio) {\n                    audio[prop] = options[prop];\n                }\n            }\n        }\n\n        audio.play();\n\n        return emitter;\n\n    }\n};\n\n/***/ }\n/******/ ])\n});\n;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8c9fbab19495d2b63fcb\n **/","var SIP = require('sip.js');\nvar EventEmitter = require('./emitter');\nvar UserAgent = require('./userAgent');\nvar PhoneLine = require('./phoneLine');\nvar AudioHelper = require('./audioHelper');\nvar defer = require('./utils').defer;\nvar uuid = require('./utils').uuid;\nvar extend = require('./utils').extend;\nvar EVENT_NAMES = require('./eventNames');\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//Patching proto because of https://developers.google.com/web/updates/2015/07/mediastream-deprecations\nvar mediaStreamManagerProto = Object.create(SIP.WebRTC.MediaStreamManager.prototype, {\n    'release': {\n        value: function release(stream) {\n            var streamId = SIP.WebRTC.MediaStreamManager.streamId(stream);\n            if (this.acquisitions[streamId] === false) {\n                //MediaStream.stop removed in M47\n                if (typeof (stream.stop) === 'function') {\n                    stream.stop();\n                }\n                else {\n                    stream.getTracks().forEach(function(track) {\n                        track.stop()\n                    });\n                }\n            }\n            delete this.acquisitions[streamId];\n        }\n    }\n});\n\nSIP.WebRTC.MediaStreamManager.prototype = mediaStreamManagerProto;\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n/**\n * @namespace RingCentral\n * @param {boolean} [options.audioHelper] Automatically create audio helper\n * @param {string} [options.uuid] Instance ID\n * @constructor\n */\nfunction WebPhone(options) {\n\n    options = options || {};\n\n    var service = this;\n\n    this.__registerDeferred = undefined;\n    this.__unregisterDeferred = undefined;\n    this.__callDeferred = undefined;\n    this.__sipRegistered = false;\n    this.__sipOutboundEnabled = false;\n\n    if (options.uuid) {\n        this.uuid = options.uuid;\n    } else {\n        localStorage['rc-webPhone-uuid'] = localStorage['rc-webPhone-uuid'] || uuid();\n        this.uuid = localStorage['rc-webPhone-uuid'];\n    }\n\n    this.activeLine = null;\n\n    this.onMute = false;\n    this.onHold = false;\n    this.onRecord = false;\n    this.contact = undefined;\n\n    var ua = new UserAgent();\n\n    this.ua = ua;\n    this.on = ua.on.bind(ua);\n\n    this.username = null;\n\n    this.isRegistered = false;\n    this.isRegistering = false;\n    this.isUnregistering = false;\n\n    this.events = EVENT_NAMES;\n\n    this.causes = SIP.C.causes;\n    this.reasons = SIP.C.REASON_PHRASE;\n\n    //naming convention: incoming or sipincoming?\n    service.on(EVENT_NAMES.sipIncomingCall, function(line) {\n        service.ua.eventEmitter.emit(EVENT_NAMES.incomingCall, line);\n    });\n\n    //naming convention: outgoing or sipoutgoing?\n    service.on(EVENT_NAMES.outgoingCall, function(line) {\n        if (service.activeLine && !service.activeLine.isOnHold()) {\n            service.activeLine.setHold();\n        }\n        service.__callDeferred && service.__callDeferred.resolve(line);\n        service.__callDeferred = null;\n    });\n\n    //naming convention: call or line?\n    service.on([EVENT_NAMES.callEnded, EVENT_NAMES.callFailed], function(call) {\n        //delete activeLine property if the call has ended on the other side\n        if (call && service.activeLine && call === service.activeLine) {\n            service.activeLine = null;\n        }\n    });\n\n    // On Call Failed due to 503 Invite Connection error reconnect the call\n    service.on(EVENT_NAMES.callFailed, function(call, response, cause) {\n        if (response) {\n            switch (true) {\n                //[WRTC-424] Should reconnect the websocket if received 503 on INVITE\n                case (/^503$/.test(response.status_code)):\n                    //This method will throw 'Connection Error', so we just remove it\n                    call.session.onTransportError = function() {};\n                    //Re-register after 500ms\n                    setTimeout(service.reregister.bind(service, true), 500);\n                    break;\n            }\n        }\n    });\n\n\n    // Setting flags for SIP Registration process\n    service.on(EVENT_NAMES.sipRegistered, function(e) {\n        service.__sipRegistered = true;\n        service.__registerDeferred && service.__registerDeferred.resolve(e);\n        service.isRegistered = true;\n        service.isRegistering = false;\n        service.isUnregistering = false;\n        service.isUnregistered = false;\n    });\n\n    service.on([EVENT_NAMES.sipRegistrationFailed, EVENT_NAMES.sipConnectionFailed], function(e) {\n        service.__sipRegistered = false;\n        service.__registerDeferred && service.__registerDeferred.reject(e);\n        service.isRegistered = false;\n        service.isRegistering = false;\n        service.isUnregistering = false;\n        service.isUnregistered = false;\n    });\n\n    service.on(EVENT_NAMES.sipUnRegistered, function(e) {\n        service.__sipRegistered = false;\n        service.__unregisterDeferred && service.__unregisterDeferred.resolve(e);\n        service.isRegistered = false;\n        service.isRegistering = false;\n        service.isUnregistered = true;\n        service.isUnregistering = false;\n    });\n\n    window.addEventListener('unload', function() {\n        service.hangup();\n        service.unregister();\n    });\n\n    this._audioHelper = null;\n    if (options.audioHelper) service.createAudioHelper(options.audioHelper);\n\n    this._appKey = options.appKey;\n    this._appName = options.appName;\n    this._appVersion = options.appVersion;\n\n    this._x_userAgent = (options.appName ? (options.appName + (options.appVersion ? '/' + options.appVersion : '')) + ' ' : '') +\n                      'RCWEBPHONE/' + WebPhone.version;\n\n    this._client_id = options.appkey;\n\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.version = '0.1.0';\n\nWebPhone.PhoneLine = PhoneLine;\nWebPhone.EventEmitter = EventEmitter;\nWebPhone.UserAgent = UserAgent;\nWebPhone.AudioHelper = AudioHelper;\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n/**\n * @param [options]\n * @return {AudioHelper}\n */\nWebPhone.prototype.createAudioHelper = function(options) {\n    if (!this._audioHelper) {\n        console.log('Helper Created');\n        this._audioHelper = new AudioHelper(this, options);\n    }\n    return this._audioHelper;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.prototype.register = function(info, checkFlags) {\n\n    try {\n        var service = this;\n\n        // console.log(\"Sip Data\"+JSON.stringify(data));\n\n        if (!checkFlags || (\n            typeof(info.sipFlags) === 'object' &&\n                //checking for undefined for platform v7.3, which doesn't support this flag\n            (info.sipFlags.outboundCallsEnabled === undefined || info.sipFlags.outboundCallsEnabled === true))\n        ) {\n\n            // Access SIP flags\n            this.__sipOutboundEnabled = info.sipFlags.outboundCallsEnabled;\n\n            // console.log('SIP Provision data', data+'\\n');\n            info = info.sipInfo[0];\n\n        } else {\n            throw new Error('ERROR.sipOutboundNotAvailable'); //FIXME Better error reporting...\n        }\n\n        var headers = [];\n        var endpointId = this.uuid;\n        if (endpointId) {\n            headers.push('P-rc-endpoint-id: ' + endpointId);\n            headers.push('x-user-agent:'+ this._x_userAgent);\n            headers.push('client-id:'+this._client_id);\n        }\n\n        extend(info, {\n            extraHeaders: headers\n        });\n\n        if (service.isRegistered) {\n            console.warn('Already registered, please unregister the UA first');\n            return service.__registerDeferred.promise;\n        }\n\n        if (service.isRegistering) {\n            console.warn('Already registering the UA');\n            return service.__registerDeferred.promise;\n        }\n\n        service.__registerDeferred = defer();\n        service.isRegistering = true;\n        service.isRegistered = false;\n\n        //compatability properties\n        info.wsServers = info.outboundProxy && info.transport\n            ? info.transport.toLowerCase() + '://' + info.outboundProxy\n            : info.wsServers;\n        info.domain = info.domain || info.sipDomain;\n        info.username = info.username || info.userName;\n\n        info.extraHeaders = Array.isArray(info.extraHeaders) ? info.extraHeaders : [];\n\n\n\n\n\n        var options = {\n            wsServers: info.wsServers,\n            uri: \"sip:\" + info.username + \"@\" + info.domain,\n            password: info.password,\n            authorizationUser: info.authorizationId,\n            traceSip: true,\n            stunServers: info.stunServers || ['stun:74.125.194.127:19302'],\n            turnServers: [],\n            log: {\n                level: 3 //FIXME LOG LEVEL 3\n            },\n            domain: info.domain,\n            autostart: false,   //turn off autostart on UA creation\n            register: false,     //turn off auto register on UA creation,\n            iceGatheringTimeout: info.iceGatheringTimeout || 3000,\n\n            headers: headers\n        };\n\n        service.username = info.userName;\n        service.ua.setSIPConfig(options);\n        service.ua.start({\n            extraHeaders: info.extraHeaders\n        });\n    }\n    catch (e) {\n        service.isRegistering = false;\n        service.isRegistered = false;\n        return Promise.reject(e);\n    }\n\n    return service.__registerDeferred.promise;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.prototype.reregister = function(reconnect) {\n    var service = this;\n    if (service.isRegistering) return service.__registerDeferred;\n    service.__registerDeferred = defer();\n    service.isRegistering = true;\n    service.ua.reregister({}, !!reconnect);\n    return service.__registerDeferred.promise;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.prototype.unregister = function() {\n    var service = this;\n    if (service.isRegistering) {\n        service.ua.forceDisconnect();\n        service.isRegistering = false;\n        service.isUnregistering = false;\n        service.isRegistered = false;\n        service.isUnregistered = true;\n    }\n\n    if (service.isUnregistered || service.isUnregistering) return service.__unregisterDeferred;\n\n    service.isUnregistering = true;\n    service.isUnregistered = false;\n\n    service.__unregisterDeferred = defer();\n    if (service.__sipRegistered) {\n        service.ua.stop();\n    }\n    else {\n        service.__unregisterDeferred.resolve(null);\n    }\n    return service.__unregisterDeferred.promise.catch(function() {\n        return null;\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.prototype.forceDisconnect = function() {\n    this.ua.forceDisconnect();\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.prototype.call = function(toNumber, fromNumber, country) {\n    var service = this;\n    if(!this.__sipOutboundEnabled || false === Boolean(this.__sipOutboundEnabled)) {\n        throw new Error('Outbound calling is disabled'); // TODO: Fix this to be more robust error messaging\n    }\n    if(!toNumber)\n        throw new Error('Invalid or undefined [toNumber]');\n    if (!service.__callDeferred) {\n        service.__callDeferred = defer();\n        this.activeLine = service.ua.call.call(service.ua, toNumber, {\n            fromNumber: fromNumber,\n            country: country\n        });\n    }\n    return service.__callDeferred;\n};\n\n\n/*--------------------------------------------------------------------------------------------------------------------*/\nWebPhone.prototype.answer = function(line) {\n    var incomingLines = this.ua.getIncomingLinesArray();\n    var activeLines = this.ua.getActiveLinesArray();\n    var self = this;\n\n    return new Promise(function(resolve, reject) {\n        if (!line) {\n            line = incomingLines.length > 0 && incomingLines[0];\n        }\n\n        if (line) {\n            var promises = [];\n            activeLines.forEach(function (activeLine) {\n                if (activeLine !== line) {\n                    !activeLine.isOnHold() && promises.push(activeLine.setHold(true));\n                }\n            });\n            resolve(Promise\n                .all(promises)\n                .then(function () {\n                    self.activeLine = line;\n                    self.ua.answer(line);\n                })\n                .catch(function (e) {\n                    self.hangup(line);\n                    throw e;\n                }));\n        } else {\n            reject();            \n        }\n    });\n\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nWebPhone.prototype.onCall = function() {\n    return this.ua.getActiveLinesArray().filter(function(line) {\n            return line.onCall;\n        }).length > 0;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/***\n * deprecated\n * @param line\n * @returns {*}\n */\nWebPhone.prototype.hangup = function(line) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        self.ua.hangup(line);\n        if (line === self.activeLine) self.activeLine = null;\n        resolve();\n    });\n};\n\nWebPhone.prototype.getLine = function(line) {\n    if (!line) line = this.activeLine;\n    if (!line) throw new Error('No line or no active line');\n    return line;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//FIXME: Check if we can replace this with  SIPJS dtmf(tone,[options]) ref: http://sipjs.com/api/0.7.0/session/#dtmftone-options\n/***\n * deprecated\n * @param value\n * @param line\n * @returns {*}\n */\nWebPhone.prototype.sendDTMF = function(value, line) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        line && line.sendDTMF.call(line, value);\n        resolve();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/***\n * deprecated\n * @param line\n * @returns {*}\n */\nWebPhone.prototype.hold = function(line) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        line && line.setHold(true);\n        if (line === self.activeLine) self.activeLine = null;\n        resolve();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/***\n * deprecated\n * @param line\n * @returns {*}\n */\nWebPhone.prototype.unhold = function(line) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        if (line) {\n            self.ua.getActiveLinesArray().forEach(function (activeLine) {\n                if (activeLine !== line && !activeLine.isIncoming() && !activeLine.isOnHold()) {\n                    activeLine.setHold(true);\n                }\n            });\n            line.setHold(false);\n            self.activeLine = line;\n        }\n        resolve();\n    });\n};\n\n////FIXME: Use SIPJS mute() and unmute() ref:http://sipjs.com/api/0.7.0/session/#muteoptions\n/*--------------------------------------------------------------------------------------------------------------------*/\n/***\n * deprecated\n * @param line\n * @returns {*}\n */\nWebPhone.prototype.mute = function(line) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        line && line.setMute(true);\n        resolve();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/***\n * deprecated\n * @param line\n * @returns {*}\n */\nWebPhone.prototype.unmute = function(line) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        line && line.setMute(false);\n        resolve();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n/***\n * deprecated\n * @param line\n * @param target\n * @param options\n * @returns {*}\n */\n//Phone-line->transfer->blindTransfer\nWebPhone.prototype.transfer = function(line, target, options) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        line = self.getLine(line);\n        line && line.transfer(target, options);\n        if (line === self.activeLine) self.activeLine = null;\n        resolve();\n    });\n};\n\nmodule.exports = WebPhone;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * @name SIP\n * @namespace\n */\nmodule.exports = (function(window) {\n  \"use strict\";\n\n  var SIP = {};\n\n  var pkg = require('../package.json');\n\n  Object.defineProperties(SIP, {\n    version: {\n      get: function(){ return pkg.version; }\n    },\n    name: {\n      get: function(){ return pkg.title; }\n    }\n  });\n\n  require('./Utils.js')(SIP);\n  var Logger = require('./Logger.js');\n  SIP.LoggerFactory = require('./LoggerFactory.js')(window, Logger);\n  require('./EventEmitter.js')(SIP);\n  SIP.C = require('./Constants.js')(SIP.name, SIP.version);\n  SIP.Exceptions = require('./Exceptions.js');\n  SIP.Timers = require('./Timers.js')(window);\n  require('./Transport.js')(SIP, window);\n  require('./Parser.js')(SIP);\n  require('./SIPMessage.js')(SIP);\n  require('./URI.js')(SIP);\n  require('./NameAddrHeader.js')(SIP);\n  require('./Transactions.js')(SIP, window);\n  var DialogRequestSender = require('./Dialog/RequestSender.js')(SIP, window);\n  require('./Dialogs.js')(SIP, DialogRequestSender);\n  require('./RequestSender.js')(SIP);\n  require('./RegisterContext.js')(SIP, window);\n  SIP.MediaHandler = require('./MediaHandler.js')(SIP.EventEmitter);\n  require('./ClientContext.js')(SIP);\n  require('./ServerContext.js')(SIP);\n  var SessionDTMF = require('./Session/DTMF.js')(SIP);\n  require('./Session.js')(SIP, window, SessionDTMF);\n  require('./Subscription.js')(SIP, window);\n  var WebRTCMediaHandler = require('./WebRTC/MediaHandler.js')(SIP);\n  var WebRTCMediaStreamManager = require('./WebRTC/MediaStreamManager.js')(SIP);\n  SIP.WebRTC = require('./WebRTC.js')(SIP.Utils, window, WebRTCMediaHandler, WebRTCMediaStreamManager);\n  require('./UA.js')(SIP, window);\n  SIP.Hacks = require('./Hacks.js')(SIP);\n  require('./SanityCheck.js')(SIP);\n  SIP.DigestAuthentication = require('./DigestAuthentication.js')(SIP.Utils);\n  SIP.Grammar = require('./Grammar/dist/Grammar')(SIP);\n\n  return SIP;\n})((typeof window !== 'undefined') ? window : global);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/SIP.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = {\n\t\"_args\": [\n\t\t[\n\t\t\t\"sip.js@0.6.4\",\n\t\t\t\"/Users/howard.zhang/Sites/ringcentral-web-phone\"\n\t\t]\n\t],\n\t\"_from\": \"sip.js@0.6.4\",\n\t\"_id\": \"sip.js@0.6.4\",\n\t\"_inCache\": true,\n\t\"_installable\": true,\n\t\"_location\": \"/sip.js\",\n\t\"_npmUser\": {\n\t\t\"email\": \"eric.green@onsip.com\",\n\t\t\"name\": \"egreen_onsip\"\n\t},\n\t\"_npmVersion\": \"1.4.13\",\n\t\"_phantomChildren\": {},\n\t\"_requested\": {\n\t\t\"name\": \"sip.js\",\n\t\t\"raw\": \"sip.js@0.6.4\",\n\t\t\"rawSpec\": \"0.6.4\",\n\t\t\"scope\": null,\n\t\t\"spec\": \"0.6.4\",\n\t\t\"type\": \"version\"\n\t},\n\t\"_requiredBy\": [\n\t\t\"/\"\n\t],\n\t\"_resolved\": \"https://registry.npmjs.org/sip.js/-/sip.js-0.6.4.tgz\",\n\t\"_shasum\": \"e080d4b0fa1a7dd803741d6bca6d32c29ae37380\",\n\t\"_shrinkwrap\": null,\n\t\"_spec\": \"sip.js@0.6.4\",\n\t\"_where\": \"/Users/howard.zhang/Sites/ringcentral-web-phone\",\n\t\"author\": {\n\t\t\"email\": \"will@onsip.com\",\n\t\t\"name\": \"Will Mitchell\"\n\t},\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/onsip/SIP.js/issues\"\n\t},\n\t\"contributors\": [\n\t\t{\n\t\t\t\"url\": \"http://sipjs.com/authors/\"\n\t\t}\n\t],\n\t\"dependencies\": {},\n\t\"description\": \"A simple, intuitive, and powerful JavaScript signaling library\",\n\t\"devDependencies\": {\n\t\t\"browserify\": \"^4.1.8\",\n\t\t\"grunt\": \"~0.4.0\",\n\t\t\"grunt-browserify\": \"^2.1.0\",\n\t\t\"grunt-cli\": \"~0.1.6\",\n\t\t\"grunt-contrib-copy\": \"^0.5.0\",\n\t\t\"grunt-contrib-jasmine\": \"~0.6.0\",\n\t\t\"grunt-contrib-jshint\": \">0.5.0\",\n\t\t\"grunt-contrib-uglify\": \"~0.2.0\",\n\t\t\"grunt-peg\": \"~1.3.1\",\n\t\t\"grunt-trimtrailingspaces\": \"^0.4.0\",\n\t\t\"node-minify\": \"~0.7.2\",\n\t\t\"pegjs\": \"0.8.0\",\n\t\t\"sdp-transform\": \"~0.4.0\"\n\t},\n\t\"directories\": {},\n\t\"dist\": {\n\t\t\"shasum\": \"e080d4b0fa1a7dd803741d6bca6d32c29ae37380\",\n\t\t\"tarball\": \"http://registry.npmjs.org/sip.js/-/sip.js-0.6.4.tgz\"\n\t},\n\t\"engines\": {\n\t\t\"node\": \">=0.8\"\n\t},\n\t\"gitHead\": \"209fb9bb50f1918522d37a002b83f21abd6946ab\",\n\t\"homepage\": \"http://sipjs.com\",\n\t\"keywords\": [\n\t\t\"sip\",\n\t\t\"websocket\",\n\t\t\"webrtc\",\n\t\t\"library\",\n\t\t\"javascript\"\n\t],\n\t\"license\": \"MIT\",\n\t\"main\": \"src/SIP.js\",\n\t\"maintainers\": [\n\t\t{\n\t\t\t\"email\": \"joseph@onsip.com\",\n\t\t\t\"name\": \"joseph-onsip\"\n\t\t},\n\t\t{\n\t\t\t\"email\": \"eric.green@onsip.com\",\n\t\t\t\"name\": \"egreen_onsip\"\n\t\t}\n\t],\n\t\"name\": \"sip.js\",\n\t\"optionalDependencies\": {},\n\t\"readme\": \"ERROR: No README data found!\",\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git+https://github.com/onsip/SIP.js.git\"\n\t},\n\t\"scripts\": {\n\t\t\"test\": \"grunt travis --verbose\"\n\t},\n\t\"title\": \"SIP.js\",\n\t\"version\": \"0.6.4\"\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/package.json\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * @fileoverview Utils\n */\n\nmodule.exports = function (SIP) {\nvar Utils;\n\nUtils= {\n\n  augment: function (object, constructor, args, override) {\n    var idx, proto;\n\n    // Add public properties from constructor's prototype onto object\n    proto = constructor.prototype;\n    for (idx in proto) {\n      if (override || object[idx] === undefined) {\n        object[idx] = proto[idx];\n      }\n    }\n\n    // Construct the object as though it were just created by constructor\n    constructor.apply(object, args);\n  },\n\n  optionsOverride: function (options, winner, loser, isDeprecated, logger, defaultValue) {\n    if (isDeprecated && options[loser]) {\n      logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');\n    }\n\n    if (options[winner] && options[loser]) {\n      logger.warn(winner + ' overriding ' + loser);\n    }\n\n    options[winner] = options[winner] || options[loser] || defaultValue;\n  },\n\n  desugarSessionOptions: function desugarSessionOptions (options) {\n    if (global.HTMLMediaElement && options instanceof global.HTMLMediaElement) {\n      options = {\n        media: {\n          constraints: {\n            audio: true,\n            video: options.tagName === 'VIDEO'\n          },\n          render: {\n            remote: {\n              video: options\n            }\n          }\n        }\n      };\n    }\n    return options;\n  },\n\n  str_utf8_length: function(string) {\n    return encodeURIComponent(string).replace(/%[A-F\\d]{2}/g, 'U').length;\n  },\n\n  getPrefixedProperty: function (object, name) {\n    if (object == null) {\n      return;\n    }\n    var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);\n    var prefixedNames = [name, 'webkit' + capitalizedName, 'moz' + capitalizedName];\n    for (var i in prefixedNames) {\n      var property = object[prefixedNames[i]];\n      if (property) {\n        return property;\n      }\n    }\n  },\n\n  generateFakeSDP: function(body) {\n    if (!body) {\n      return;\n    }\n\n    var start = body.indexOf('o=');\n    var end = body.indexOf('\\r\\n', start);\n\n    return 'v=0\\r\\n' + body.slice(start, end) + '\\r\\ns=-\\r\\nt=0 0\\r\\nc=IN IP4 0.0.0.0';\n  },\n\n  isFunction: function(fn) {\n    if (fn !== undefined) {\n      return Object.prototype.toString.call(fn) === '[object Function]';\n    } else {\n      return false;\n    }\n  },\n\n  isDecimal: function (num) {\n    return !isNaN(num) && (parseFloat(num) === parseInt(num,10));\n  },\n\n  createRandomToken: function(size, base) {\n    var i, r,\n      token = '';\n\n    base = base || 32;\n\n    for( i=0; i < size; i++ ) {\n      r = Math.random() * base|0;\n      token += r.toString(base);\n    }\n\n    return token;\n  },\n\n  newTag: function() {\n    return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);\n  },\n\n  // http://stackoverflow.com/users/109538/broofa\n  newUUID: function() {\n    var UUID =  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);\n      return v.toString(16);\n    });\n\n    return UUID;\n  },\n\n  hostType: function(host) {\n    if (!host) {\n      return;\n    } else {\n      host = SIP.Grammar.parse(host,'host');\n      if (host !== -1) {\n        return host.host_type;\n      }\n    }\n  },\n\n  /**\n  * Normalize SIP URI.\n  * NOTE: It does not allow a SIP URI without username.\n  * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.\n  * Detects the domain part (if given) and properly hex-escapes the user portion.\n  * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.\n  * @private\n  * @param {String} target\n  * @param {String} [domain]\n  */\n  normalizeTarget: function(target, domain) {\n    var uri, target_array, target_user, target_domain;\n\n    // If no target is given then raise an error.\n    if (!target) {\n      return;\n    // If a SIP.URI instance is given then return it.\n    } else if (target instanceof SIP.URI) {\n      return target;\n\n    // If a string is given split it by '@':\n    // - Last fragment is the desired domain.\n    // - Otherwise append the given domain argument.\n    } else if (typeof target === 'string') {\n      target_array = target.split('@');\n\n      switch(target_array.length) {\n        case 1:\n          if (!domain) {\n            return;\n          }\n          target_user = target;\n          target_domain = domain;\n          break;\n        case 2:\n          target_user = target_array[0];\n          target_domain = target_array[1];\n          break;\n        default:\n          target_user = target_array.slice(0, target_array.length-1).join('@');\n          target_domain = target_array[target_array.length-1];\n      }\n\n      // Remove the URI scheme (if present).\n      target_user = target_user.replace(/^(sips?|tel):/i, '');\n\n      // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.\n      if (/^[\\-\\.\\(\\)]*\\+?[0-9\\-\\.\\(\\)]+$/.test(target_user)) {\n        target_user = target_user.replace(/[\\-\\.\\(\\)]/g, '');\n      }\n\n      // Build the complete SIP URI.\n      target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain;\n\n      // Finally parse the resulting URI.\n      if (uri = SIP.URI.parse(target)) {\n        return uri;\n      } else {\n        return;\n      }\n    } else {\n      return;\n    }\n  },\n\n  /**\n  * Hex-escape a SIP URI user.\n  * @private\n  * @param {String} user\n  */\n  escapeUser: function(user) {\n    // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n    return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');\n  },\n\n  headerize: function(string) {\n    var exceptions = {\n      'Call-Id': 'Call-ID',\n      'Cseq': 'CSeq',\n      'Rack': 'RAck',\n      'Rseq': 'RSeq',\n      'Www-Authenticate': 'WWW-Authenticate'\n      },\n      name = string.toLowerCase().replace(/_/g,'-').split('-'),\n      hname = '',\n      parts = name.length, part;\n\n    for (part = 0; part < parts; part++) {\n      if (part !== 0) {\n        hname +='-';\n      }\n      hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);\n    }\n    if (exceptions[hname]) {\n      hname = exceptions[hname];\n    }\n    return hname;\n  },\n\n  sipErrorCause: function(status_code) {\n    var cause;\n\n    for (cause in SIP.C.SIP_ERROR_CAUSES) {\n      if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {\n        return SIP.C.causes[cause];\n      }\n    }\n\n    return SIP.C.causes.SIP_FAILURE_CODE;\n  },\n\n  /**\n  * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n  * @private\n  */\n  getRandomTestNetIP: function() {\n    function getOctet(from,to) {\n      return Math.floor(Math.random()*(to-from+1)+from);\n    }\n    return '192.0.2.' + getOctet(1, 254);\n  },\n\n  getAllowedMethods: function(ua) {\n    var event,\n      allowed = SIP.UA.C.ALLOWED_METHODS.toString();\n\n    for (event in SIP.UA.C.EVENT_METHODS) {\n      if (ua.checkListener(event)) {\n        allowed += ','+ SIP.UA.C.EVENT_METHODS[event];\n      }\n    }\n\n    return allowed;\n  },\n\n  // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info\n  calculateMD5: function(string) {\n    function RotateLeft(lValue, iShiftBits) {\n      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));\n    }\n\n    function AddUnsigned(lX,lY) {\n      var lX4,lY4,lX8,lY8,lResult;\n      lX8 = (lX & 0x80000000);\n      lY8 = (lY & 0x80000000);\n      lX4 = (lX & 0x40000000);\n      lY4 = (lY & 0x40000000);\n      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);\n      if (lX4 & lY4) {\n        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\n      }\n      if (lX4 | lY4) {\n        if (lResult & 0x40000000) {\n          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n        } else {\n          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\n        }\n      } else {\n        return (lResult ^ lX8 ^ lY8);\n      }\n    }\n\n    function F(x,y,z) {\n      return (x & y) | ((~x) & z);\n    }\n\n    function G(x,y,z) {\n      return (x & z) | (y & (~z));\n    }\n\n    function H(x,y,z) {\n      return (x ^ y ^ z);\n    }\n\n    function I(x,y,z) {\n      return (y ^ (x | (~z)));\n    }\n\n    function FF(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    }\n\n    function GG(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    }\n\n    function HH(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    }\n\n    function II(a,b,c,d,x,s,ac) {\n      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));\n      return AddUnsigned(RotateLeft(a, s), b);\n    }\n\n    function ConvertToWordArray(string) {\n      var lWordCount;\n      var lMessageLength = string.length;\n      var lNumberOfWords_temp1=lMessageLength + 8;\n      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;\n      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;\n      var lWordArray=Array(lNumberOfWords-1);\n      var lBytePosition = 0;\n      var lByteCount = 0;\n      while ( lByteCount < lMessageLength ) {\n        lWordCount = (lByteCount-(lByteCount % 4))/4;\n        lBytePosition = (lByteCount % 4)*8;\n        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));\n        lByteCount++;\n      }\n      lWordCount = (lByteCount-(lByteCount % 4))/4;\n      lBytePosition = (lByteCount % 4)*8;\n      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\n      lWordArray[lNumberOfWords-2] = lMessageLength<<3;\n      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;\n      return lWordArray;\n    }\n\n    function WordToHex(lValue) {\n      var WordToHexValue=\"\",WordToHexValue_temp=\"\",lByte,lCount;\n      for (lCount = 0;lCount<=3;lCount++) {\n        lByte = (lValue>>>(lCount*8)) & 255;\n        WordToHexValue_temp = \"0\" + lByte.toString(16);\n        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);\n      }\n      return WordToHexValue;\n    }\n\n    function Utf8Encode(string) {\n      string = string.replace(/\\r\\n/g,\"\\n\");\n      var utftext = \"\";\n\n      for (var n = 0; n < string.length; n++) {\n        var c = string.charCodeAt(n);\n\n        if (c < 128) {\n          utftext += String.fromCharCode(c);\n        }\n        else if((c > 127) && (c < 2048)) {\n          utftext += String.fromCharCode((c >> 6) | 192);\n          utftext += String.fromCharCode((c & 63) | 128);\n        }\n        else {\n          utftext += String.fromCharCode((c >> 12) | 224);\n          utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n          utftext += String.fromCharCode((c & 63) | 128);\n        }\n      }\n      return utftext;\n    }\n\n    var x=[];\n    var k,AA,BB,CC,DD,a,b,c,d;\n    var S11=7, S12=12, S13=17, S14=22;\n    var S21=5, S22=9 , S23=14, S24=20;\n    var S31=4, S32=11, S33=16, S34=23;\n    var S41=6, S42=10, S43=15, S44=21;\n\n    string = Utf8Encode(string);\n\n    x = ConvertToWordArray(string);\n\n    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;\n\n    for (k=0;k<x.length;k+=16) {\n      AA=a; BB=b; CC=c; DD=d;\n      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);\n      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);\n      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);\n      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);\n      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);\n      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);\n      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);\n      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);\n      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);\n      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);\n      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);\n      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);\n      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);\n      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);\n      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);\n      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);\n      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);\n      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);\n      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);\n      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);\n      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);\n      d=GG(d,a,b,c,x[k+10],S22,0x2441453);\n      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);\n      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);\n      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);\n      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);\n      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);\n      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);\n      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);\n      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);\n      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);\n      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);\n      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);\n      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);\n      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);\n      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);\n      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);\n      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);\n      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);\n      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);\n      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);\n      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);\n      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);\n      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);\n      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);\n      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);\n      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);\n      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);\n      a=II(a,b,c,d,x[k+0], S41,0xF4292244);\n      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);\n      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);\n      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);\n      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);\n      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);\n      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);\n      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);\n      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);\n      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);\n      c=II(c,d,a,b,x[k+6], S43,0xA3014314);\n      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);\n      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);\n      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);\n      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);\n      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);\n      a=AddUnsigned(a,AA);\n      b=AddUnsigned(b,BB);\n      c=AddUnsigned(c,CC);\n      d=AddUnsigned(d,DD);\n    }\n\n    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);\n\n    return temp.toLowerCase();\n  }\n};\n\nSIP.Utils = Utils;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Utils.js\n ** module id = 4\n ** module chunks = 0\n **/","\nmodule.exports = (function() {\n\nvar Logger = function(logger, category, label) {\n  this.logger = logger;\n  this.category = category;\n  this.label = label;\n};\n\n\nLogger.prototype.debug = function(content) {\n  this.logger.debug(this.category, this.label, content);\n};\n\nLogger.prototype.log = function(content) {\n  this.logger.log(this.category, this.label, content);\n};\n\nLogger.prototype.warn = function(content) {\n  this.logger.warn(this.category, this.label, content);\n};\n\nLogger.prototype.error = function(content) {\n  this.logger.error(this.category, this.label, content);\n};\n\nreturn Logger;\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Logger.js\n ** module id = 5\n ** module chunks = 0\n **/","\nmodule.exports = function (window, Logger) {\n\n// Console is not defined in ECMAScript, so just in case...\nvar console = window.console || {\n  debug: function () {},\n  log: function () {},\n  warn: function () {},\n  error: function () {}\n};\n\nvar LoggerFactory = function() {\n  var logger,\n    levels = {\n    'error': 0,\n    'warn': 1,\n    'log': 2,\n    'debug': 3\n    },\n\n    level = 2,\n    builtinEnabled = true,\n    connector = null;\n\n    this.loggers = {};\n\n    logger = this.getLogger('sip.loggerfactory');\n\n\n  Object.defineProperties(this, {\n    builtinEnabled: {\n      get: function(){ return builtinEnabled; },\n      set: function(value){\n        if (typeof value === 'boolean') {\n          builtinEnabled = value;\n        } else {\n          logger.error('invalid \"builtinEnabled\" parameter value: '+ JSON.stringify(value));\n        }\n      }\n    },\n\n    level: {\n      get: function() {return level; },\n      set: function(value) {\n        if (value >= 0 && value <=3) {\n          level = value;\n        } else if (value > 3) {\n          level = 3;\n        } else if (levels.hasOwnProperty(value)) {\n          level = levels[value];\n        } else {\n          logger.error('invalid \"level\" parameter value: '+ JSON.stringify(value));\n        }\n      }\n    },\n\n    connector: {\n      get: function() {return connector; },\n      set: function(value){\n        if(value === null || value === \"\" || value === undefined) {\n          connector = null;\n        } else if (typeof value === 'function') {\n          connector = value;\n        } else {\n          logger.error('invalid \"connector\" parameter value: '+ JSON.stringify(value));\n        }\n      }\n    }\n  });\n};\n\nLoggerFactory.prototype.print = function(target, category, label, content) {\n  var prefix = [];\n\n  prefix.push(new Date());\n\n  prefix.push(category);\n\n  if (label) {\n    prefix.push(label);\n  }\n\n  prefix.push('');\n\n  if (typeof content === 'string') {\n    target.call(console, prefix.join(' | ') + content);\n  } else {\n    target.call(console, content);\n  }\n};\n\nLoggerFactory.prototype.debug = function(category, label, content) {\n  if (this.level === 3) {\n    if (this.builtinEnabled) {\n      this.print(console.debug, category, label, content);\n    }\n\n    if (this.connector) {\n      this.connector('debug', category, label, content);\n    }\n  }\n};\n\nLoggerFactory.prototype.log = function(category, label, content) {\n  if (this.level >= 2) {\n    if (this.builtinEnabled) {\n      this.print(console.log, category, label, content);\n    }\n\n    if (this.connector) {\n      this.connector('log', category, label, content);\n    }\n  }\n};\n\nLoggerFactory.prototype.warn = function(category, label, content) {\n  if (this.level >= 1) {\n    if (this.builtinEnabled) {\n      this.print(console.warn, category, label, content);\n    }\n\n    if (this.connector) {\n      this.connector('warn', category, label, content);\n    }\n  }\n};\n\nLoggerFactory.prototype.error = function(category, label, content) {\n  if (this.builtinEnabled) {\n    this.print(console.error,category, label, content);\n  }\n\n  if (this.connector) {\n    this.connector('error', category, label, content);\n  }\n};\n\nLoggerFactory.prototype.getLogger = function(category, label) {\n  var logger;\n\n  if (label && this.level === 3) {\n    return new Logger(this, category, label);\n  } else if (this.loggers[category]) {\n    return this.loggers[category];\n  } else {\n    logger = new Logger(this, category);\n    this.loggers[category] = logger;\n    return logger;\n  }\n};\n\nreturn LoggerFactory;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/LoggerFactory.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * @fileoverview EventEmitter\n */\n\n/**\n * @augments SIP\n * @class Class creating an event emitter.\n */\nmodule.exports = function (SIP) {\nvar\n  EventEmitter,\n  Event,\n  logger = new SIP.LoggerFactory().getLogger('sip.eventemitter'),\n  C = {\n    MAX_LISTENERS: 10\n  };\n\nEventEmitter = function(){};\nEventEmitter.prototype = {\n  /**\n   * Initialize events dictionaries.\n   * @param {Array} events\n   */\n  initEvents: function(events) {\n    this.events = {};\n\n    return this.initMoreEvents(events);\n  },\n\n  initMoreEvents: function(events) {\n    var idx;\n\n    if (!this.logger) {\n      this.logger = logger;\n    }\n\n    this.maxListeners = C.MAX_LISTENERS;\n\n    for (idx = 0; idx < events.length; idx++) {\n      if (!this.events[events[idx]]) {\n        this.logger.log('adding event '+ events[idx]);\n        this.events[events[idx]] = [];\n      } else {\n        this.logger.log('skipping event '+ events[idx]+ ' - Event exists');\n      }\n    }\n\n    return this;\n  },\n\n  /**\n  * Check whether an event exists or not.\n  * @param {String} event\n  * @returns {Boolean}\n  */\n  checkEvent: function(event) {\n    return !!(this.events && this.events[event]);\n  },\n\n  /**\n  * Check whether an event exists and has at least one listener or not.\n  * @param {String} event\n  * @returns {Boolean}\n  */\n  checkListener: function(event) {\n    return this.checkEvent(event) && this.events[event].length > 0;\n  },\n\n  /**\n  * Add a listener to the end of the listeners array for the specified event.\n  * @param {String} event\n  * @param {Function} listener\n  */\n  on: function(event, listener, bindTarget) {\n    if (listener === undefined) {\n      return this;\n    } else if (typeof listener !== 'function') {\n      this.logger.error('listener must be a function');\n      return this;\n    } else if (!this.checkEvent(event)) {\n      this.logger.error('unable to add a listener to a nonexistent event '+ event);\n      throw new TypeError('Invalid or uninitialized event: ' + event);\n    }\n\n    var listenerObj = { listener: listener };\n    if (bindTarget) {\n      listenerObj.bindTarget = bindTarget;\n    }\n\n    if (this.events[event].length >= this.maxListeners) {\n      this.logger.warn('max listeners exceeded for event '+ event);\n      return this;\n    }\n\n    this.events[event].push(listenerObj);\n    this.logger.log('new listener added to event '+ event);\n    return this;\n  },\n\n  /**\n  * Add a one time listener for the specified event.\n  * The listener is invoked only the next time the event is fired, then it is removed.\n  * @param {String} event\n  * @param {Function} listener\n  */\n  once: function(event, listener, bindTarget) {\n    var self = this;\n    function listenOnce () {\n      listener.apply(this, arguments);\n      self.off(event, listenOnce, bindTarget);\n    }\n\n    return this.on(event, listenOnce, bindTarget);\n  },\n\n  /**\n  * Remove a listener from the listener array for the specified event.\n  * Note that the order of the array elements will change after removing the listener\n  * @param {String} event\n  * @param {Function} listener\n  */\n  off: function(event, listener, bindTarget) {\n    var events, length,\n      idx = 0;\n\n    if (listener && typeof listener !== 'function') {\n      this.logger.error('listener must be a function');\n      return this;\n    } else if (!event) {\n      for (idx in this.events) {\n        this.events[idx] = [];\n      }\n      return this;\n    } else if (!this.checkEvent(event)) {\n      this.logger.error('unable to remove a listener from a nonexistent event '+ event);\n      throw new TypeError('Invalid or uninitialized event: ' + event);\n    }\n\n    events = this.events[event];\n    length = events.length;\n\n    while (idx < length) {\n      if (events[idx] &&\n          (!listener || events[idx].listener === listener) &&\n          (!bindTarget || events[idx].bindTarget === bindTarget)) {\n        events.splice(idx,1);\n      } else {\n        idx ++;\n      }\n    }\n\n    return this;\n  },\n\n  /**\n  * By default EventEmitter will print a warning\n  * if more than C.MAX_LISTENERS listeners are added for a particular event.\n  * This function allows that limit to be modified.\n  * @param {Number} listeners\n  */\n  setMaxListeners: function(listeners) {\n    if (typeof listeners !== 'number' || listeners < 0) {\n      this.logger.error('listeners must be a positive number');\n      return this;\n    }\n\n    this.maxListeners = listeners;\n    return this;\n  },\n\n  /**\n  * Execute each of the listeners in order with the supplied arguments.\n  * @param {String} events\n  * @param {Array} args\n  */\n  emit: function(event) {\n    if (!this.checkEvent(event)) {\n      this.logger.error('unable to emit a nonexistent event '+ event);\n      throw new TypeError('Invalid or uninitialized event: ' + event);\n    }\n\n    this.logger.log('emitting event '+ event);\n\n    // Fire event listeners\n    var args = Array.prototype.slice.call(arguments, 1);\n    this.events[event].slice().forEach(function (listener) {\n      try {\n        listener.listener.apply(listener.bindTarget || this, args);\n      } catch(err) {\n        this.logger.error(err.stack);\n      }\n    }, this);\n\n    return this;\n  }\n};\n\nEvent = function(type, sender, data) {\n  this.type = type;\n  this.sender= sender;\n  this.data = data;\n};\n\nEventEmitter.C = C;\n\nSIP.EventEmitter = EventEmitter;\nSIP.Event = Event;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/EventEmitter.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * @fileoverview SIP Constants\n */\n\n/**\n * SIP Constants.\n * @augments SIP\n */\n\nmodule.exports = function (name, version) {\nreturn {\n  USER_AGENT: name +'/'+ version,\n\n  // SIP scheme\n  SIP:  'sip',\n  SIPS: 'sips',\n\n  // End and Failure causes\n  causes: {\n    // Generic error causes\n    CONNECTION_ERROR:         'Connection Error',\n    REQUEST_TIMEOUT:          'Request Timeout',\n    SIP_FAILURE_CODE:         'SIP Failure Code',\n    INTERNAL_ERROR:           'Internal Error',\n\n    // SIP error causes\n    BUSY:                     'Busy',\n    REJECTED:                 'Rejected',\n    REDIRECTED:               'Redirected',\n    UNAVAILABLE:              'Unavailable',\n    NOT_FOUND:                'Not Found',\n    ADDRESS_INCOMPLETE:       'Address Incomplete',\n    INCOMPATIBLE_SDP:         'Incompatible SDP',\n    AUTHENTICATION_ERROR:     'Authentication Error',\n    DIALOG_ERROR:             'Dialog Error',\n\n    // Session error causes\n    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',\n    WEBRTC_ERROR:             'WebRTC Error',\n    CANCELED:                 'Canceled',\n    NO_ANSWER:                'No Answer',\n    EXPIRES:                  'Expires',\n    NO_ACK:                   'No ACK',\n    NO_PRACK:                 'No PRACK',\n    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',\n    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',\n    RTP_TIMEOUT:              'RTP Timeout'\n  },\n\n  supported: {\n    UNSUPPORTED:        'none',\n    SUPPORTED:          'supported',\n    REQUIRED:           'required'\n  },\n\n  SIP_ERROR_CAUSES: {\n    REDIRECTED: [300,301,302,305,380],\n    BUSY: [486,600],\n    REJECTED: [403,603],\n    NOT_FOUND: [404,604],\n    UNAVAILABLE: [480,410,408,430],\n    ADDRESS_INCOMPLETE: [484],\n    INCOMPATIBLE_SDP: [488,606],\n    AUTHENTICATION_ERROR:[401,407]\n  },\n\n  // SIP Methods\n  ACK:        'ACK',\n  BYE:        'BYE',\n  CANCEL:     'CANCEL',\n  INFO:       'INFO',\n  INVITE:     'INVITE',\n  MESSAGE:    'MESSAGE',\n  NOTIFY:     'NOTIFY',\n  OPTIONS:    'OPTIONS',\n  REGISTER:   'REGISTER',\n  UPDATE:     'UPDATE',\n  SUBSCRIBE:  'SUBSCRIBE',\n  REFER:      'REFER',\n  PRACK:      'PRACK',\n\n  /* SIP Response Reasons\n   * DOC: http://www.iana.org/assignments/sip-parameters\n   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7\n   */\n  REASON_PHRASE: {\n    100: 'Trying',\n    180: 'Ringing',\n    181: 'Call Is Being Forwarded',\n    182: 'Queued',\n    183: 'Session Progress',\n    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199\n    200: 'OK',\n    202: 'Accepted',  // RFC 3265\n    204: 'No Notification',  //RFC 5839\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Moved Temporarily',\n    305: 'Use Proxy',\n    380: 'Alternative Service',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    410: 'Gone',\n    412: 'Conditional Request Failed',  // RFC 3903\n    413: 'Request Entity Too Large',\n    414: 'Request-URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Unsupported URI Scheme',\n    417: 'Unknown Resource-Priority',  // RFC 4412\n    420: 'Bad Extension',\n    421: 'Extension Required',\n    422: 'Session Interval Too Small',  // RFC 4028\n    423: 'Interval Too Brief',\n    428: 'Use Identity Header',  // RFC 4474\n    429: 'Provide Referrer Identity',  // RFC 3892\n    430: 'Flow Failed',  // RFC 5626\n    433: 'Anonymity Disallowed',  // RFC 5079\n    436: 'Bad Identity-Info',  // RFC 4474\n    437: 'Unsupported Certificate',  // RFC 4744\n    438: 'Invalid Identity Header',  // RFC 4744\n    439: 'First Hop Lacks Outbound Support',  // RFC 5626\n    440: 'Max-Breadth Exceeded',  // RFC 5393\n    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events\n    470: 'Consent Needed',  // RFC 5360\n    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.\n    480: 'Temporarily Unavailable',\n    481: 'Call/Transaction Does Not Exist',\n    482: 'Loop Detected',\n    483: 'Too Many Hops',\n    484: 'Address Incomplete',\n    485: 'Ambiguous',\n    486: 'Busy Here',\n    487: 'Request Terminated',\n    488: 'Not Acceptable Here',\n    489: 'Bad Event',  // RFC 3265\n    491: 'Request Pending',\n    493: 'Undecipherable',\n    494: 'Security Agreement Required',  // RFC 3329\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Server Time-out',\n    505: 'Version Not Supported',\n    513: 'Message Too Large',\n    580: 'Precondition Failure',  // RFC 3312\n    600: 'Busy Everywhere',\n    603: 'Decline',\n    604: 'Does Not Exist Anywhere',\n    606: 'Not Acceptable'\n  }\n};\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Constants.js\n ** module id = 8\n ** module chunks = 0\n **/","/**\n * @fileoverview Exceptions\n */\n\n/**\n * SIP Exceptions.\n * @augments SIP\n */\nmodule.exports = {\n  ConfigurationError: (function(){\n    var exception = function(parameter, value) {\n      this.code = 1;\n      this.name = 'CONFIGURATION_ERROR';\n      this.parameter = parameter;\n      this.value = value;\n      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter \"'+ this.parameter +'\"';\n    };\n    exception.prototype = new Error();\n    return exception;\n  }()),\n\n  InvalidStateError: (function(){\n    var exception = function(status) {\n      this.code = 2;\n      this.name = 'INVALID_STATE_ERROR';\n      this.status = status;\n      this.message = 'Invalid status: ' + status;\n    };\n    exception.prototype = new Error();\n    return exception;\n  }()),\n\n  NotSupportedError: (function(){\n    var exception = function(message) {\n      this.code = 3;\n      this.name = 'NOT_SUPPORTED_ERROR';\n      this.message = message;\n    };\n    exception.prototype = new Error();\n    return exception;\n  }()),\n\n  NotReadyError: (function(){\n    var exception = function(message) {\n      this.code = 4;\n      this.name = 'NOT_READY_ERROR';\n      this.message = message;\n    };\n    exception.prototype = new Error();\n    return exception;\n  }())\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Exceptions.js\n ** module id = 9\n ** module chunks = 0\n **/","/**\n * @fileoverview SIP TIMERS\n */\n\n/**\n * @augments SIP\n */\nvar\n  T1 = 500,\n  T2 = 4000,\n  T4 = 5000;\nmodule.exports = function (timers) {\n  var exports = {\n    T1: T1,\n    T2: T2,\n    T4: T4,\n    TIMER_B: 64 * T1,\n    TIMER_D: 0  * T1,\n    TIMER_F: 64 * T1,\n    TIMER_H: 64 * T1,\n    TIMER_I: 0  * T1,\n    TIMER_J: 0  * T1,\n    TIMER_K: 0  * T4,\n    TIMER_L: 64 * T1,\n    TIMER_M: 64 * T1,\n    TIMER_N: 64 * T1,\n    PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1\n  };\n\n  ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']\n  .forEach(function (name) {\n    // can't just use timers[name].bind(timers) since it bypasses jasmine's\n    // clock-mocking\n    exports[name] = function () {\n      return timers[name].apply(timers, arguments);\n    };\n  });\n\n  return exports;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Timers.js\n ** module id = 10\n ** module chunks = 0\n **/","/**\n * @fileoverview Transport\n */\n\n/**\n * @augments SIP\n * @class Transport\n * @param {SIP.UA} ua\n * @param {Object} server ws_server Object\n */\nmodule.exports = function (SIP, window) {\nvar Transport,\n  C = {\n    // Transport status codes\n    STATUS_READY:        0,\n    STATUS_DISCONNECTED: 1,\n    STATUS_ERROR:        2\n  };\n\nTransport = function(ua, server) {\n\n  this.logger = ua.getLogger('sip.transport');\n  this.ua = ua;\n  this.ws = null;\n  this.server = server;\n  this.reconnection_attempts = 0;\n  this.closed = false;\n  this.connected = false;\n  this.reconnectTimer = null;\n  this.lastTransportError = {};\n\n  this.ua.transport = this;\n\n  // Connect\n  this.connect();\n};\n\nTransport.prototype = {\n  /**\n   * Send a message.\n   * @param {SIP.OutgoingRequest|String} msg\n   * @returns {Boolean}\n   */\n  send: function(msg) {\n    var message = msg.toString();\n\n    if(this.ws && this.ws.readyState === window.WebSocket.OPEN) {\n      if (this.ua.configuration.traceSip === true) {\n        this.logger.log('sending WebSocket message:\\n\\n' + message + '\\n');\n      }\n      this.ws.send(message);\n      return true;\n    } else {\n      this.logger.warn('unable to send message, WebSocket is not open');\n      return false;\n    }\n  },\n\n  /**\n  * Disconnect socket.\n  */\n  disconnect: function() {\n    if(this.ws) {\n      // Clear reconnectTimer\n      SIP.Timers.clearTimeout(this.reconnectTimer);\n\n      this.closed = true;\n      this.logger.log('closing WebSocket ' + this.server.ws_uri);\n      this.ws.close();\n    }\n\n    if (this.reconnectTimer !== null) {\n      SIP.Timers.clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n      this.ua.emit('disconnected', {\n        transport: this,\n        code: this.lastTransportError.code,\n        reason: this.lastTransportError.reason\n      });\n    }\n  },\n\n  /**\n  * Connect socket.\n  */\n  connect: function() {\n    var transport = this;\n\n    if(this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {\n      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');\n      return false;\n    }\n\n    if(this.ws) {\n      this.ws.close();\n    }\n\n    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);\n    this.ua.onTransportConnecting(this,\n      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);\n\n    try {\n      this.ws = new window.WebSocket(this.server.ws_uri, 'sip');\n    } catch(e) {\n      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);\n    }\n\n    this.ws.binaryType = 'arraybuffer';\n\n    this.ws.onopen = function() {\n      transport.onOpen();\n    };\n\n    this.ws.onclose = function(e) {\n      transport.onClose(e);\n    };\n\n    this.ws.onmessage = function(e) {\n      transport.onMessage(e);\n    };\n\n    this.ws.onerror = function(e) {\n      transport.onError(e);\n    };\n  },\n\n  // Transport Event Handlers\n\n  /**\n  * @event\n  * @param {event} e\n  */\n  onOpen: function() {\n    this.connected = true;\n\n    this.logger.log('WebSocket ' + this.server.ws_uri + ' connected');\n    // Clear reconnectTimer since we are not disconnected\n    if (this.reconnectTimer !== null) {\n      SIP.Timers.clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    // Reset reconnection_attempts\n    this.reconnection_attempts = 0;\n    // Disable closed\n    this.closed = false;\n    // Trigger onTransportConnected callback\n    this.ua.onTransportConnected(this);\n  },\n\n  /**\n  * @event\n  * @param {event} e\n  */\n  onClose: function(e) {\n    var connected_before = this.connected;\n\n    this.connected = false;\n    this.lastTransportError.code = e.code;\n    this.lastTransportError.reason = e.reason;\n    this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');\n\n    if(e.wasClean === false) {\n      this.logger.warn('WebSocket abrupt disconnection');\n    }\n    // Transport was connected\n    if(connected_before === true) {\n      this.ua.onTransportClosed(this);\n      // Check whether the user requested to close.\n      if(!this.closed) {\n        this.reConnect();\n      } else {\n        this.ua.emit('disconnected', {\n          transport: this,\n          code: this.lastTransportError.code,\n          reason: this.lastTransportError.reason\n        });\n      }\n    } else {\n      // This is the first connection attempt\n      //Network error\n      this.ua.onTransportError(this);\n    }\n  },\n\n  /**\n  * @event\n  * @param {event} e\n  */\n  onMessage: function(e) {\n    var message, transaction,\n      data = e.data;\n\n    // CRLF Keep Alive response from server. Ignore it.\n    if(data === '\\r\\n') {\n      if (this.ua.configuration.traceSip === true) {\n        this.logger.log('received WebSocket message with CRLF Keep Alive response');\n      }\n      return;\n    }\n\n    // WebSocket binary message.\n    else if (typeof data !== 'string') {\n      try {\n        data = String.fromCharCode.apply(null, new Uint8Array(data));\n      } catch(evt) {\n        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');\n        return;\n      }\n\n      if (this.ua.configuration.traceSip === true) {\n        this.logger.log('received WebSocket binary message:\\n\\n' + data + '\\n');\n      }\n    }\n\n    // WebSocket text message.\n    else {\n      if (this.ua.configuration.traceSip === true) {\n        this.logger.log('received WebSocket text message:\\n\\n' + data + '\\n');\n      }\n    }\n\n    message = SIP.Parser.parseMessage(data, this.ua);\n\n    if (!message) {\n      return;\n    }\n\n    if(this.ua.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {\n      return;\n    }\n\n    // Do some sanity check\n    if(SIP.sanityCheck(message, this.ua, this)) {\n      if(message instanceof SIP.IncomingRequest) {\n        message.transport = this;\n        this.ua.receiveRequest(message);\n      } else if(message instanceof SIP.IncomingResponse) {\n        /* Unike stated in 18.1.2, if a response does not match\n        * any transaction, it is discarded here and no passed to the core\n        * in order to be discarded there.\n        */\n        switch(message.method) {\n          case SIP.C.INVITE:\n            transaction = this.ua.transactions.ict[message.via_branch];\n            if(transaction) {\n              transaction.receiveResponse(message);\n            }\n            break;\n          case SIP.C.ACK:\n            // Just in case ;-)\n            break;\n          default:\n            transaction = this.ua.transactions.nict[message.via_branch];\n            if(transaction) {\n              transaction.receiveResponse(message);\n            }\n            break;\n        }\n      }\n    }\n  },\n\n  /**\n  * @event\n  * @param {event} e\n  */\n  onError: function(e) {\n    this.logger.warn('WebSocket connection error: ' + e);\n  },\n\n  /**\n  * Reconnection attempt logic.\n  * @private\n  */\n  reConnect: function() {\n    var transport = this;\n\n    this.reconnection_attempts += 1;\n\n    if(this.reconnection_attempts > this.ua.configuration.wsServerMaxReconnection) {\n      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);\n      this.ua.onTransportError(this);\n    } else {\n      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');\n\n      this.reconnectTimer = SIP.Timers.setTimeout(function() {\n        transport.connect();\n        transport.reconnectTimer = null;\n      }, this.ua.configuration.wsServerReconnectionTimeout * 1000);\n    }\n  }\n};\n\nTransport.C = C;\nSIP.Transport = Transport;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Transport.js\n ** module id = 11\n ** module chunks = 0\n **/","/**\n * @fileoverview SIP Message Parser\n */\n\n/**\n * Extract and parse every header of a SIP message.\n * @augments SIP\n * @namespace\n */\nmodule.exports = function (SIP) {\nvar Parser;\n\nfunction getHeader(data, headerStart) {\n  var\n    // 'start' position of the header.\n    start = headerStart,\n    // 'end' position of the header.\n    end = 0,\n    // 'partial end' position of the header.\n    partialEnd = 0;\n\n  //End of message.\n  if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n    return -2;\n  }\n\n  while(end === 0) {\n    // Partial End of Header.\n    partialEnd = data.indexOf('\\r\\n', start);\n\n    // 'indexOf' returns -1 if the value to be found never occurs.\n    if (partialEnd === -1) {\n      return partialEnd;\n    }\n\n    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n      // Not the end of the message. Continue from the next position.\n      start = partialEnd + 2;\n    } else {\n      end = partialEnd;\n    }\n  }\n\n  return end;\n}\n\nfunction parseHeader(message, data, headerStart, headerEnd) {\n  var header, idx, length, parsed,\n    hcolonIndex = data.indexOf(':', headerStart),\n    headerName = data.substring(headerStart, hcolonIndex).trim(),\n    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();\n\n  // If header-field is well-known, parse it.\n  switch(headerName.toLowerCase()) {\n    case 'via':\n    case 'v':\n      message.addHeader('via', headerValue);\n      if(message.getHeaders('via').length === 1) {\n        parsed = message.parseHeader('Via');\n        if(parsed) {\n          message.via = parsed;\n          message.via_branch = parsed.branch;\n        }\n      } else {\n        parsed = 0;\n      }\n      break;\n    case 'from':\n    case 'f':\n      message.setHeader('from', headerValue);\n      parsed = message.parseHeader('from');\n      if(parsed) {\n        message.from = parsed;\n        message.from_tag = parsed.getParam('tag');\n      }\n      break;\n    case 'to':\n    case 't':\n      message.setHeader('to', headerValue);\n      parsed = message.parseHeader('to');\n      if(parsed) {\n        message.to = parsed;\n        message.to_tag = parsed.getParam('tag');\n      }\n      break;\n    case 'record-route':\n      parsed = SIP.Grammar.parse(headerValue, 'Record_Route');\n\n      if (parsed === -1) {\n        parsed = undefined;\n        break;\n      }\n\n      length = parsed.length;\n      for (idx = 0; idx < length; idx++) {\n        header = parsed[idx];\n        message.addHeader('record-route', headerValue.substring(header.position, header.offset));\n        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n      }\n      break;\n    case 'call-id':\n    case 'i':\n      message.setHeader('call-id', headerValue);\n      parsed = message.parseHeader('call-id');\n      if(parsed) {\n        message.call_id = headerValue;\n      }\n      break;\n    case 'contact':\n    case 'm':\n      parsed = SIP.Grammar.parse(headerValue, 'Contact');\n\n      if (parsed === -1) {\n        parsed = undefined;\n        break;\n      }\n\n      length = parsed.length;\n      for (idx = 0; idx < length; idx++) {\n        header = parsed[idx];\n        message.addHeader('contact', headerValue.substring(header.position, header.offset));\n        message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;\n      }\n      break;\n    case 'content-length':\n    case 'l':\n      message.setHeader('content-length', headerValue);\n      parsed = message.parseHeader('content-length');\n      break;\n    case 'content-type':\n    case 'c':\n      message.setHeader('content-type', headerValue);\n      parsed = message.parseHeader('content-type');\n      break;\n    case 'cseq':\n      message.setHeader('cseq', headerValue);\n      parsed = message.parseHeader('cseq');\n      if(parsed) {\n        message.cseq = parsed.value;\n      }\n      if(message instanceof SIP.IncomingResponse) {\n        message.method = parsed.method;\n      }\n      break;\n    case 'max-forwards':\n      message.setHeader('max-forwards', headerValue);\n      parsed = message.parseHeader('max-forwards');\n      break;\n    case 'www-authenticate':\n      message.setHeader('www-authenticate', headerValue);\n      parsed = message.parseHeader('www-authenticate');\n      break;\n    case 'proxy-authenticate':\n      message.setHeader('proxy-authenticate', headerValue);\n      parsed = message.parseHeader('proxy-authenticate');\n      break;\n    case 'refer-to':\n    case 'r':\n      message.setHeader('refer-to', headerValue);\n      parsed = message.parseHeader('refer-to');\n      if (parsed) {\n        message.refer_to = parsed;\n      }\n      break;\n    default:\n      // Do not parse this header.\n      message.setHeader(headerName, headerValue);\n      parsed = 0;\n  }\n\n  if (parsed === undefined) {\n    return {\n      error: 'error parsing header \"'+ headerName +'\"'\n    };\n  } else {\n    return true;\n  }\n}\n\n/** Parse SIP Message\n * @function\n * @param {String} message SIP message.\n * @param {Object} logger object.\n * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}\n */\nParser = {};\nParser.parseMessage = function(data, ua) {\n  var message, firstLine, contentLength, bodyStart, parsed,\n    headerStart = 0,\n    headerEnd = data.indexOf('\\r\\n'),\n    logger = ua.getLogger('sip.parser');\n\n  if(headerEnd === -1) {\n    logger.warn('no CRLF found, not a SIP message, discarded');\n    return;\n  }\n\n  // Parse first line. Check if it is a Request or a Reply.\n  firstLine = data.substring(0, headerEnd);\n  parsed = SIP.Grammar.parse(firstLine, 'Request_Response');\n\n  if(parsed === -1) {\n    logger.warn('error parsing first line of SIP message: \"' + firstLine + '\"');\n    return;\n  } else if(!parsed.status_code) {\n    message = new SIP.IncomingRequest(ua);\n    message.method = parsed.method;\n    message.ruri = parsed.uri;\n  } else {\n    message = new SIP.IncomingResponse(ua);\n    message.status_code = parsed.status_code;\n    message.reason_phrase = parsed.reason_phrase;\n  }\n\n  message.data = data;\n  headerStart = headerEnd + 2;\n\n  /* Loop over every line in data. Detect the end of each header and parse\n  * it or simply add to the headers collection.\n  */\n  while(true) {\n    headerEnd = getHeader(data, headerStart);\n\n    // The SIP message has normally finished.\n    if(headerEnd === -2) {\n      bodyStart = headerStart + 2;\n      break;\n    }\n    // data.indexOf returned -1 due to a malformed message.\n    else if(headerEnd === -1) {\n      logger.error('malformed message');\n      return;\n    }\n\n    parsed = parseHeader(message, data, headerStart, headerEnd);\n\n    if(parsed !== true) {\n      logger.error(parsed.error);\n      return;\n    }\n\n    headerStart = headerEnd + 2;\n  }\n\n  /* RFC3261 18.3.\n   * If there are additional bytes in the transport packet\n   * beyond the end of the body, they MUST be discarded.\n   */\n  if(message.hasHeader('content-length')) {\n    contentLength = message.getHeader('content-length');\n    message.body = data.substr(bodyStart, contentLength);\n  } else {\n    message.body = data.substring(bodyStart);\n  }\n\n  return message;\n};\n\nSIP.Parser = Parser;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Parser.js\n ** module id = 12\n ** module chunks = 0\n **/","/**\n * @fileoverview SIP Message\n */\n\nmodule.exports = function (SIP) {\nvar\n  OutgoingRequest,\n  IncomingMessage,\n  IncomingRequest,\n  IncomingResponse;\n\n/**\n * @augments SIP\n * @class Class for outgoing SIP request.\n * @param {String} method request method\n * @param {String} ruri request uri\n * @param {SIP.UA} ua\n * @param {Object} params parameters that will have priority over ua.configuration parameters:\n * <br>\n *  - cseq, call_id, from_tag, from_uri, from_displayName, to_uri, to_tag, route_set\n * @param {Object} [headers] extra headers\n * @param {String} [body]\n */\nOutgoingRequest = function(method, ruri, ua, params, extraHeaders, body) {\n  var\n    to,\n    from,\n    call_id,\n    cseq;\n\n  params = params || {};\n\n  // Mandatory parameters check\n  if(!method || !ruri || !ua) {\n    return null;\n  }\n\n  this.logger = ua.getLogger('sip.sipmessage');\n  this.ua = ua;\n  this.headers = {};\n  this.method = method;\n  this.ruri = ruri;\n  this.body = body;\n  this.extraHeaders = (extraHeaders || []).slice();\n  this.statusCode = params.status_code;\n  this.reasonPhrase = params.reason_phrase;\n\n  // Fill the Common SIP Request Headers\n\n  // Route\n  if (params.route_set) {\n    this.setHeader('route', params.route_set);\n  } else if (ua.configuration.usePreloadedRoute){\n    this.setHeader('route', ua.transport.server.sip_uri);\n  }\n\n  // Via\n  // Empty Via header. Will be filled by the client transaction.\n  this.setHeader('via', '');\n\n  // Max-Forwards\n  this.setHeader('max-forwards', SIP.UA.C.MAX_FORWARDS);\n\n  // To\n  to = (params.to_displayName || params.to_displayName === 0) ? '\"' + params.to_displayName + '\" ' : '';\n  to += '<' + (params.to_uri || ruri) + '>';\n  to += params.to_tag ? ';tag=' + params.to_tag : '';\n  this.to = new SIP.NameAddrHeader.parse(to);\n  this.setHeader('to', to);\n\n  // From\n  if (params.from_displayName || params.from_displayName === 0) {\n    from = '\"' + params.from_displayName + '\" ';\n  } else if (ua.configuration.displayName) {\n    from = '\"' + ua.configuration.displayName + '\" ';\n  } else {\n    from = '';\n  }\n  from += '<' + (params.from_uri || ua.configuration.uri) + '>;tag=';\n  from += params.from_tag || SIP.Utils.newTag();\n  this.from = new SIP.NameAddrHeader.parse(from);\n  this.setHeader('from', from);\n\n  // Call-ID\n  call_id = params.call_id || (ua.configuration.sipjsId + SIP.Utils.createRandomToken(15));\n  this.call_id = call_id;\n  this.setHeader('call-id', call_id);\n\n  // CSeq\n  cseq = params.cseq || Math.floor(Math.random() * 10000);\n  this.cseq = cseq;\n  this.setHeader('cseq', cseq + ' ' + method);\n};\n\nOutgoingRequest.prototype = {\n  /**\n   * Replace the the given header by the given value.\n   * @param {String} name header name\n   * @param {String | Array} value header value\n   */\n  setHeader: function(name, value) {\n    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n  },\n\n  /**\n   * Get the value of the given header name at the given position.\n   * @param {String} name header name\n   * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.\n   */\n  getHeader: function(name) {\n    var regexp, idx,\n      length = this.extraHeaders.length,\n      header = this.headers[SIP.Utils.headerize(name)];\n\n    if(header) {\n      if(header[0]) {\n        return header[0];\n      }\n    } else {\n      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n      for (idx = 0; idx < length; idx++) {\n        header = this.extraHeaders[idx];\n        if (regexp.test(header)) {\n          return header.substring(header.indexOf(':')+1).trim();\n        }\n      }\n    }\n\n    return;\n  },\n\n  /**\n   * Get the header/s of the given name.\n   * @param {String} name header name\n   * @returns {Array} Array with all the headers of the specified name.\n   */\n  getHeaders: function(name) {\n    var idx, length, regexp,\n      header = this.headers[SIP.Utils.headerize(name)],\n      result = [];\n\n    if(header) {\n      length = header.length;\n      for (idx = 0; idx < length; idx++) {\n        result.push(header[idx]);\n      }\n      return result;\n    } else {\n      length = this.extraHeaders.length;\n      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n      for (idx = 0; idx < length; idx++) {\n        header = this.extraHeaders[idx];\n        if (regexp.test(header)) {\n          result.push(header.substring(header.indexOf(':')+1).trim());\n        }\n      }\n      return result;\n    }\n  },\n\n  /**\n   * Verify the existence of the given header.\n   * @param {String} name header name\n   * @returns {boolean} true if header with given name exists, false otherwise\n   */\n  hasHeader: function(name) {\n    var regexp, idx,\n      length = this.extraHeaders.length;\n\n    if (this.headers[SIP.Utils.headerize(name)]) {\n      return true;\n    } else {\n      regexp = new RegExp('^\\\\s*' + name + '\\\\s*:','i');\n      for (idx = 0; idx < length; idx++) {\n        if (regexp.test(this.extraHeaders[idx])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  },\n\n  toString: function() {\n    var msg = '', header, length, idx, supported = [];\n\n    msg += this.method + ' ' + this.ruri + ' SIP/2.0\\r\\n';\n\n    for (header in this.headers) {\n      length = this.headers[header].length;\n      for (idx = 0; idx < length; idx++) {\n        msg += header + ': ' + this.headers[header][idx] + '\\r\\n';\n      }\n    }\n\n    length = this.extraHeaders.length;\n    for (idx = 0; idx < length; idx++) {\n      msg += this.extraHeaders[idx].trim() +'\\r\\n';\n    }\n\n    //Supported\n    if (this.method === SIP.C.REGISTER) {\n      supported.push('path', 'gruu');\n    } else if (this.method === SIP.C.INVITE &&\n               (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu)) {\n      supported.push('gruu');\n    }\n\n    if (this.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {\n      supported.push('100rel');\n    }\n\n    supported.push('outbound');\n\n    msg += 'Supported: ' +  supported +'\\r\\n';\n    msg += 'User-Agent: ' + this.ua.configuration.userAgentString +'\\r\\n';\n\n    if(this.body) {\n      length = SIP.Utils.str_utf8_length(this.body);\n      msg += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n      msg += this.body;\n    } else {\n      msg += 'Content-Length: 0\\r\\n\\r\\n';\n    }\n\n    return msg;\n  }\n};\n\n/**\n * @augments SIP\n * @class Class for incoming SIP message.\n */\nIncomingMessage = function(){\n  this.data = null;\n  this.headers = null;\n  this.method =  null;\n  this.via = null;\n  this.via_branch = null;\n  this.call_id = null;\n  this.cseq = null;\n  this.from = null;\n  this.from_tag = null;\n  this.to = null;\n  this.to_tag = null;\n  this.body = null;\n};\n\nIncomingMessage.prototype = {\n  /**\n  * Insert a header of the given name and value into the last position of the\n  * header array.\n  * @param {String} name header name\n  * @param {String} value header value\n  */\n  addHeader: function(name, value) {\n    var header = { raw: value };\n\n    name = SIP.Utils.headerize(name);\n\n    if(this.headers[name]) {\n      this.headers[name].push(header);\n    } else {\n      this.headers[name] = [header];\n    }\n  },\n\n  /**\n   * Get the value of the given header name at the given position.\n   * @param {String} name header name\n   * @returns {String|undefined} Returns the specified header, null if header doesn't exist.\n   */\n  getHeader: function(name) {\n    var header = this.headers[SIP.Utils.headerize(name)];\n\n    if(header) {\n      if(header[0]) {\n        return header[0].raw;\n      }\n    } else {\n      return;\n    }\n  },\n\n  /**\n   * Get the header/s of the given name.\n   * @param {String} name header name\n   * @returns {Array} Array with all the headers of the specified name.\n   */\n  getHeaders: function(name) {\n    var idx, length,\n      header = this.headers[SIP.Utils.headerize(name)],\n      result = [];\n\n    if(!header) {\n      return [];\n    }\n\n    length = header.length;\n    for (idx = 0; idx < length; idx++) {\n      result.push(header[idx].raw);\n    }\n\n    return result;\n  },\n\n  /**\n   * Verify the existence of the given header.\n   * @param {String} name header name\n   * @returns {boolean} true if header with given name exists, false otherwise\n   */\n  hasHeader: function(name) {\n    return(this.headers[SIP.Utils.headerize(name)]) ? true : false;\n  },\n\n  /**\n  * Parse the given header on the given index.\n  * @param {String} name header name\n  * @param {Number} [idx=0] header index\n  * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n  */\n  parseHeader: function(name, idx) {\n    var header, value, parsed;\n\n    name = SIP.Utils.headerize(name);\n\n    idx = idx || 0;\n\n    if(!this.headers[name]) {\n      this.logger.log('header \"' + name + '\" not present');\n      return;\n    } else if(idx >= this.headers[name].length) {\n      this.logger.log('not so many \"' + name + '\" headers present');\n      return;\n    }\n\n    header = this.headers[name][idx];\n    value = header.raw;\n\n    if(header.parsed) {\n      return header.parsed;\n    }\n\n    //substitute '-' by '_' for grammar rule matching.\n    parsed = SIP.Grammar.parse(value, name.replace(/-/g, '_'));\n\n    if(parsed === -1) {\n      this.headers[name].splice(idx, 1); //delete from headers\n      this.logger.warn('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n      return;\n    } else {\n      header.parsed = parsed;\n      return parsed;\n    }\n  },\n\n  /**\n   * Message Header attribute selector. Alias of parseHeader.\n   * @param {String} name header name\n   * @param {Number} [idx=0] header index\n   * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n   *\n   * @example\n   * message.s('via',3).port\n   */\n  s: function(name, idx) {\n    return this.parseHeader(name, idx);\n  },\n\n  /**\n  * Replace the value of the given header by the value.\n  * @param {String} name header name\n  * @param {String} value header value\n  */\n  setHeader: function(name, value) {\n    var header = { raw: value };\n    this.headers[SIP.Utils.headerize(name)] = [header];\n  },\n\n  toString: function() {\n    return this.data;\n  }\n};\n\n/**\n * @augments IncomingMessage\n * @class Class for incoming SIP request.\n */\nIncomingRequest = function(ua) {\n  this.logger = ua.getLogger('sip.sipmessage');\n  this.ua = ua;\n  this.headers = {};\n  this.ruri = null;\n  this.transport = null;\n  this.server_transaction = null;\n};\nIncomingRequest.prototype = new IncomingMessage();\n\n/**\n* Stateful reply.\n* @param {Number} code status code\n* @param {String} reason reason phrase\n* @param {Object} headers extra headers\n* @param {String} body body\n* @param {Function} [onSuccess] onSuccess callback\n* @param {Function} [onFailure] onFailure callback\n*/\nIncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {\n  var rr, vias, length, idx, response,\n  supported = [],\n    to = this.getHeader('To'),\n    r = 0,\n    v = 0;\n\n  code = code || null;\n  reason = reason || null;\n\n  // Validate code and reason values\n  if (!code || (code < 100 || code > 699)) {\n    throw new TypeError('Invalid status_code: '+ code);\n  } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n    throw new TypeError('Invalid reason_phrase: '+ reason);\n  }\n\n  reason = reason || SIP.C.REASON_PHRASE[code] || '';\n  extraHeaders = (extraHeaders || []).slice();\n\n  response = 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n\n  if(this.method === SIP.C.INVITE && code > 100 && code <= 200) {\n    rr = this.getHeaders('record-route');\n    length = rr.length;\n\n    for(r; r < length; r++) {\n      response += 'Record-Route: ' + rr[r] + '\\r\\n';\n    }\n  }\n\n  vias = this.getHeaders('via');\n  length = vias.length;\n\n  for(v; v < length; v++) {\n    response += 'Via: ' + vias[v] + '\\r\\n';\n  }\n\n  if(!this.to_tag && code > 100) {\n    to += ';tag=' + SIP.Utils.newTag();\n  } else if(this.to_tag && !this.s('to').hasParam('tag')) {\n    to += ';tag=' + this.to_tag;\n  }\n\n  response += 'To: ' + to + '\\r\\n';\n  response += 'From: ' + this.getHeader('From') + '\\r\\n';\n  response += 'Call-ID: ' + this.call_id + '\\r\\n';\n  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n\n  length = extraHeaders.length;\n  for (idx = 0; idx < length; idx++) {\n    response += extraHeaders[idx].trim() +'\\r\\n';\n  }\n\n  //Supported\n  if (this.method === SIP.C.INVITE &&\n               (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu)) {\n    supported.push('gruu');\n  }\n\n  if (this.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {\n    supported.push('100rel');\n  }\n\n  supported.push('outbound');\n\n  response += 'Supported: ' + supported + '\\r\\n';\n\n  if(body) {\n    length = SIP.Utils.str_utf8_length(body);\n    response += 'Content-Type: application/sdp\\r\\n';\n    response += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n    response += body;\n  } else {\n    response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n  }\n\n  this.server_transaction.receiveResponse(code, response, onSuccess, onFailure);\n\n  return response;\n};\n\n/**\n* Stateless reply.\n* @param {Number} code status code\n* @param {String} reason reason phrase\n*/\nIncomingRequest.prototype.reply_sl = function(code, reason) {\n  var to, response,\n    v = 0,\n    vias = this.getHeaders('via'),\n    length = vias.length;\n\n  code = code || null;\n  reason = reason || null;\n\n  // Validate code and reason values\n  if (!code || (code < 100 || code > 699)) {\n    throw new TypeError('Invalid status_code: '+ code);\n  } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n    throw new TypeError('Invalid reason_phrase: '+ reason);\n  }\n\n  reason = reason || SIP.C.REASON_PHRASE[code] || '';\n\n  response = 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n\n  for(v; v < length; v++) {\n    response += 'Via: ' + vias[v] + '\\r\\n';\n  }\n\n  to = this.getHeader('To');\n\n  if(!this.to_tag && code > 100) {\n    to += ';tag=' + SIP.Utils.newTag();\n  } else if(this.to_tag && !this.s('to').hasParam('tag')) {\n    to += ';tag=' + this.to_tag;\n  }\n\n  response += 'To: ' + to + '\\r\\n';\n  response += 'From: ' + this.getHeader('From') + '\\r\\n';\n  response += 'Call-ID: ' + this.call_id + '\\r\\n';\n  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n  response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n\n  this.transport.send(response);\n};\n\n\n/**\n * @augments IncomingMessage\n * @class Class for incoming SIP response.\n */\nIncomingResponse = function(ua) {\n  this.logger = ua.getLogger('sip.sipmessage');\n  this.headers = {};\n  this.status_code = null;\n  this.reason_phrase = null;\n};\nIncomingResponse.prototype = new IncomingMessage();\n\nSIP.OutgoingRequest = OutgoingRequest;\nSIP.IncomingRequest = IncomingRequest;\nSIP.IncomingResponse = IncomingResponse;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/SIPMessage.js\n ** module id = 13\n ** module chunks = 0\n **/","/**\n * @fileoverview SIP URI\n */\n\n/**\n * @augments SIP\n * @class Class creating a SIP URI.\n *\n * @param {String} [scheme]\n * @param {String} [user]\n * @param {String} host\n * @param {String} [port]\n * @param {Object} [parameters]\n * @param {Object} [headers]\n *\n */\nmodule.exports = function (SIP) {\nvar URI;\n\nURI = function(scheme, user, host, port, parameters, headers) {\n  var param, header;\n\n  // Checks\n  if(!host) {\n    throw new TypeError('missing or invalid \"host\" parameter');\n  }\n\n  // Initialize parameters\n  scheme = scheme || SIP.C.SIP;\n  this.parameters = {};\n  this.headers = {};\n\n  for (param in parameters) {\n    this.setParam(param, parameters[param]);\n  }\n\n  for (header in headers) {\n    this.setHeader(header, headers[header]);\n  }\n\n  Object.defineProperties(this, {\n    scheme: {\n      get: function(){ return scheme; },\n      set: function(value){\n        scheme = value.toLowerCase();\n      }\n    },\n\n    user: {\n      get: function(){ return user; },\n      set: function(value){\n        user = value;\n      }\n    },\n\n    host: {\n      get: function(){ return host; },\n      set: function(value){\n        host = value.toLowerCase();\n      }\n    },\n\n    port: {\n      get: function(){ return port; },\n      set: function(value){\n        port = value === 0 ? value : (parseInt(value,10) || null);\n      }\n    }\n  });\n};\nURI.prototype = {\n  setParam: function(key, value) {\n    if(key) {\n      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();\n    }\n  },\n\n  getParam: function(key) {\n    if(key) {\n      return this.parameters[key.toLowerCase()];\n    }\n  },\n\n  hasParam: function(key) {\n    if(key) {\n      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;\n    }\n  },\n\n  deleteParam: function(parameter) {\n    var value;\n    parameter = parameter.toLowerCase();\n    if (this.parameters.hasOwnProperty(parameter)) {\n      value = this.parameters[parameter];\n      delete this.parameters[parameter];\n      return value;\n    }\n  },\n\n  clearParams: function() {\n    this.parameters = {};\n  },\n\n  setHeader: function(name, value) {\n    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n  },\n\n  getHeader: function(name) {\n    if(name) {\n      return this.headers[SIP.Utils.headerize(name)];\n    }\n  },\n\n  hasHeader: function(name) {\n    if(name) {\n      return (this.headers.hasOwnProperty(SIP.Utils.headerize(name)) && true) || false;\n    }\n  },\n\n  deleteHeader: function(header) {\n    var value;\n    header = SIP.Utils.headerize(header);\n    if(this.headers.hasOwnProperty(header)) {\n      value = this.headers[header];\n      delete this.headers[header];\n      return value;\n    }\n  },\n\n  clearHeaders: function() {\n    this.headers = {};\n  },\n\n  clone: function() {\n    return new URI(\n      this.scheme,\n      this.user,\n      this.host,\n      this.port,\n      JSON.parse(JSON.stringify(this.parameters)),\n      JSON.parse(JSON.stringify(this.headers)));\n  },\n\n  toString: function(){\n    var header, parameter, idx, uri,\n      headers = [];\n\n    uri  = this.scheme + ':';\n    // add slashes if it's not a sip(s) URI\n    if (!this.scheme.match(\"^sips?$\")) {\n      uri += \"//\";\n    }\n    if (this.user) {\n      uri += SIP.Utils.escapeUser(this.user) + '@';\n    }\n    uri += this.host;\n    if (this.port || this.port === 0) {\n      uri += ':' + this.port;\n    }\n\n    for (parameter in this.parameters) {\n      uri += ';' + parameter;\n\n      if (this.parameters[parameter] !== null) {\n        uri += '='+ this.parameters[parameter];\n      }\n    }\n\n    for(header in this.headers) {\n      for(idx in this.headers[header]) {\n        headers.push(header + '=' + this.headers[header][idx]);\n      }\n    }\n\n    if (headers.length > 0) {\n      uri += '?' + headers.join('&');\n    }\n\n    return uri;\n  }\n};\n\n\n/**\n  * Parse the given string and returns a SIP.URI instance or undefined if\n  * it is an invalid URI.\n  * @public\n  * @param {String} uri\n  */\nURI.parse = function(uri) {\n  uri = SIP.Grammar.parse(uri,'SIP_URI');\n\n  if (uri !== -1) {\n    return uri;\n  } else {\n    return undefined;\n  }\n};\n\nSIP.URI = URI;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/URI.js\n ** module id = 14\n ** module chunks = 0\n **/","/**\n * @fileoverview SIP NameAddrHeader\n */\n\n/**\n * @augments SIP\n * @class Class creating a Name Address SIP header.\n *\n * @param {SIP.URI} uri\n * @param {String} [displayName]\n * @param {Object} [parameters]\n *\n */\nmodule.exports = function (SIP) {\nvar NameAddrHeader;\n\nNameAddrHeader = function(uri, displayName, parameters) {\n  var param;\n\n  // Checks\n  if(!uri || !(uri instanceof SIP.URI)) {\n    throw new TypeError('missing or invalid \"uri\" parameter');\n  }\n\n  // Initialize parameters\n  this.uri = uri;\n  this.parameters = {};\n\n  for (param in parameters) {\n    this.setParam(param, parameters[param]);\n  }\n\n  Object.defineProperties(this, {\n    displayName: {\n      get: function() { return displayName; },\n      set: function(value) {\n        displayName = (value === 0) ? '0' : value;\n      }\n    }\n  });\n};\nNameAddrHeader.prototype = {\n  setParam: function (key, value) {\n    if(key) {\n      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();\n    }\n  },\n  getParam: SIP.URI.prototype.getParam,\n  hasParam: SIP.URI.prototype.hasParam,\n  deleteParam: SIP.URI.prototype.deleteParam,\n  clearParams: SIP.URI.prototype.clearParams,\n\n  clone: function() {\n    return new NameAddrHeader(\n      this.uri.clone(),\n      this.displayName,\n      JSON.parse(JSON.stringify(this.parameters)));\n  },\n\n  toString: function() {\n    var body, parameter;\n\n    body  = (this.displayName || this.displayName === 0) ? '\"' + this.displayName + '\" ' : '';\n    body += '<' + this.uri.toString() + '>';\n\n    for (parameter in this.parameters) {\n      body += ';' + parameter;\n\n      if (this.parameters[parameter] !== null) {\n        body += '='+ this.parameters[parameter];\n      }\n    }\n\n    return body;\n  }\n};\n\n\n/**\n  * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if\n  * it is an invalid NameAddrHeader.\n  * @public\n  * @param {String} name_addr_header\n  */\nNameAddrHeader.parse = function(name_addr_header) {\n  name_addr_header = SIP.Grammar.parse(name_addr_header,'Name_Addr_Header');\n\n  if (name_addr_header !== -1) {\n    return name_addr_header;\n  } else {\n    return undefined;\n  }\n};\n\nSIP.NameAddrHeader = NameAddrHeader;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/NameAddrHeader.js\n ** module id = 15\n ** module chunks = 0\n **/","/**\n * @fileoverview SIP Transactions\n */\n\n/**\n * SIP Transactions module.\n * @augments SIP\n */\nmodule.exports = function (SIP) {\nvar\n  C = {\n    // Transaction states\n    STATUS_TRYING:     1,\n    STATUS_PROCEEDING: 2,\n    STATUS_CALLING:    3,\n    STATUS_ACCEPTED:   4,\n    STATUS_COMPLETED:  5,\n    STATUS_TERMINATED: 6,\n    STATUS_CONFIRMED:  7,\n\n    // Transaction types\n    NON_INVITE_CLIENT: 'nict',\n    NON_INVITE_SERVER: 'nist',\n    INVITE_CLIENT: 'ict',\n    INVITE_SERVER: 'ist'\n  };\n\n/**\n* @augments SIP.Transactions\n* @class Non Invite Client Transaction\n* @param {SIP.RequestSender} request_sender\n* @param {SIP.OutgoingRequest} request\n* @param {SIP.Transport} transport\n*/\nvar NonInviteClientTransaction = function(request_sender, request, transport) {\n  var via,\n    events = ['stateChanged'];\n\n  this.type = C.NON_INVITE_CLIENT;\n  this.transport = transport;\n  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n  this.request_sender = request_sender;\n  this.request = request;\n\n  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n\n  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);\n  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + this.id;\n\n  this.request.setHeader('via', via);\n\n  this.request_sender.ua.newTransaction(this);\n\n  this.initEvents(events);\n};\nNonInviteClientTransaction.prototype = new SIP.EventEmitter();\n\nNonInviteClientTransaction.prototype.stateChanged = function(state) {\n  this.state = state;\n  this.emit('stateChanged');\n};\n\nNonInviteClientTransaction.prototype.send = function() {\n  var tr = this;\n\n  this.stateChanged(C.STATUS_TRYING);\n  this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);\n\n  if(!this.transport.send(this.request)) {\n    this.onTransportError();\n  }\n};\n\nNonInviteClientTransaction.prototype.onTransportError = function() {\n  this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);\n  SIP.Timers.clearTimeout(this.F);\n  SIP.Timers.clearTimeout(this.K);\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.request_sender.ua.destroyTransaction(this);\n  this.request_sender.onTransportError();\n};\n\nNonInviteClientTransaction.prototype.timer_F = function() {\n  this.logger.log('Timer F expired for non-INVITE client transaction ' + this.id);\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.request_sender.ua.destroyTransaction(this);\n  this.request_sender.onRequestTimeout();\n};\n\nNonInviteClientTransaction.prototype.timer_K = function() {\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.request_sender.ua.destroyTransaction(this);\n};\n\nNonInviteClientTransaction.prototype.receiveResponse = function(response) {\n  var\n    tr = this,\n    status_code = response.status_code;\n\n  if(status_code < 200) {\n    switch(this.state) {\n      case C.STATUS_TRYING:\n      case C.STATUS_PROCEEDING:\n        this.stateChanged(C.STATUS_PROCEEDING);\n        this.request_sender.receiveResponse(response);\n        break;\n    }\n  } else {\n    switch(this.state) {\n      case C.STATUS_TRYING:\n      case C.STATUS_PROCEEDING:\n        this.stateChanged(C.STATUS_COMPLETED);\n        SIP.Timers.clearTimeout(this.F);\n\n        if(status_code === 408) {\n          this.request_sender.onRequestTimeout();\n        } else {\n          this.request_sender.receiveResponse(response);\n        }\n\n        this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);\n        break;\n      case C.STATUS_COMPLETED:\n        break;\n    }\n  }\n};\n\n\n\n/**\n* @augments SIP.Transactions\n* @class Invite Client Transaction\n* @param {SIP.RequestSender} request_sender\n* @param {SIP.OutgoingRequest} request\n* @param {SIP.Transport} transport\n*/\nvar InviteClientTransaction = function(request_sender, request, transport) {\n  var via,\n    tr = this,\n    events = ['stateChanged'];\n\n  this.type = C.INVITE_CLIENT;\n  this.transport = transport;\n  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n  this.request_sender = request_sender;\n  this.request = request;\n\n  this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);\n\n  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);\n  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + this.id;\n\n  this.request.setHeader('via', via);\n\n  this.request_sender.ua.newTransaction(this);\n\n  // Add the cancel property to the request.\n  //Will be called from the request instance, not the transaction itself.\n  this.request.cancel = function(reason) {\n    tr.cancel_request(tr, reason);\n  };\n\n  this.initEvents(events);\n};\nInviteClientTransaction.prototype = new SIP.EventEmitter();\n\nInviteClientTransaction.prototype.stateChanged = function(state) {\n  this.state = state;\n  this.emit('stateChanged');\n};\n\nInviteClientTransaction.prototype.send = function() {\n  var tr = this;\n  this.stateChanged(C.STATUS_CALLING);\n  this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);\n\n  if(!this.transport.send(this.request)) {\n    this.onTransportError();\n  }\n};\n\nInviteClientTransaction.prototype.onTransportError = function() {\n  this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);\n  SIP.Timers.clearTimeout(this.B);\n  SIP.Timers.clearTimeout(this.D);\n  SIP.Timers.clearTimeout(this.M);\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.request_sender.ua.destroyTransaction(this);\n\n  if (this.state !== C.STATUS_ACCEPTED) {\n    this.request_sender.onTransportError();\n  }\n};\n\n// RFC 6026 7.2\nInviteClientTransaction.prototype.timer_M = function() {\n  this.logger.log('Timer M expired for INVITE client transaction ' + this.id);\n\n  if(this.state === C.STATUS_ACCEPTED) {\n    SIP.Timers.clearTimeout(this.B);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.request_sender.ua.destroyTransaction(this);\n  }\n};\n\n// RFC 3261 17.1.1\nInviteClientTransaction.prototype.timer_B = function() {\n  this.logger.log('Timer B expired for INVITE client transaction ' + this.id);\n  if(this.state === C.STATUS_CALLING) {\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.request_sender.ua.destroyTransaction(this);\n    this.request_sender.onRequestTimeout();\n  }\n};\n\nInviteClientTransaction.prototype.timer_D = function() {\n  this.logger.log('Timer D expired for INVITE client transaction ' + this.id);\n  SIP.Timers.clearTimeout(this.B);\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.request_sender.ua.destroyTransaction(this);\n};\n\nInviteClientTransaction.prototype.sendACK = function(response) {\n  var tr = this;\n\n  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\\r\\n';\n  this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\\r\\n';\n\n  if(this.request.headers['Route']) {\n    this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\\r\\n';\n  }\n\n  this.ack += 'To: ' + response.getHeader('to') + '\\r\\n';\n  this.ack += 'From: ' + this.request.headers['From'].toString() + '\\r\\n';\n  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\\r\\n';\n  this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];\n  this.ack += ' ACK\\r\\n\\r\\n';\n\n  this.D = SIP.Timers.setTimeout(tr.timer_D.bind(tr), SIP.Timers.TIMER_D);\n\n  this.transport.send(this.ack);\n};\n\nInviteClientTransaction.prototype.cancel_request = function(tr, reason) {\n  var request = tr.request;\n\n  this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\\r\\n';\n  this.cancel += 'Via: ' + request.headers['Via'].toString() + '\\r\\n';\n\n  if(this.request.headers['Route']) {\n    this.cancel += 'Route: ' + request.headers['Route'].toString() + '\\r\\n';\n  }\n\n  this.cancel += 'To: ' + request.headers['To'].toString() + '\\r\\n';\n  this.cancel += 'From: ' + request.headers['From'].toString() + '\\r\\n';\n  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\\r\\n';\n  this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +\n  ' CANCEL\\r\\n';\n\n  if(reason) {\n    this.cancel += 'Reason: ' + reason + '\\r\\n';\n  }\n\n  this.cancel += 'Content-Length: 0\\r\\n\\r\\n';\n\n  // Send only if a provisional response (>100) has been received.\n  if(this.state === C.STATUS_PROCEEDING) {\n    this.transport.send(this.cancel);\n  }\n};\n\nInviteClientTransaction.prototype.receiveResponse = function(response) {\n  var\n  tr = this,\n  status_code = response.status_code;\n\n  if(status_code >= 100 && status_code <= 199) {\n    switch(this.state) {\n      case C.STATUS_CALLING:\n        this.stateChanged(C.STATUS_PROCEEDING);\n        this.request_sender.receiveResponse(response);\n        if(this.cancel) {\n          this.transport.send(this.cancel);\n        }\n        break;\n      case C.STATUS_PROCEEDING:\n        this.request_sender.receiveResponse(response);\n        break;\n    }\n  } else if(status_code >= 200 && status_code <= 299) {\n    switch(this.state) {\n      case C.STATUS_CALLING:\n      case C.STATUS_PROCEEDING:\n        this.stateChanged(C.STATUS_ACCEPTED);\n        this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);\n        this.request_sender.receiveResponse(response);\n        break;\n      case C.STATUS_ACCEPTED:\n        this.request_sender.receiveResponse(response);\n        break;\n    }\n  } else if(status_code >= 300 && status_code <= 699) {\n    switch(this.state) {\n      case C.STATUS_CALLING:\n      case C.STATUS_PROCEEDING:\n        this.stateChanged(C.STATUS_COMPLETED);\n        this.sendACK(response);\n        this.request_sender.receiveResponse(response);\n        break;\n      case C.STATUS_COMPLETED:\n        this.sendACK(response);\n        break;\n    }\n  }\n};\n\n\n/**\n * @augments SIP.Transactions\n * @class ACK Client Transaction\n * @param {SIP.RequestSender} request_sender\n * @param {SIP.OutgoingRequest} request\n * @param {SIP.Transport} transport\n */\nvar AckClientTransaction = function(request_sender, request, transport) {\n  var via;\n\n  this.transport = transport;\n  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n  this.request_sender = request_sender;\n  this.request = request;\n\n  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n\n  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);\n  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + this.id;\n\n  this.request.setHeader('via', via);\n};\nAckClientTransaction.prototype = new SIP.EventEmitter();\n\nAckClientTransaction.prototype.send = function() {\n  if(!this.transport.send(this.request)) {\n    this.onTransportError();\n  }\n};\n\nAckClientTransaction.prototype.onTransportError = function() {\n  this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);\n  this.request_sender.onTransportError();\n};\n\n\n/**\n* @augments SIP.Transactions\n* @class Non Invite Server Transaction\n* @param {SIP.IncomingRequest} request\n* @param {SIP.UA} ua\n*/\nvar NonInviteServerTransaction = function(request, ua) {\n  var events = ['stateChanged'];\n\n  this.type = C.NON_INVITE_SERVER;\n  this.id = request.via_branch;\n  this.request = request;\n  this.transport = request.transport;\n  this.ua = ua;\n  this.last_response = '';\n  request.server_transaction = this;\n\n  this.logger = ua.getLogger('sip.transaction.nist', this.id);\n\n  this.state = C.STATUS_TRYING;\n\n  ua.newTransaction(this);\n\n  this.initEvents(events);\n};\nNonInviteServerTransaction.prototype = new SIP.EventEmitter();\n\nNonInviteServerTransaction.prototype.stateChanged = function(state) {\n  this.state = state;\n  this.emit('stateChanged');\n};\n\nNonInviteServerTransaction.prototype.timer_J = function() {\n  this.logger.log('Timer J expired for non-INVITE server transaction ' + this.id);\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.ua.destroyTransaction(this);\n};\n\nNonInviteServerTransaction.prototype.onTransportError = function() {\n  if (!this.transportError) {\n    this.transportError = true;\n\n    this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);\n\n    SIP.Timers.clearTimeout(this.J);\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n};\n\nNonInviteServerTransaction.prototype.receiveResponse = function(status_code, response, onSuccess, onFailure) {\n  var tr = this;\n\n  if(status_code === 100) {\n    /* RFC 4320 4.1\n     * 'A SIP element MUST NOT\n     * send any provisional response with a\n     * Status-Code other than 100 to a non-INVITE request.'\n     */\n    switch(this.state) {\n      case C.STATUS_TRYING:\n        this.stateChanged(C.STATUS_PROCEEDING);\n        if(!this.transport.send(response))  {\n          this.onTransportError();\n        }\n        break;\n      case C.STATUS_PROCEEDING:\n        this.last_response = response;\n        if(!this.transport.send(response)) {\n          this.onTransportError();\n          if (onFailure) {\n            onFailure();\n          }\n        } else if (onSuccess) {\n          onSuccess();\n        }\n        break;\n    }\n  } else if(status_code >= 200 && status_code <= 699) {\n    switch(this.state) {\n      case C.STATUS_TRYING:\n      case C.STATUS_PROCEEDING:\n        this.stateChanged(C.STATUS_COMPLETED);\n        this.last_response = response;\n        this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);\n        if(!this.transport.send(response)) {\n          this.onTransportError();\n          if (onFailure) {\n            onFailure();\n          }\n        } else if (onSuccess) {\n          onSuccess();\n        }\n        break;\n      case C.STATUS_COMPLETED:\n        break;\n    }\n  }\n};\n\n/**\n* @augments SIP.Transactions\n* @class Invite Server Transaction\n* @param {SIP.IncomingRequest} request\n* @param {SIP.UA} ua\n*/\nvar InviteServerTransaction = function(request, ua) {\n  var events = ['stateChanged'];\n\n  this.type = C.INVITE_SERVER;\n  this.id = request.via_branch;\n  this.request = request;\n  this.transport = request.transport;\n  this.ua = ua;\n  this.last_response = '';\n  request.server_transaction = this;\n\n  this.logger = ua.getLogger('sip.transaction.ist', this.id);\n\n  this.state = C.STATUS_PROCEEDING;\n\n  ua.newTransaction(this);\n\n  this.resendProvisionalTimer = null;\n\n  request.reply(100);\n\n  this.initEvents(events);\n};\nInviteServerTransaction.prototype = new SIP.EventEmitter();\n\nInviteServerTransaction.prototype.stateChanged = function(state) {\n  this.state = state;\n  this.emit('stateChanged');\n};\n\nInviteServerTransaction.prototype.timer_H = function() {\n  this.logger.log('Timer H expired for INVITE server transaction ' + this.id);\n\n  if(this.state === C.STATUS_COMPLETED) {\n    this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');\n  }\n\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.ua.destroyTransaction(this);\n};\n\nInviteServerTransaction.prototype.timer_I = function() {\n  this.stateChanged(C.STATUS_TERMINATED);\n  this.ua.destroyTransaction(this);\n};\n\n// RFC 6026 7.1\nInviteServerTransaction.prototype.timer_L = function() {\n  this.logger.log('Timer L expired for INVITE server transaction ' + this.id);\n\n  if(this.state === C.STATUS_ACCEPTED) {\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n};\n\nInviteServerTransaction.prototype.onTransportError = function() {\n  if (!this.transportError) {\n    this.transportError = true;\n\n    this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);\n\n    if (this.resendProvisionalTimer !== null) {\n      SIP.Timers.clearInterval(this.resendProvisionalTimer);\n      this.resendProvisionalTimer = null;\n    }\n\n    SIP.Timers.clearTimeout(this.L);\n    SIP.Timers.clearTimeout(this.H);\n    SIP.Timers.clearTimeout(this.I);\n\n    this.stateChanged(C.STATUS_TERMINATED);\n    this.ua.destroyTransaction(this);\n  }\n};\n\nInviteServerTransaction.prototype.resend_provisional = function() {\n  if(!this.transport.send(this.last_response)) {\n    this.onTransportError();\n  }\n};\n\n// INVITE Server Transaction RFC 3261 17.2.1\nInviteServerTransaction.prototype.receiveResponse = function(status_code, response, onSuccess, onFailure) {\n  var tr = this;\n\n  if(status_code >= 100 && status_code <= 199) {\n    switch(this.state) {\n      case C.STATUS_PROCEEDING:\n        if(!this.transport.send(response)) {\n          this.onTransportError();\n        }\n        this.last_response = response;\n        break;\n    }\n  }\n\n  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {\n    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.\n    if(this.resendProvisionalTimer === null) {\n      this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr),\n        SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);\n    }\n  } else if(status_code >= 200 && status_code <= 299) {\n    switch(this.state) {\n      case C.STATUS_PROCEEDING:\n        this.stateChanged(C.STATUS_ACCEPTED);\n        this.last_response = response;\n        this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);\n\n        if (this.resendProvisionalTimer !== null) {\n          SIP.Timers.clearInterval(this.resendProvisionalTimer);\n          this.resendProvisionalTimer = null;\n        }\n        /* falls through */\n        case C.STATUS_ACCEPTED:\n          // Note that this point will be reached for proceeding tr.state also.\n          if(!this.transport.send(response)) {\n            this.onTransportError();\n            if (onFailure) {\n              onFailure();\n            }\n          } else if (onSuccess) {\n            onSuccess();\n          }\n          break;\n    }\n  } else if(status_code >= 300 && status_code <= 699) {\n    switch(this.state) {\n      case C.STATUS_PROCEEDING:\n        if (this.resendProvisionalTimer !== null) {\n          SIP.Timers.clearInterval(this.resendProvisionalTimer);\n          this.resendProvisionalTimer = null;\n        }\n\n        if(!this.transport.send(response)) {\n          this.onTransportError();\n          if (onFailure) {\n            onFailure();\n          }\n        } else {\n          this.stateChanged(C.STATUS_COMPLETED);\n          this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);\n          if (onSuccess) {\n            onSuccess();\n          }\n        }\n        break;\n    }\n  }\n};\n\n/**\n * @function\n * @param {SIP.UA} ua\n * @param {SIP.IncomingRequest} request\n *\n * @return {boolean}\n * INVITE:\n *  _true_ if retransmission\n *  _false_ new request\n *\n * ACK:\n *  _true_  ACK to non2xx response\n *  _false_ ACK must be passed to TU (accepted state)\n *          ACK to 2xx response\n *\n * CANCEL:\n *  _true_  no matching invite transaction\n *  _false_ matching invite transaction and no final response sent\n *\n * OTHER:\n *  _true_  retransmission\n *  _false_ new request\n */\nvar checkTransaction = function(ua, request) {\n  var tr;\n\n  switch(request.method) {\n    case SIP.C.INVITE:\n      tr = ua.transactions.ist[request.via_branch];\n      if(tr) {\n        switch(tr.state) {\n          case C.STATUS_PROCEEDING:\n            tr.transport.send(tr.last_response);\n            break;\n\n            // RFC 6026 7.1 Invite retransmission\n            //received while in C.STATUS_ACCEPTED state. Absorb it.\n          case C.STATUS_ACCEPTED:\n            break;\n        }\n        return true;\n      }\n      break;\n    case SIP.C.ACK:\n      tr = ua.transactions.ist[request.via_branch];\n\n      // RFC 6026 7.1\n      if(tr) {\n        if(tr.state === C.STATUS_ACCEPTED) {\n          return false;\n        } else if(tr.state === C.STATUS_COMPLETED) {\n          tr.state = C.STATUS_CONFIRMED;\n          tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);\n          return true;\n        }\n      }\n\n      // ACK to 2XX Response.\n      else {\n        return false;\n      }\n      break;\n    case SIP.C.CANCEL:\n      tr = ua.transactions.ist[request.via_branch];\n      if(tr) {\n        request.reply_sl(200);\n        if(tr.state === C.STATUS_PROCEEDING) {\n          return false;\n        } else {\n          return true;\n        }\n      } else {\n        request.reply_sl(481);\n        return true;\n      }\n      break;\n    default:\n\n      // Non-INVITE Server Transaction RFC 3261 17.2.2\n      tr = ua.transactions.nist[request.via_branch];\n      if(tr) {\n        switch(tr.state) {\n          case C.STATUS_TRYING:\n            break;\n          case C.STATUS_PROCEEDING:\n          case C.STATUS_COMPLETED:\n            tr.transport.send(tr.last_response);\n            break;\n        }\n        return true;\n      }\n      break;\n  }\n};\n\nSIP.Transactions = {\n  C: C,\n  checkTransaction: checkTransaction,\n  NonInviteClientTransaction: NonInviteClientTransaction,\n  InviteClientTransaction: InviteClientTransaction,\n  AckClientTransaction: AckClientTransaction,\n  NonInviteServerTransaction: NonInviteServerTransaction,\n  InviteServerTransaction: InviteServerTransaction\n};\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Transactions.js\n ** module id = 16\n ** module chunks = 0\n **/","\n/**\n * @fileoverview In-Dialog Request Sender\n */\n\n/**\n * @augments SIP.Dialog\n * @class Class creating an In-dialog request sender.\n * @param {SIP.Dialog} dialog\n * @param {Object} applicant\n * @param {SIP.OutgoingRequest} request\n */\n/**\n * @fileoverview in-Dialog Request Sender\n */\n\nmodule.exports = function (SIP) {\nvar RequestSender;\n\nRequestSender = function(dialog, applicant, request) {\n\n  this.dialog = dialog;\n  this.applicant = applicant;\n  this.request = request;\n\n  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.\n  this.reattempt = false;\n  this.reattemptTimer = null;\n};\n\nRequestSender.prototype = {\n  send: function() {\n    var self = this,\n      request_sender = new SIP.RequestSender(this, this.dialog.owner.ua);\n\n      request_sender.send();\n\n    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-\n    if (this.request.method === SIP.C.INVITE && request_sender.clientTransaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n      this.dialog.uac_pending_reply = true;\n      request_sender.clientTransaction.on('stateChanged', function stateChanged(){\n        if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n            this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n            this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n\n          this.off('stateChanged', stateChanged);\n          self.dialog.uac_pending_reply = false;\n\n          if (self.dialog.uas_pending_reply === false) {\n            self.dialog.owner.onReadyToReinvite();\n          }\n        }\n      });\n    }\n  },\n\n  onRequestTimeout: function() {\n    this.applicant.onRequestTimeout();\n  },\n\n  onTransportError: function() {\n    this.applicant.onTransportError();\n  },\n\n  receiveResponse: function(response) {\n    var self = this;\n\n    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.\n    if (response.status_code === 408 || response.status_code === 481) {\n      this.applicant.onDialogError(response);\n    } else if (response.method === SIP.C.INVITE && response.status_code === 491) {\n      if (this.reattempt) {\n        this.applicant.receiveResponse(response);\n      } else {\n        this.request.cseq.value = this.dialog.local_seqnum += 1;\n        this.reattemptTimer = SIP.Timers.setTimeout(\n          function() {\n            if (self.applicant.owner.status !== SIP.Session.C.STATUS_TERMINATED) {\n              self.reattempt = true;\n              self.request_sender.send();\n            }\n          },\n          this.getReattemptTimeout()\n        );\n      }\n    } else {\n      this.applicant.receiveResponse(response);\n    }\n  }\n};\n\nreturn RequestSender;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Dialog/RequestSender.js\n ** module id = 17\n ** module chunks = 0\n **/","/**\n * @fileoverview SIP Dialog\n */\n\n/**\n * @augments SIP\n * @class Class creating a SIP dialog.\n * @param {SIP.RTCSession} owner\n * @param {SIP.IncomingRequest|SIP.IncomingResponse} message\n * @param {Enum} type UAC / UAS\n * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED\n */\nmodule.exports = function (SIP, RequestSender) {\n\nvar Dialog,\n  C = {\n    // Dialog states\n    STATUS_EARLY:       1,\n    STATUS_CONFIRMED:   2\n  };\n\n// RFC 3261 12.1\nDialog = function(owner, message, type, state) {\n  var contact;\n\n  this.uac_pending_reply = false;\n  this.uas_pending_reply = false;\n\n  if(!message.hasHeader('contact')) {\n    return {\n      error: 'unable to create a Dialog without Contact header field'\n    };\n  }\n\n  if(message instanceof SIP.IncomingResponse) {\n    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;\n  } else {\n    // Create confirmed dialog if state is not defined\n    state = state || C.STATUS_CONFIRMED;\n  }\n\n  contact = message.parseHeader('contact');\n\n  // RFC 3261 12.1.1\n  if(type === 'UAS') {\n    this.id = {\n      call_id: message.call_id,\n      local_tag: message.to_tag,\n      remote_tag: message.from_tag,\n      toString: function() {\n        return this.call_id + this.local_tag + this.remote_tag;\n      }\n    };\n    this.state = state;\n    this.remote_seqnum = message.cseq;\n    this.local_uri = message.parseHeader('to').uri;\n    this.remote_uri = message.parseHeader('from').uri;\n    this.remote_target = contact.uri;\n    this.route_set = message.getHeaders('record-route');\n    this.invite_seqnum = message.cseq;\n    this.local_seqnum = message.cseq;\n  }\n  // RFC 3261 12.1.2\n  else if(type === 'UAC') {\n    this.id = {\n      call_id: message.call_id,\n      local_tag: message.from_tag,\n      remote_tag: message.to_tag,\n      toString: function() {\n        return this.call_id + this.local_tag + this.remote_tag;\n      }\n    };\n    this.state = state;\n    this.invite_seqnum = message.cseq;\n    this.local_seqnum = message.cseq;\n    this.local_uri = message.parseHeader('from').uri;\n    this.pracked = [];\n    this.remote_uri = message.parseHeader('to').uri;\n    this.remote_target = contact.uri;\n    this.route_set = message.getHeaders('record-route').reverse();\n\n    //RENDERBODY\n    if (this.state === C.STATUS_EARLY && (!owner.hasOffer)) {\n      this.mediaHandler = owner.mediaHandlerFactory(owner);\n    }\n  }\n\n  this.logger = owner.ua.getLogger('sip.dialog', this.id.toString());\n  this.owner = owner;\n  owner.ua.dialogs[this.id.toString()] = this;\n  this.logger.log('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));\n};\n\nDialog.prototype = {\n  /**\n   * @param {SIP.IncomingMessage} message\n   * @param {Enum} UAC/UAS\n   */\n  update: function(message, type) {\n    this.state = C.STATUS_CONFIRMED;\n\n    this.logger.log('dialog '+ this.id.toString() +'  changed to CONFIRMED state');\n\n    if(type === 'UAC') {\n      // RFC 3261 13.2.2.4\n      this.route_set = message.getHeaders('record-route').reverse();\n    }\n  },\n\n  terminate: function() {\n    this.logger.log('dialog ' + this.id.toString() + ' deleted');\n    if (this.mediaHandler && this.state !== C.STATUS_CONFIRMED) {\n      this.mediaHandler.peerConnection.close();\n    }\n    delete this.owner.ua.dialogs[this.id.toString()];\n  },\n\n  /**\n  * @param {String} method request method\n  * @param {Object} extraHeaders extra headers\n  * @returns {SIP.OutgoingRequest}\n  */\n\n  // RFC 3261 12.2.1.1\n  createRequest: function(method, extraHeaders, body) {\n    var cseq, request;\n    extraHeaders = (extraHeaders || []).slice();\n\n    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }\n\n    cseq = (method === SIP.C.CANCEL || method === SIP.C.ACK) ? this.invite_seqnum : this.local_seqnum += 1;\n\n    request = new SIP.OutgoingRequest(\n      method,\n      this.remote_target,\n      this.owner.ua, {\n        'cseq': cseq,\n        'call_id': this.id.call_id,\n        'from_uri': this.local_uri,\n        'from_tag': this.id.local_tag,\n        'to_uri': this.remote_uri,\n        'to_tag': this.id.remote_tag,\n        'route_set': this.route_set\n      }, extraHeaders, body);\n\n    request.dialog = this;\n\n    return request;\n  },\n\n  /**\n  * @param {SIP.IncomingRequest} request\n  * @returns {Boolean}\n  */\n\n  // RFC 3261 12.2.2\n  checkInDialogRequest: function(request) {\n    var self = this;\n\n    if(!this.remote_seqnum) {\n      this.remote_seqnum = request.cseq;\n    } else if(request.cseq < this.remote_seqnum) {\n        //Do not try to reply to an ACK request.\n        if (request.method !== SIP.C.ACK) {\n          request.reply(500);\n        }\n        if (request.cseq === this.invite_seqnum) {\n          return true;\n        }\n        return false;\n    } else if(request.cseq > this.remote_seqnum) {\n      this.remote_seqnum = request.cseq;\n    }\n\n    switch(request.method) {\n      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-\n      case SIP.C.INVITE:\n        if (this.uac_pending_reply === true) {\n          request.reply(491);\n        } else if (this.uas_pending_reply === true) {\n          var retryAfter = (Math.random() * 10 | 0) + 1;\n          request.reply(500, null, ['Retry-After:' + retryAfter]);\n          return false;\n        } else {\n          this.uas_pending_reply = true;\n          request.server_transaction.on('stateChanged', function stateChanged(){\n            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n                this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n                this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n\n              this.off('stateChanged', stateChanged);\n              self.uas_pending_reply = false;\n\n              if (self.uac_pending_reply === false) {\n                self.owner.onReadyToReinvite();\n              }\n            }\n          });\n        }\n\n        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted\n        if(request.hasHeader('contact')) {\n          request.server_transaction.on('stateChanged', function(){\n            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED) {\n              self.remote_target = request.parseHeader('contact').uri;\n            }\n          });\n        }\n        break;\n      case SIP.C.NOTIFY:\n        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted\n        if(request.hasHeader('contact')) {\n          request.server_transaction.on('stateChanged', function(){\n            if (this.state === SIP.Transactions.C.STATUS_COMPLETED) {\n              self.remote_target = request.parseHeader('contact').uri;\n            }\n          });\n        }\n        break;\n    }\n\n    return true;\n  },\n\n  sendRequest: function(applicant, method, options) {\n    options = options || {};\n\n    var\n      extraHeaders = (options.extraHeaders || []).slice(),\n      body = options.body || null,\n      request = this.createRequest(method, extraHeaders, body),\n      request_sender = new RequestSender(this, applicant, request);\n\n    request_sender.send();\n\n    return request;\n  },\n\n  /**\n  * @param {SIP.IncomingRequest} request\n  */\n  receiveRequest: function(request) {\n    //Check in-dialog request\n    if(!this.checkInDialogRequest(request)) {\n      return;\n    }\n\n    this.owner.receiveRequest(request);\n  }\n};\n\nDialog.C = C;\nSIP.Dialog = Dialog;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Dialogs.js\n ** module id = 18\n ** module chunks = 0\n **/","\n/**\n * @fileoverview Request Sender\n */\n\n/**\n * @augments SIP\n * @class Class creating a request sender.\n * @param {Object} applicant\n * @param {SIP.UA} ua\n */\nmodule.exports = function (SIP) {\nvar RequestSender;\n\nRequestSender = function(applicant, ua) {\n  this.logger = ua.getLogger('sip.requestsender');\n  this.ua = ua;\n  this.applicant = applicant;\n  this.method = applicant.request.method;\n  this.request = applicant.request;\n  this.credentials = null;\n  this.challenged = false;\n  this.staled = false;\n\n  // If ua is in closing process or even closed just allow sending Bye and ACK\n  if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {\n    this.onTransportError();\n  }\n};\n\n/**\n* Create the client transaction and send the message.\n*/\nRequestSender.prototype = {\n  send: function() {\n    switch(this.method) {\n      case \"INVITE\":\n        this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);\n        break;\n      case \"ACK\":\n        this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);\n        break;\n      default:\n        this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);\n    }\n    this.clientTransaction.send();\n\n    return this.clientTransaction;\n  },\n\n  /**\n  * Callback fired when receiving a request timeout error from the client transaction.\n  * To be re-defined by the applicant.\n  * @event\n  */\n  onRequestTimeout: function() {\n    this.applicant.onRequestTimeout();\n  },\n\n  /**\n  * Callback fired when receiving a transport error from the client transaction.\n  * To be re-defined by the applicant.\n  * @event\n  */\n  onTransportError: function() {\n    this.applicant.onTransportError();\n  },\n\n  /**\n  * Called from client transaction when receiving a correct response to the request.\n  * Authenticate request if needed or pass the response back to the applicant.\n  * @param {SIP.IncomingResponse} response\n  */\n  receiveResponse: function(response) {\n    var cseq, challenge, authorization_header_name,\n      status_code = response.status_code;\n\n    /*\n    * Authentication\n    * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n    */\n    if ((status_code === 401 || status_code === 407) && this.ua.configuration.password !== null) {\n\n      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n      if (response.status_code === 401) {\n        challenge = response.parseHeader('www-authenticate');\n        authorization_header_name = 'authorization';\n      } else {\n        challenge = response.parseHeader('proxy-authenticate');\n        authorization_header_name = 'proxy-authorization';\n      }\n\n      // Verify it seems a valid challenge.\n      if (! challenge) {\n        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');\n        this.applicant.receiveResponse(response);\n        return;\n      }\n\n      if (!this.challenged || (!this.staled && challenge.stale === true)) {\n        if (!this.credentials) {\n          this.credentials = new SIP.DigestAuthentication(this.ua);\n        }\n\n        // Verify that the challenge is really valid.\n        if (!this.credentials.authenticate(this.request, challenge)) {\n          this.applicant.receiveResponse(response);\n          return;\n        }\n        this.challenged = true;\n\n        if (challenge.stale) {\n          this.staled = true;\n        }\n\n        if (response.method === SIP.C.REGISTER) {\n          cseq = this.applicant.cseq += 1;\n        } else if (this.request.dialog){\n          cseq = this.request.dialog.local_seqnum += 1;\n        } else {\n          cseq = this.request.cseq + 1;\n          this.request.cseq = cseq;\n        }\n        this.request.setHeader('cseq', cseq +' '+ this.method);\n\n        this.request.setHeader(authorization_header_name, this.credentials.toString());\n        this.send();\n      } else {\n        this.applicant.receiveResponse(response);\n      }\n    } else {\n      this.applicant.receiveResponse(response);\n    }\n  }\n};\n\nSIP.RequestSender = RequestSender;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/RequestSender.js\n ** module id = 19\n ** module chunks = 0\n **/","module.exports = function (SIP) {\n\nvar RegisterContext;\n\nRegisterContext = function (ua) {\n  var params = {},\n      regId = 1,\n      events = [\n        'registered',\n        'unregistered'\n      ];\n\n  this.registrar = ua.configuration.registrarServer;\n  this.expires = ua.configuration.registerExpires;\n\n\n  // Contact header\n  this.contact = ua.contact.toString();\n\n  if(regId) {\n    this.contact += ';reg-id='+ regId;\n    this.contact += ';+sip.instance=\"<urn:uuid:'+ ua.configuration.instanceId+'>\"';\n  }\n\n  // Call-ID and CSeq values RFC3261 10.2\n  this.call_id = SIP.Utils.createRandomToken(22);\n  this.cseq = 80;\n\n  this.to_uri = ua.configuration.uri;\n\n  params.to_uri = this.to_uri;\n  params.call_id = this.call_id;\n  params.cseq = this.cseq;\n\n  // Extends ClientContext\n  SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, {params: params}]);\n\n  this.registrationTimer = null;\n  this.registrationExpiredTimer = null;\n\n  // Set status\n  this.registered = false;\n\n  this.logger = ua.getLogger('sip.registercontext');\n  this.initMoreEvents(events);\n};\n\nRegisterContext.prototype = {\n  register: function (options) {\n    var self = this, extraHeaders;\n\n    // Handle Options\n    options = options || {};\n    extraHeaders = (options.extraHeaders || []).slice();\n    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);\n    extraHeaders.push('Allow: ' + SIP.Utils.getAllowedMethods(this.ua));\n\n    this.receiveResponse = function(response) {\n      var contact, expires,\n        contacts = response.getHeaders('contact').length,\n        cause;\n\n      // Discard responses to older REGISTER/un-REGISTER requests.\n      if(response.cseq !== this.cseq) {\n        return;\n      }\n\n      // Clear registration timer\n      if (this.registrationTimer !== null) {\n        SIP.Timers.clearTimeout(this.registrationTimer);\n        this.registrationTimer = null;\n      }\n\n      switch(true) {\n        case /^1[0-9]{2}$/.test(response.status_code):\n          this.emit('progress', response);\n          break;\n        case /^2[0-9]{2}$/.test(response.status_code):\n          this.emit('accepted', response);\n\n          if(response.hasHeader('expires')) {\n            expires = response.getHeader('expires');\n          }\n\n          if (this.registrationExpiredTimer !== null) {\n            SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n            this.registrationExpiredTimer = null;\n          }\n\n          // Search the Contact pointing to us and update the expires value accordingly.\n          if (!contacts) {\n            this.logger.warn('no Contact header in response to REGISTER, response ignored');\n            break;\n          }\n\n          while(contacts--) {\n            contact = response.parseHeader('contact', contacts);\n            if(contact.uri.user === this.ua.contact.uri.user) {\n              expires = contact.getParam('expires');\n              break;\n            } else {\n              contact = null;\n            }\n          }\n\n          if (!contact) {\n            this.logger.warn('no Contact header pointing to us, response ignored');\n            break;\n          }\n\n          if(!expires) {\n            expires = this.expires;\n          }\n\n          // Re-Register before the expiration interval has elapsed.\n          // For that, decrease the expires value. ie: 3 seconds\n          this.registrationTimer = SIP.Timers.setTimeout(function() {\n            self.registrationTimer = null;\n            self.register(options);\n          }, (expires * 1000) - 3000);\n          this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {\n            self.logger.warn('registration expired');\n            if (self.registered) {\n              self.unregistered(null, SIP.C.causes.EXPIRES);\n            }\n          }, expires * 1000);\n\n          //Save gruu values\n          if (contact.hasParam('temp-gruu')) {\n            this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/\"/g,''));\n          }\n          if (contact.hasParam('pub-gruu')) {\n            this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/\"/g,''));\n          }\n\n          this.registered = true;\n          this.emit('registered', response || null);\n          break;\n        // Interval too brief RFC3261 10.2.8\n        case /^423$/.test(response.status_code):\n          if(response.hasHeader('min-expires')) {\n            // Increase our registration interval to the suggested minimum\n            this.expires = response.getHeader('min-expires');\n            // Attempt the registration again immediately\n            this.register(options);\n          } else { //This response MUST contain a Min-Expires header field\n            this.logger.warn('423 response received for REGISTER without Min-Expires');\n            this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);\n          }\n          break;\n        default:\n          cause = SIP.Utils.sipErrorCause(response.status_code);\n          this.registrationFailure(response, cause);\n      }\n    };\n\n    this.onRequestTimeout = function() {\n      this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);\n    };\n\n    this.onTransportError = function() {\n      this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);\n    };\n\n    this.cseq++;\n    this.request.cseq = this.cseq;\n    this.request.setHeader('cseq', this.cseq + ' REGISTER');\n    this.request.extraHeaders = extraHeaders;\n    this.send();\n  },\n\n  registrationFailure: function (response, cause) {\n    this.emit('failed', response || null, cause || null);\n  },\n\n  onTransportClosed: function() {\n    this.registered_before = this.registered;\n    if (this.registrationTimer !== null) {\n      SIP.Timers.clearTimeout(this.registrationTimer);\n      this.registrationTimer = null;\n    }\n\n    if (this.registrationExpiredTimer !== null) {\n      SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n      this.registrationExpiredTimer = null;\n    }\n\n    if(this.registered) {\n      this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n    }\n  },\n\n  onTransportConnected: function() {\n    this.register();\n  },\n\n  close: function() {\n    this.registered_before = this.registered;\n    this.unregister();\n  },\n\n  unregister: function(options) {\n    var extraHeaders;\n\n    if(!this.registered) {\n      this.logger.warn('already unregistered');\n      return;\n    }\n\n    options = options || {};\n    extraHeaders = (options.extraHeaders || []).slice();\n\n    this.registered = false;\n\n    // Clear the registration timer.\n    if (this.registrationTimer !== null) {\n      SIP.Timers.clearTimeout(this.registrationTimer);\n      this.registrationTimer = null;\n    }\n\n    if(options.all) {\n      extraHeaders.push('Contact: *');\n      extraHeaders.push('Expires: 0');\n    } else {\n      extraHeaders.push('Contact: '+ this.contact + ';expires=0');\n    }\n\n\n    this.receiveResponse = function(response) {\n      var cause;\n\n      switch(true) {\n        case /^1[0-9]{2}$/.test(response.status_code):\n          this.emit('progress', response);\n          break;\n        case /^2[0-9]{2}$/.test(response.status_code):\n          this.emit('accepted', response);\n          if (this.registrationExpiredTimer !== null) {\n            SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n            this.registrationExpiredTimer = null;\n          }\n          this.unregistered(response);\n          break;\n        default:\n          cause = SIP.Utils.sipErrorCause(response.status_code);\n          this.unregistered(response,cause);\n      }\n    };\n\n    this.onRequestTimeout = function() {\n      // Not actually unregistered...\n      //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);\n    };\n\n    this.onTransportError = function() {\n      // Not actually unregistered...\n      //this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n    };\n\n    this.cseq++;\n    this.request.cseq = this.cseq;\n    this.request.setHeader('cseq', this.cseq + ' REGISTER');\n    this.request.extraHeaders = extraHeaders;\n\n    this.send();\n  },\n\n  unregistered: function(response, cause) {\n    this.registered = false;\n    this.emit('unregistered', response || null, cause || null);\n  }\n\n};\n\n\nSIP.RegisterContext = RegisterContext;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/RegisterContext.js\n ** module id = 20\n ** module chunks = 0\n **/","/**\n * @fileoverview MediaHandler\n */\n\n/* MediaHandler\n * @class PeerConnection helper Class.\n * @param {SIP.Session} session\n * @param {Object} [options]\n */\nmodule.exports = function (EventEmitter) {\nvar MediaHandler = function(session, options) {\n  // keep jshint happy\n  session = session;\n  options = options;\n};\n\nMediaHandler.prototype = Object.create(EventEmitter.prototype, {\n  isReady: {value: function isReady () {}},\n\n  close: {value: function close () {}},\n\n  /**\n   * @param {Function} onSuccess called with the obtained local media description\n   * @param {Function} onFailure\n   * @param {Object} [mediaHint] A custom object describing the media to be used during this session.\n   */\n  getDescription: {value: function getDescription (onSuccess, onFailure, mediaHint) {\n    // keep jshint happy\n    onSuccess = onSuccess;\n    onFailure = onFailure;\n    mediaHint = mediaHint;\n  }},\n\n  /**\n  * Message reception.\n  * @param {String} type\n  * @param {String} description\n  * @param {Function} onSuccess\n  * @param {Function} onFailure\n  */\n  setDescription: {value: function setDescription (description, onSuccess, onFailure) {\n    // keep jshint happy\n    description = description;\n    onSuccess = onSuccess;\n    onFailure = onFailure;\n  }}\n});\n\nreturn MediaHandler;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/MediaHandler.js\n ** module id = 21\n ** module chunks = 0\n **/","module.exports = function (SIP) {\nvar ClientContext;\n\nClientContext = function (ua, method, target, options) {\n  var params, extraHeaders,\n      originalTarget = target,\n      events = [\n        'progress',\n        'accepted',\n        'rejected',\n        'failed',\n        'cancel'\n      ];\n\n  if (target === undefined) {\n    throw new TypeError('Not enough arguments');\n  }\n\n  // Check target validity\n  target = ua.normalizeTarget(target);\n  if (!target) {\n    throw new TypeError('Invalid target: ' + originalTarget);\n  }\n\n  this.ua = ua;\n  this.logger = ua.getLogger('sip.clientcontext');\n  this.method = method;\n\n  params = options && options.params;\n  extraHeaders = (options && options.extraHeaders || []).slice();\n\n  if (options && options.body) {\n    this.body = options.body;\n  }\n  if (options && options.contentType) {\n    this.contentType = options.contentType;\n    extraHeaders.push('Content-Type: ' + this.contentType);\n  }\n\n  this.request = new SIP.OutgoingRequest(this.method, target, this.ua, params, extraHeaders);\n\n  this.localIdentity = this.request.from;\n  this.remoteIdentity = this.request.to;\n\n  if (this.body) {\n    this.request.body = this.body;\n  }\n\n  this.data = {};\n\n  this.initEvents(events);\n};\nClientContext.prototype = new SIP.EventEmitter();\n\nClientContext.prototype.send = function () {\n  (new SIP.RequestSender(this, this.ua)).send();\n  return this;\n};\n\nClientContext.prototype.cancel = function (options) {\n  options = options || {};\n\n  var\n  status_code = options.status_code,\n  reason_phrase = options.reason_phrase,\n  cancel_reason;\n\n  if (status_code && status_code < 200 || status_code > 699) {\n    throw new TypeError('Invalid status_code: ' + status_code);\n  } else if (status_code) {\n    reason_phrase = reason_phrase || SIP.C.REASON_PHRASE[status_code] || '';\n    cancel_reason = 'SIP ;cause=' + status_code + ' ;text=\"' + reason_phrase + '\"';\n  }\n  this.request.cancel(cancel_reason);\n\n  this.emit('cancel');\n};\n\nClientContext.prototype.receiveResponse = function (response) {\n  var cause = SIP.C.REASON_PHRASE[response.status_code] || '';\n\n  switch(true) {\n    case /^1[0-9]{2}$/.test(response.status_code):\n      this.emit('progress', response, cause);\n      break;\n\n    case /^2[0-9]{2}$/.test(response.status_code):\n      if(this.ua.applicants[this]) {\n        delete this.ua.applicants[this];\n      }\n      this.emit('accepted', response, cause);\n      break;\n\n    default:\n      if(this.ua.applicants[this]) {\n        delete this.ua.applicants[this];\n      }\n      this.emit('rejected', response, cause);\n      this.emit('failed', response, cause);\n      break;\n  }\n\n};\n\nClientContext.prototype.onRequestTimeout = function () {\n  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n};\n\nClientContext.prototype.onTransportError = function () {\n  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n};\n\nSIP.ClientContext = ClientContext;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/ClientContext.js\n ** module id = 22\n ** module chunks = 0\n **/","module.exports = function (SIP) {\nvar ServerContext;\n\nServerContext = function (ua, request) {\n  var events = [\n      'progress',\n      'accepted',\n      'rejected',\n      'failed'\n    ];\n  this.ua = ua;\n  this.logger = ua.getLogger('sip.servercontext');\n  this.request = request;\n  if (request.method === SIP.C.INVITE) {\n    this.transaction = new SIP.Transactions.InviteServerTransaction(request, ua);\n  } else {\n    this.transaction = new SIP.Transactions.NonInviteServerTransaction(request, ua);\n  }\n\n  if (request.body) {\n    this.body = request.body;\n  }\n  if (request.hasHeader('Content-Type')) {\n    this.contentType = request.getHeader('Content-Type');\n  }\n  this.method = request.method;\n\n  this.data = {};\n\n  this.localIdentity = request.to;\n  this.remoteIdentity = request.from;\n\n  this.initEvents(events);\n};\n\nServerContext.prototype = new SIP.EventEmitter();\n\nServerContext.prototype.progress = function (options) {\n  options = options || {};\n  var\n    statusCode = options.statusCode || 180,\n    reasonPhrase = options.reasonPhrase || SIP.C.REASON_PHRASE[statusCode],\n    extraHeaders = (options.extraHeaders || []).slice(),\n    body = options.body,\n    response;\n\n  if (statusCode < 100 || statusCode > 199) {\n    throw new TypeError('Invalid statusCode: ' + statusCode);\n  }\n  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n  this.emit('progress', response, reasonPhrase);\n\n  return this;\n};\n\nServerContext.prototype.accept = function (options) {\n  options = options || {};\n  var\n    statusCode = options.statusCode || 200,\n    reasonPhrase = options.reasonPhrase || SIP.C.REASON_PHRASE[statusCode],\n    extraHeaders = (options.extraHeaders || []).slice(),\n    body = options.body,\n    response;\n\n  if (statusCode < 200 || statusCode > 299) {\n    throw new TypeError('Invalid statusCode: ' + statusCode);\n  }\n  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n  this.emit('accepted', response, reasonPhrase);\n\n  return this;\n};\n\nServerContext.prototype.reject = function (options) {\n  options = options || {};\n  var\n    statusCode = options.statusCode || 480,\n    reasonPhrase = options.reasonPhrase || SIP.C.REASON_PHRASE[statusCode],\n    extraHeaders = (options.extraHeaders || []).slice(),\n    body = options.body,\n    response;\n\n  if (statusCode < 300 || statusCode > 699) {\n    throw new TypeError('Invalid statusCode: ' + statusCode);\n  }\n  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n  this.emit('rejected', response, reasonPhrase);\n  this.emit('failed', response, reasonPhrase);\n\n  return this;\n};\n\nServerContext.prototype.reply = function (options) {\n  options = options || {};\n  var\n    statusCode = options.statusCode,\n    reasonPhrase = options.reasonPhrase,\n    extraHeaders = (options.extraHeaders || []).slice(),\n    body = options.body;\n\n  this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n\n  return this;\n};\n\nServerContext.prototype.onRequestTimeout = function () {\n  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n};\n\nServerContext.prototype.onTransportError = function () {\n  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n};\n\nSIP.ServerContext = ServerContext;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/ServerContext.js\n ** module id = 23\n ** module chunks = 0\n **/","/**\n * @fileoverview DTMF\n */\n\n/**\n * @class DTMF\n * @param {SIP.Session} session\n */\nmodule.exports = function (SIP) {\n\nvar DTMF,\n  C = {\n    MIN_DURATION:            70,\n    MAX_DURATION:            6000,\n    DEFAULT_DURATION:        100,\n    MIN_INTER_TONE_GAP:      50,\n    DEFAULT_INTER_TONE_GAP:  500\n  };\n\nDTMF = function(session, tone, options) {\n  var events = [\n  'succeeded',\n  'failed'\n  ], duration, interToneGap;\n\n  if (tone === undefined) {\n    throw new TypeError('Not enough arguments');\n  }\n\n  this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);\n  this.owner = session;\n  this.direction = null;\n\n  options = options || {};\n  duration = options.duration || null;\n  interToneGap = options.interToneGap || null;\n\n  // Check tone type\n  if (typeof tone === 'string' ) {\n    tone = tone.toUpperCase();\n  } else if (typeof tone === 'number') {\n    tone = tone.toString();\n  } else {\n    throw new TypeError('Invalid tone: '+ tone);\n  }\n\n  // Check tone value\n  if (!tone.match(/^[0-9A-D#*]$/)) {\n    throw new TypeError('Invalid tone: '+ tone);\n  } else {\n    this.tone = tone;\n  }\n\n  // Check duration\n  if (duration && !SIP.Utils.isDecimal(duration)) {\n    throw new TypeError('Invalid tone duration: '+ duration);\n  } else if (!duration) {\n    duration = DTMF.C.DEFAULT_DURATION;\n  } else if (duration < DTMF.C.MIN_DURATION) {\n    this.logger.warn('\"duration\" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_DURATION+ ' milliseconds');\n    duration = DTMF.C.MIN_DURATION;\n  } else if (duration > DTMF.C.MAX_DURATION) {\n    this.logger.warn('\"duration\" value is greater than the maximum allowed, setting it to '+ DTMF.C.MAX_DURATION +' milliseconds');\n    duration = DTMF.C.MAX_DURATION;\n  } else {\n    duration = Math.abs(duration);\n  }\n  this.duration = duration;\n\n  // Check interToneGap\n  if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {\n    throw new TypeError('Invalid interToneGap: '+ interToneGap);\n  } else if (!interToneGap) {\n    interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;\n  } else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {\n    this.logger.warn('\"interToneGap\" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_INTER_TONE_GAP +' milliseconds');\n    interToneGap = DTMF.C.MIN_INTER_TONE_GAP;\n  } else {\n    interToneGap = Math.abs(interToneGap);\n  }\n  this.interToneGap = interToneGap;\n\n  this.initEvents(events);\n};\nDTMF.prototype = new SIP.EventEmitter();\n\n\nDTMF.prototype.send = function(options) {\n  var extraHeaders, body;\n\n  this.direction = 'outgoing';\n\n  // Check RTCSession Status\n  if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED &&\n    this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n    throw new SIP.Exceptions.InvalidStateError(this.owner.status);\n  }\n\n  // Get DTMF options\n  options = options || {};\n  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];\n\n  extraHeaders.push('Content-Type: application/dtmf-relay');\n\n  body = \"Signal= \" + this.tone + \"\\r\\n\";\n  body += \"Duration= \" + this.duration;\n\n  this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {\n    extraHeaders: extraHeaders,\n    body: body\n  });\n\n  this.owner.emit('dtmf', this.request, this);\n};\n\n/**\n * @private\n */\nDTMF.prototype.receiveResponse = function(response) {\n  var cause;\n\n  switch(true) {\n    case /^1[0-9]{2}$/.test(response.status_code):\n      // Ignore provisional responses.\n      break;\n\n    case /^2[0-9]{2}$/.test(response.status_code):\n      this.emit('succeeded', {\n        originator: 'remote',\n        response: response\n      });\n      break;\n\n    default:\n      cause = SIP.Utils.sipErrorCause(response.status_code);\n      this.emit('failed', response, cause);\n      break;\n  }\n};\n\n/**\n * @private\n */\nDTMF.prototype.onRequestTimeout = function() {\n  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n  this.owner.onRequestTimeout();\n};\n\n/**\n * @private\n */\nDTMF.prototype.onTransportError = function() {\n  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n  this.owner.onTransportError();\n};\n\n/**\n * @private\n */\nDTMF.prototype.onDialogError = function(response) {\n  this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);\n  this.owner.onDialogError(response);\n};\n\n/**\n * @private\n */\nDTMF.prototype.init_incoming = function(request) {\n  this.direction = 'incoming';\n  this.request = request;\n\n  request.reply(200);\n\n  if (!this.tone || !this.duration) {\n    this.logger.warn('invalid INFO DTMF received, discarded');\n  } else {\n    this.owner.emit('dtmf', request, this);\n  }\n};\n\nDTMF.C = C;\nreturn DTMF;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Session/DTMF.js\n ** module id = 24\n ** module chunks = 0\n **/","module.exports = function (SIP, window, DTMF) {\n\nvar Session, InviteServerContext, InviteClientContext,\n C = {\n    //Session states\n    STATUS_NULL:                        0,\n    STATUS_INVITE_SENT:                 1,\n    STATUS_1XX_RECEIVED:                2,\n    STATUS_INVITE_RECEIVED:             3,\n    STATUS_WAITING_FOR_ANSWER:          4,\n    STATUS_ANSWERED:                    5,\n    STATUS_WAITING_FOR_PRACK:           6,\n    STATUS_WAITING_FOR_ACK:             7,\n    STATUS_CANCELED:                    8,\n    STATUS_TERMINATED:                  9,\n    STATUS_ANSWERED_WAITING_FOR_PRACK: 10,\n    STATUS_EARLY_MEDIA:                11,\n    STATUS_CONFIRMED:                  12\n  };\n\n/*\n * @param {function returning SIP.MediaHandler} [mediaHandlerFactory]\n *        (See the documentation for the mediaHandlerFactory argument of the UA constructor.)\n */\nSession = function (mediaHandlerFactory) {\n  var events = [\n  'connecting',\n  'terminated',\n  'dtmf',\n  'invite',\n  'cancel',\n  'refer',\n  'bye',\n  'hold',\n  'unhold',\n  'muted',\n  'unmuted'\n  ];\n\n  this.status = C.STATUS_NULL;\n  this.dialog = null;\n  this.earlyDialogs = {};\n  this.mediaHandlerFactory = mediaHandlerFactory || SIP.WebRTC.MediaHandler.defaultFactory;\n  // this.mediaHandler gets set by ICC/ISC constructors\n  this.hasOffer = false;\n  this.hasAnswer = false;\n\n  // Session Timers\n  this.timers = {\n    ackTimer: null,\n    expiresTimer: null,\n    invite2xxTimer: null,\n    userNoAnswerTimer: null,\n    rel1xxTimer: null,\n    prackTimer: null\n  };\n\n  // Session info\n  this.startTime = null;\n  this.endTime = null;\n  this.tones = null;\n\n  // Mute/Hold state\n  this.local_hold = false;\n  this.remote_hold = false;\n\n  this.pending_actions = {\n    actions: [],\n\n    length: function() {\n      return this.actions.length;\n    },\n\n    isPending: function(name){\n      var\n      idx = 0,\n      length = this.actions.length;\n\n      for (idx; idx<length; idx++) {\n        if (this.actions[idx].name === name) {\n          return true;\n        }\n      }\n      return false;\n    },\n\n    shift: function() {\n      return this.actions.shift();\n    },\n\n    push: function(name) {\n      this.actions.push({\n        name: name\n      });\n    },\n\n    pop: function(name) {\n      var\n      idx = 0,\n      length = this.actions.length;\n\n      for (idx; idx<length; idx++) {\n        if (this.actions[idx].name === name) {\n          this.actions.splice(idx,1);\n          length --;\n          idx--;\n        }\n      }\n    }\n   };\n\n  this.early_sdp = null;\n  this.rel100 = SIP.C.supported.UNSUPPORTED;\n\n  this.initMoreEvents(events);\n};\n\nSession.prototype = {\n  dtmf: function(tones, options) {\n    var tone, dtmfs = [],\n        self = this;\n\n    options = options || {};\n\n    if (tones === undefined) {\n      throw new TypeError('Not enough arguments');\n    }\n\n    // Check Session Status\n    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {\n      throw new SIP.Exceptions.InvalidStateError(this.status);\n    }\n\n    // Check tones\n    if (!tones || (typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {\n      throw new TypeError('Invalid tones: '+ tones);\n    }\n\n    tones = tones.toString().split('');\n\n    while (tones.length > 0) { dtmfs.push(new DTMF(this, tones.shift(), options)); }\n\n    if (this.tones) {\n      // Tones are already queued, just add to the queue\n      this.tones =  this.tones.concat(dtmfs);\n      return this;\n    }\n\n    var sendDTMF = function () {\n      var dtmf, timeout;\n\n      if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {\n        // Stop sending DTMF\n        self.tones = null;\n        return this;\n      }\n\n      dtmf = self.tones.shift();\n\n      if (tone === ',') {\n        timeout = 2000;\n      } else {\n        dtmf.on('failed', function(){self.tones = null;});\n        dtmf.send(options);\n        timeout = dtmf.duration + dtmf.interToneGap;\n      }\n\n      // Set timeout for the next tone\n      SIP.Timers.setTimeout(sendDTMF, timeout);\n    };\n\n    this.tones = dtmfs;\n    sendDTMF();\n    return this;\n  },\n\n  bye: function(options) {\n    options = options || {};\n    var statusCode = options.statusCode;\n\n    // Check Session Status\n    if (this.status === C.STATUS_TERMINATED) {\n      this.logger.error('Error: Attempted to send BYE in a terminated session.');\n      return this;\n    }\n\n    this.logger.log('terminating Session');\n\n    if (statusCode && (statusCode < 200 || statusCode >= 700)) {\n      throw new TypeError('Invalid statusCode: '+ statusCode);\n    }\n\n    options.receiveResponse = function () {};\n\n    return this.\n      sendRequest(SIP.C.BYE, options).\n      terminated();\n  },\n\n  refer: function(target, options) {\n    options = options || {};\n    var extraHeaders = (options.extraHeaders || []).slice(),\n        originalTarget = target;\n\n    if (target === undefined) {\n      throw new TypeError('Not enough arguments');\n    } else if (target instanceof SIP.InviteServerContext || target instanceof SIP.InviteClientContext) {\n      //Attended Transfer\n      // B.transfer(C)\n      extraHeaders.push('Contact: '+ this.contact);\n      extraHeaders.push('Allow: '+ SIP.Utils.getAllowedMethods(this.ua));\n      extraHeaders.push('Refer-To: <' + target.dialog.remote_target.toString() + '?Replaces=' + target.dialog.id.call_id + '%3Bto-tag%3D' + target.dialog.id.remote_tag + '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>');\n    } else {\n      //Blind Transfer\n\n      // Check Session Status\n      if (this.status !== C.STATUS_CONFIRMED) {\n        throw new SIP.Exceptions.InvalidStateError(this.status);\n      }\n\n      // normalizeTarget allows instances of SIP.URI to pass through unaltered,\n      // so try to make one ahead of time\n      try {\n        target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n      } catch (e) {\n        this.logger.debug(\".refer() cannot parse Refer_To from\", target);\n        this.logger.debug(\"...falling through to normalizeTarget()\");\n      }\n\n      // Check target validity\n      target = this.ua.normalizeTarget(target);\n      if (!target) {\n        throw new TypeError('Invalid target: ' + originalTarget);\n      }\n\n      extraHeaders.push('Contact: '+ this.contact);\n      extraHeaders.push('Allow: '+ SIP.Utils.getAllowedMethods(this.ua));\n      extraHeaders.push('Refer-To: '+ target);\n    }\n\n    // Send the request\n    this.sendRequest(SIP.C.REFER, {\n      extraHeaders: extraHeaders,\n      body: options.body,\n      receiveResponse: function() {}\n    });\n    // hang up only if we transferred to a SIP address\n    if (target.scheme.match(\"^sips?$\")) {\n      this.terminate();\n    }\n    return this;\n  },\n\n  followRefer: function followRefer (callback) {\n    return function referListener (callback, request) {\n      // window.open non-SIP URIs if possible and keep session open\n      var target = request.parseHeader('refer-to').uri;\n      if (!target.scheme.match(\"^sips?$\")) {\n        var targetString = target.toString();\n        if (typeof window !== \"undefined\" && typeof window.open === \"function\") {\n          window.open(targetString);\n        } else {\n          this.logger.warn(\"referred to non-SIP URI but window.open isn't a function: \" + targetString);\n        }\n        return;\n      }\n\n      SIP.Hacks.Chrome.getsConfusedAboutGUM(this);\n\n      /*\n        Harmless race condition.  Both sides of REFER\n        may send a BYE, but in the end the dialogs are destroyed.\n      */\n      var referSession = this.ua.invite(request.parseHeader('refer-to').uri, {\n        media: this.mediaHint\n      });\n\n      callback.call(this, request, referSession);\n\n      this.terminate();\n    }.bind(this, callback);\n  },\n\n  sendRequest: function(method,options) {\n    options = options || {};\n    var self = this;\n\n    var request = new SIP.OutgoingRequest(\n      method,\n      this.dialog.remote_target,\n      this.ua,\n      {\n        cseq: options.cseq || (this.dialog.local_seqnum += 1),\n        call_id: this.dialog.id.call_id,\n        from_uri: this.dialog.local_uri,\n        from_tag: this.dialog.id.local_tag,\n        to_uri: this.dialog.remote_uri,\n        to_tag: this.dialog.id.remote_tag,\n        route_set: this.dialog.route_set,\n        statusCode: options.statusCode,\n        reasonPhrase: options.reasonPhrase\n      },\n      options.extraHeaders || [],\n      options.body\n    );\n\n    new SIP.RequestSender({\n      request: request,\n      onRequestTimeout: function() {\n        self.onRequestTimeout();\n      },\n      onTransportError: function() {\n        self.onTransportError();\n      },\n      receiveResponse: options.receiveResponse || function(response) {\n        self.receiveNonInviteResponse(response);\n      }\n    }, this.ua).send();\n\n    // Emit the request event\n    if (this.checkEvent(method.toLowerCase())) {\n      this.emit(method.toLowerCase(), request);\n    }\n\n    return this;\n  },\n\n  close: function() {\n    var idx;\n\n    if(this.status === C.STATUS_TERMINATED) {\n      return this;\n    }\n\n    this.logger.log('closing INVITE session ' + this.id);\n\n    // 1st Step. Terminate media.\n    if (this.mediaHandler){\n      this.mediaHandler.close();\n    }\n\n    // 2nd Step. Terminate signaling.\n\n    // Clear session timers\n    for(idx in this.timers) {\n      SIP.Timers.clearTimeout(this.timers[idx]);\n    }\n\n    // Terminate dialogs\n\n    // Terminate confirmed dialog\n    if(this.dialog) {\n      this.dialog.terminate();\n      delete this.dialog;\n    }\n\n    // Terminate early dialogs\n    for(idx in this.earlyDialogs) {\n      this.earlyDialogs[idx].terminate();\n      delete this.earlyDialogs[idx];\n    }\n\n    this.status = C.STATUS_TERMINATED;\n\n    delete this.ua.sessions[this.id];\n    return this;\n  },\n\n  createDialog: function(message, type, early) {\n    var dialog, early_dialog,\n      local_tag = message[(type === 'UAS') ? 'to_tag' : 'from_tag'],\n      remote_tag = message[(type === 'UAS') ? 'from_tag' : 'to_tag'],\n      id = message.call_id + local_tag + remote_tag;\n\n    early_dialog = this.earlyDialogs[id];\n\n    // Early Dialog\n    if (early) {\n      if (early_dialog) {\n        return true;\n      } else {\n        early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY);\n\n        // Dialog has been successfully created.\n        if(early_dialog.error) {\n          this.logger.error(early_dialog.error);\n          this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n          return false;\n        } else {\n          this.earlyDialogs[id] = early_dialog;\n          return true;\n        }\n      }\n    }\n    // Confirmed Dialog\n    else {\n      // In case the dialog is in _early_ state, update it\n      if (early_dialog) {\n        early_dialog.update(message, type);\n        this.dialog = early_dialog;\n        delete this.earlyDialogs[id];\n        for (var dia in this.earlyDialogs) {\n          this.earlyDialogs[dia].terminate();\n          delete this.earlyDialogs[dia];\n        }\n        return true;\n      }\n\n      // Otherwise, create a _confirmed_ dialog\n      dialog = new SIP.Dialog(this, message, type);\n\n      if(dialog.error) {\n        this.logger.error(dialog.error);\n        this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n        return false;\n      } else {\n        this.to_tag = message.to_tag;\n        this.dialog = dialog;\n        return true;\n      }\n    }\n  },\n\n  /**\n  * Check if Session is ready for a re-INVITE\n  *\n  * @returns {Boolean}\n  */\n  isReadyToReinvite: function() {\n    return this.mediaHandler.isReady() &&\n      !this.dialog.uac_pending_reply &&\n      !this.dialog.uas_pending_reply;\n  },\n\n  /**\n   * Mute\n   */\n  mute: function(options) {\n    var ret = this.mediaHandler.mute(options);\n    if (ret) {\n      this.onmute(ret);\n    }\n  },\n\n  /**\n   * Unmute\n   */\n  unmute: function(options) {\n    var ret = this.mediaHandler.unmute(options);\n    if (ret) {\n      this.onunmute(ret);\n    }\n  },\n\n  /**\n   * Hold\n   */\n  hold: function() {\n\n    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n      throw new SIP.Exceptions.InvalidStateError(this.status);\n    }\n\n    this.mediaHandler.hold();\n\n    // Check if RTCSession is ready to send a reINVITE\n    if (!this.isReadyToReinvite()) {\n      /* If there is a pending 'unhold' action, cancel it and don't queue this one\n       * Else, if there isn't any 'hold' action, add this one to the queue\n       * Else, if there is already a 'hold' action, skip\n       */\n      if (this.pending_actions.isPending('unhold')) {\n        this.pending_actions.pop('unhold');\n      } else if (!this.pending_actions.isPending('hold')) {\n        this.pending_actions.push('hold');\n      }\n      return;\n    } else if (this.local_hold === true) {\n        return;\n    }\n\n    this.onhold('local');\n\n    this.sendReinvite({\n      mangle: function(body){\n\n        // Don't receive media\n        // TODO - This will break for media streams with different directions.\n        if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(body)) {\n          body = body.replace(/(m=[^\\r]*\\r\\n)/g, '$1a=sendonly\\r\\n');\n        } else {\n          body = body.replace(/a=sendrecv\\r\\n/g, 'a=sendonly\\r\\n');\n          body = body.replace(/a=recvonly\\r\\n/g, 'a=inactive\\r\\n');\n        }\n\n        return body;\n      }\n    });\n  },\n\n  /**\n   * Unhold\n   */\n  unhold: function() {\n\n    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n      throw new SIP.Exceptions.InvalidStateError(this.status);\n    }\n\n    this.mediaHandler.unhold();\n\n    if (!this.isReadyToReinvite()) {\n      /* If there is a pending 'hold' action, cancel it and don't queue this one\n       * Else, if there isn't any 'unhold' action, add this one to the queue\n       * Else, if there is already a 'unhold' action, skip\n       */\n      if (this.pending_actions.isPending('hold')) {\n        this.pending_actions.pop('hold');\n      } else if (!this.pending_actions.isPending('unhold')) {\n        this.pending_actions.push('unhold');\n      }\n      return;\n    } else if (this.local_hold === false) {\n      return;\n    }\n\n    this.onunhold('local');\n\n    this.sendReinvite();\n  },\n\n  /**\n   * isOnHold\n   */\n  isOnHold: function() {\n    return {\n      local: this.local_hold,\n      remote: this.remote_hold\n    };\n  },\n\n  /**\n   * In dialog INVITE Reception\n   * @private\n   */\n  receiveReinvite: function(request) {\n    var self = this,\n        contentType = request.getHeader('Content-Type'),\n        hold = true;\n\n    if (request.body) {\n      if (contentType !== 'application/sdp') {\n        this.logger.warn('invalid Content-Type');\n        request.reply(415);\n        return;\n      }\n\n      // Are we holding?\n      hold = (/a=(sendonly|inactive)/).test(request.body);\n\n      this.mediaHandler.setDescription(\n        request.body,\n        /*\n         * onSuccess\n         * SDP Offer is valid\n         */\n        function() {\n          self.mediaHandler.getDescription(\n            function(body) {\n              request.reply(200, null, ['Contact: ' + self.contact], body,\n                function() {\n                  self.status = C.STATUS_WAITING_FOR_ACK;\n                  self.setInvite2xxTimer(request, body);\n                  self.setACKTimer();\n\n                  if (self.remote_hold && !hold) {\n                    self.onunhold('remote');\n                  } else if (!self.remote_hold && hold) {\n                    self.onhold('remote');\n                  }\n                });\n            },\n            function() {\n              request.reply(500);\n            },\n            self.mediaHint\n          );\n        },\n        /*\n         * onFailure\n         * Bad media description\n         */\n        function(e) {\n          self.logger.error(e);\n          request.reply(488);\n        }\n      );\n    }\n  },\n\n  sendReinvite: function(options) {\n    options = options || {};\n\n    var\n      self = this,\n       extraHeaders = (options.extraHeaders || []).slice(),\n       eventHandlers = options.eventHandlers || {},\n       mangle = options.mangle || null;\n\n    if (eventHandlers.succeeded) {\n      this.reinviteSucceeded = eventHandlers.succeeded;\n    } else {\n      this.reinviteSucceeded = function(){\n        SIP.Timers.clearTimeout(self.timers.ackTimer);\n        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n        self.status = C.STATUS_CONFIRMED;\n      };\n    }\n    if (eventHandlers.failed) {\n      this.reinviteFailed = eventHandlers.failed;\n    } else {\n      this.reinviteFailed = function(){};\n    }\n\n    extraHeaders.push('Contact: ' + this.contact);\n    extraHeaders.push('Allow: '+ SIP.Utils.getAllowedMethods(this.ua));\n    extraHeaders.push('Content-Type: application/sdp');\n\n    this.receiveResponse = this.receiveReinviteResponse;\n    //REVISIT\n    this.mediaHandler.getDescription(\n      function(body){\n        if (mangle) {\n          body = mangle(body);\n        }\n\n        self.dialog.sendRequest(self, SIP.C.INVITE, {\n          extraHeaders: extraHeaders,\n          body: body\n        });\n      },\n      function() {\n        if (self.isReadyToReinvite()) {\n          self.onReadyToReinvite();\n        }\n        self.reinviteFailed();\n      },\n      self.mediaHint\n    );\n  },\n\n  receiveRequest: function (request) {\n    switch (request.method) {\n      case SIP.C.BYE:\n        request.reply(200);\n        if(this.status === C.STATUS_CONFIRMED) {\n          this.emit('bye', request);\n          this.terminated(request, SIP.C.causes.BYE);\n        }\n        break;\n      case SIP.C.INVITE:\n        if(this.status === C.STATUS_CONFIRMED) {\n          this.logger.log('re-INVITE received');\n          // Switch these two lines to try re-INVITEs:\n          //this.receiveReinvite(request);\n          request.reply(488, null, ['Warning: 399 sipjs \"Cannot update media description\"']);\n        }\n        break;\n      case SIP.C.INFO:\n        if(this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK) {\n          var body, tone, duration,\n              contentType = request.getHeader('content-type'),\n              reg_tone = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/,\n              reg_duration = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n\n          if (contentType) {\n            if (contentType.match(/^application\\/dtmf-relay/i)) {\n              if (request.body) {\n                body = request.body.split('\\r\\n', 2);\n                if (body.length === 2) {\n                  if (reg_tone.test(body[0])) {\n                    tone = body[0].replace(reg_tone,\"$2\");\n                  }\n                  if (reg_duration.test(body[1])) {\n                    duration = parseInt(body[1].replace(reg_duration,\"$2\"), 10);\n                  }\n                }\n              }\n\n              new DTMF(this, tone, {duration: duration}).init_incoming(request);\n            } else {\n              request.reply(415, null, [\"Accept: application/dtmf-relay\"]);\n            }\n          }\n        }\n        break;\n      case SIP.C.REFER:\n        if(this.status ===  C.STATUS_CONFIRMED) {\n          this.logger.log('REFER received');\n          request.reply(202, 'Accepted');\n          var\n            hasReferListener = this.checkListener('refer'),\n            notifyBody = hasReferListener ?\n              'SIP/2.0 100 Trying' :\n              // RFC 3515.2.4.2: 'the UA MAY decline the request.'\n              'SIP/2.0 603 Declined'\n          ;\n\n          this.sendRequest(SIP.C.NOTIFY, {\n            extraHeaders:[\n              'Event: refer',\n              'Subscription-State: terminated',\n              'Content-Type: message/sipfrag'\n            ],\n            body: notifyBody,\n            receiveResponse: function() {}\n          });\n\n          if (hasReferListener) {\n            this.emit('refer', request);\n          }\n        }\n        break;\n    }\n  },\n\n  /**\n   * Reception of Response for in-dialog INVITE\n   * @private\n   */\n  receiveReinviteResponse: function(response) {\n    var self = this,\n        contentType = response.getHeader('Content-Type');\n\n    if (this.status === C.STATUS_TERMINATED) {\n      return;\n    }\n\n    switch(true) {\n      case /^1[0-9]{2}$/.test(response.status_code):\n        break;\n      case /^2[0-9]{2}$/.test(response.status_code):\n        this.status = C.STATUS_CONFIRMED;\n\n        this.sendRequest(SIP.C.ACK,{cseq:response.cseq});\n\n        if(!response.body) {\n          this.reinviteFailed();\n          break;\n        } else if (contentType !== 'application/sdp') {\n          this.reinviteFailed();\n          break;\n        }\n\n        //REVISIT\n        this.mediaHandler.setDescription(\n          response.body,\n          /*\n           * onSuccess\n           * SDP Answer fits with Offer.\n           */\n          function() {\n            self.reinviteSucceeded();\n          },\n          /*\n           * onFailure\n           * SDP Answer does not fit the Offer.\n           */\n          function() {\n            self.reinviteFailed();\n          }\n        );\n        break;\n      default:\n        this.reinviteFailed();\n    }\n  },\n\n  acceptAndTerminate: function(response, status_code, reason_phrase) {\n    var extraHeaders = [];\n\n    if (status_code) {\n      reason_phrase = reason_phrase || SIP.C.REASON_PHRASE[status_code] || '';\n      extraHeaders.push('Reason: SIP ;cause=' + status_code + '; text=\"' + reason_phrase + '\"');\n    }\n\n    // An error on dialog creation will fire 'failed' event\n    if (this.dialog || this.createDialog(response, 'UAC')) {\n      this.sendRequest(SIP.C.ACK,{cseq: response.cseq});\n      this.sendRequest(SIP.C.BYE, {\n        extraHeaders: extraHeaders\n      });\n    }\n\n    return this;\n  },\n\n  /**\n   * RFC3261 13.3.1.4\n   * Response retransmissions cannot be accomplished by transaction layer\n   *  since it is destroyed when receiving the first 2xx answer\n   */\n  setInvite2xxTimer: function(request, body) {\n    var self = this,\n        timeout = SIP.Timers.T1;\n\n    this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {\n      if (self.status !== C.STATUS_WAITING_FOR_ACK) {\n        return;\n      }\n\n      self.logger.log('no ACK received, attempting to retransmit OK');\n\n      request.reply(200, null, ['Contact: ' + self.contact], body);\n\n      timeout = Math.min(timeout * 2, SIP.Timers.T2);\n\n      self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);\n    }, timeout);\n  },\n\n  /**\n   * RFC3261 14.2\n   * If a UAS generates a 2xx response and never receives an ACK,\n   *  it SHOULD generate a BYE to terminate the dialog.\n   */\n  setACKTimer: function() {\n    var self = this;\n\n    this.timers.ackTimer = SIP.Timers.setTimeout(function() {\n      if(self.status === C.STATUS_WAITING_FOR_ACK) {\n        self.logger.log('no ACK received for an extended period of time, terminating the call');\n        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n        self.sendRequest(SIP.C.BYE);\n        self.terminated(null, SIP.C.causes.NO_ACK);\n      }\n    }, SIP.Timers.TIMER_H);\n  },\n\n  /*\n   * @private\n   */\n  onReadyToReinvite: function() {\n    var action = this.pending_actions.shift();\n\n    if (!action || !this[action.name]) {\n      return;\n    }\n\n    this[action.name]();\n  },\n\n  onTransportError: function() {\n    if (this.status === C.STATUS_CONFIRMED) {\n      this.terminated(null, SIP.C.causes.CONNECTION_ERROR);\n    } else if (this.status !== C.STATUS_TERMINATED) {\n      this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n    }\n  },\n\n  onRequestTimeout: function() {\n    if (this.status === C.STATUS_CONFIRMED) {\n      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n    } else if (this.status !== C.STATUS_TERMINATED) {\n      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n    }\n  },\n\n  onDialogError: function(response) {\n    if (this.status === C.STATUS_CONFIRMED) {\n      this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n    } else if (this.status !== C.STATUS_TERMINATED) {\n      this.failed(response, SIP.C.causes.DIALOG_ERROR);\n    }\n  },\n\n  /**\n   * @private\n   */\n  onhold: function(originator) {\n    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = true;\n    this.emit('hold', { originator: originator });\n  },\n\n  /**\n   * @private\n   */\n  onunhold: function(originator) {\n    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = false;\n    this.emit('unhold', { originator: originator });\n  },\n\n  /*\n   * @private\n   */\n  onmute: function(options) {\n    this.emit('muted', {\n      audio: options.audio,\n      video: options.video\n    });\n  },\n\n  /*\n   * @private\n   */\n  onunmute: function(options) {\n    this.emit('unmuted', {\n      audio: options.audio,\n      video: options.video\n    });\n  },\n\n  failed: function(response, cause) {\n    this.close();\n    return this.emit('failed', response, cause);\n  },\n\n  rejected: function(response, cause) {\n    this.close();\n    return this.emit('rejected',\n      response || null,\n      cause\n    );\n  },\n\n  canceled: function() {\n    this.close();\n    return this.emit('cancel');\n  },\n\n  accepted: function(response, cause) {\n    cause = cause || (response && SIP.C.REASON_PHRASE[response.status_code]) || '';\n\n    this.startTime = new Date();\n\n    return this.emit('accepted', response, cause);\n  },\n\n  terminated: function(message, cause) {\n    this.endTime = new Date();\n\n    this.close();\n    return this.emit('terminated', {\n      message: message || null,\n      cause: cause || null\n    });\n  },\n\n  connecting: function(request) {\n    return this.emit('connecting', { request: request });\n  }\n};\n\nSession.C = C;\nSIP.Session = Session;\n\n\nInviteServerContext = function(ua, request) {\n  var expires,\n    self = this,\n    contentType = request.getHeader('Content-Type'),\n    contentDisp = request.parseHeader('Content-Disposition');\n\n  // Check body and content type\n  if ((!contentDisp && contentType !== 'application/sdp') || (contentDisp && contentDisp.type === 'render')) {\n    this.renderbody = request.body;\n    this.rendertype = contentType;\n  } else if (contentType !== 'application/sdp' && (contentDisp && contentDisp.type === 'session')) {\n    request.reply(415);\n    //TODO: instead of 415, pass off to the media handler, who can then decide if we can use it\n    return;\n  }\n\n  //TODO: move this into media handler\n  SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);\n  SIP.Hacks.AllBrowsers.maskDtls(request);\n\n  SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);\n  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);\n\n  this.status = C.STATUS_INVITE_RECEIVED;\n  this.from_tag = request.from_tag;\n  this.id = request.call_id + this.from_tag;\n  this.request = request;\n  this.contact = this.ua.contact.toString();\n\n  this.receiveNonInviteResponse = function () {}; // intentional no-op\n\n  this.logger = ua.getLogger('sip.inviteservercontext', this.id);\n\n  //Save the session into the ua sessions collection.\n  this.ua.sessions[this.id] = this;\n\n  //Get the Expires header value if exists\n  if(request.hasHeader('expires')) {\n    expires = request.getHeader('expires') * 1000;\n  }\n\n  //Set 100rel if necessary\n  function set100rel(h,c) {\n    if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {\n      self.rel100 = c;\n    }\n  }\n  set100rel('require', SIP.C.supported.REQUIRED);\n  set100rel('supported', SIP.C.supported.SUPPORTED);\n\n  /* Set the to_tag before\n   * replying a response code that will create a dialog.\n   */\n  request.to_tag = SIP.Utils.newTag();\n\n  // An error on dialog creation will fire 'failed' event\n  if(!this.createDialog(request, 'UAS', true)) {\n    request.reply(500, 'Missing Contact header field');\n    return;\n  }\n\n  //Initialize Media Session\n  this.mediaHandler = this.mediaHandlerFactory(this, {\n    RTCConstraints: {\"optional\": [{'DtlsSrtpKeyAgreement': 'true'}]}\n  });\n\n  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n  }\n\n  function fireNewSession() {\n    var options = {extraHeaders: ['Contact: ' + self.contact]};\n\n    if (self.rel100 !== SIP.C.supported.REQUIRED) {\n      self.progress(options);\n    }\n    self.status = C.STATUS_WAITING_FOR_ANSWER;\n\n    // Set userNoAnswerTimer\n    self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function() {\n      request.reply(408);\n      self.failed(request, SIP.C.causes.NO_ANSWER);\n    }, self.ua.configuration.noAnswerTimeout);\n\n    /* Set expiresTimer\n     * RFC3261 13.3.1\n     */\n    if (expires) {\n      self.timers.expiresTimer = SIP.Timers.setTimeout(function() {\n        if(self.status === C.STATUS_WAITING_FOR_ANSWER) {\n          request.reply(487);\n          self.failed(request, SIP.C.causes.EXPIRES);\n        }\n      }, expires);\n    }\n\n    self.emit('invite',request);\n  }\n\n  if (!request.body || this.renderbody) {\n    SIP.Timers.setTimeout(fireNewSession, 0);\n  } else {\n    this.hasOffer = true;\n    this.mediaHandler.setDescription(\n      request.body,\n      /*\n       * onSuccess\n       * SDP Offer is valid. Fire UA newRTCSession\n       */\n      fireNewSession,\n      /*\n       * onFailure\n       * Bad media description\n       */\n      function(e) {\n        self.logger.warn('invalid SDP');\n        self.logger.warn(e);\n        request.reply(488);\n      }\n    );\n  }\n};\n\nInviteServerContext.prototype = {\n  reject: function(options) {\n    // Check Session Status\n    if (this.status === C.STATUS_TERMINATED) {\n      throw new SIP.Exceptions.InvalidStateError(this.status);\n    }\n\n    this.logger.log('rejecting RTCSession');\n\n    SIP.ServerContext.prototype.reject.apply(this, [options]);\n    return this.terminated();\n  },\n\n  terminate: function(options) {\n    options = options || {};\n\n    var\n    extraHeaders = (options.extraHeaders || []).slice(),\n    body = options.body,\n    dialog,\n    self = this;\n\n    if (this.status === C.STATUS_WAITING_FOR_ACK &&\n       this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n      dialog = this.dialog;\n\n      this.receiveRequest = function(request) {\n        if (request.method === SIP.C.ACK) {\n          this.request(SIP.C.BYE, {\n            extraHeaders: extraHeaders,\n            body: body\n          });\n          dialog.terminate();\n        }\n      };\n\n      this.request.server_transaction.on('stateChanged', function(){\n        if (this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n          this.request = new SIP.OutgoingRequest(\n            SIP.C.BYE,\n            this.dialog.remote_target,\n            this.ua,\n            {\n              'cseq': this.dialog.local_seqnum+=1,\n              'call_id': this.dialog.id.call_id,\n              'from_uri': this.dialog.local_uri,\n              'from_tag': this.dialog.id.local_tag,\n              'to_uri': this.dialog.remote_uri,\n              'to_tag': this.dialog.id.remote_tag,\n              'route_set': this.dialog.route_set\n            },\n            extraHeaders,\n            body\n          );\n\n          new SIP.RequestSender(\n            {\n              request: this.request,\n              onRequestTimeout: function() {\n                self.onRequestTimeout();\n              },\n              onTransportError: function() {\n                self.onTransportError();\n              },\n              receiveResponse: function() {\n                return;\n              }\n            },\n            this.ua\n          ).send();\n          dialog.terminate();\n        }\n      });\n\n      this.emit('bye', this.request);\n      this.terminated();\n\n      // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)\n      this.dialog = dialog;\n\n      // Restore the dialog into 'ua' so the ACK can reach 'this' session\n      this.ua.dialogs[dialog.id.toString()] = dialog;\n\n    } else if (this.status === C.STATUS_CONFIRMED) {\n      this.bye(options);\n    } else {\n      this.reject(options);\n    }\n\n    return this;\n  },\n\n  /*\n   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n   */\n  progress: function (options) {\n    options = options || {};\n    var\n      statusCode = options.statusCode || 180,\n      reasonPhrase = options.reasonPhrase,\n      extraHeaders = (options.extraHeaders || []).slice(),\n      body = options.body,\n      response;\n\n    if (statusCode < 100 || statusCode > 199) {\n      throw new TypeError('Invalid statusCode: ' + statusCode);\n    }\n\n    if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n      return this;\n    }\n\n    function do100rel() {\n      statusCode = options.statusCode || 183;\n\n      // Set status and add extra headers\n      this.status = C.STATUS_WAITING_FOR_PRACK;\n      extraHeaders.push('Contact: '+ this.contact);\n      extraHeaders.push('Require: 100rel');\n      extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000));\n\n      // Save media hint for later (referred sessions)\n      this.mediaHint = options.media;\n\n      // Get the session description to add to preaccept with\n      this.mediaHandler.getDescription(\n        // Success\n        function succ(body) {\n          if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n            return;\n          }\n\n          this.early_sdp = body;\n          this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true;\n\n          // Retransmit until we get a response or we time out (see prackTimer below)\n          var timeout = SIP.Timers.T1;\n          this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {\n            this.request.reply(statusCode, null, extraHeaders, body);\n            timeout *= 2;\n            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);\n          }.bind(this), timeout);\n\n          // Timeout and reject INVITE if no response\n          this.timers.prackTimer = SIP.Timers.setTimeout(function () {\n            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {\n              return;\n            }\n\n            this.logger.log('no PRACK received, rejecting the call');\n            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n            this.request.reply(504);\n            this.terminated(null, SIP.C.causes.NO_PRACK);\n          }.bind(this), SIP.Timers.T1 * 64);\n\n          // Send the initial response\n          response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n          this.emit('progress', response, reasonPhrase);\n        }.bind(this),\n\n        // Failure\n        function fail() {\n          this.failed(null, SIP.C.causes.WEBRTC_ERROR);\n        }.bind(this),\n\n        // Media hint:\n        options.media);\n    } // end do100rel\n\n    function normalReply() {\n      response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n      this.emit('progress', response, reasonPhrase);\n    }\n\n    if (options.statusCode !== 100 &&\n        (this.rel100 === SIP.C.supported.REQUIRED ||\n         (this.rel100 === SIP.C.supported.SUPPORTED && options.rel100) ||\n         (this.rel100 === SIP.C.supported.SUPPORTED && (this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)))) {\n      do100rel.apply(this);\n    } else {\n      normalReply.apply(this);\n    }\n    return this;\n  },\n\n  /*\n   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n   */\n  accept: function(options) {\n    options = options || {};\n    options = SIP.Utils.desugarSessionOptions(options);\n    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n    this.mediaHint = options.media;\n\n    // commented out now-unused hold-related variables for jshint. See below. JMF 2014-1-21\n    var\n      //idx, length, hasAudio, hasVideo,\n      self = this,\n      request = this.request,\n      extraHeaders = (options.extraHeaders || []).slice(),\n    //mediaStream = options.mediaStream || null,\n      sdpCreationSucceeded = function(body) {\n        var\n          response,\n          // run for reply success callback\n          replySucceeded = function() {\n            self.status = C.STATUS_WAITING_FOR_ACK;\n\n            self.setInvite2xxTimer(request, body);\n            self.setACKTimer();\n          },\n\n          // run for reply failure callback\n          replyFailed = function() {\n            self.failed(null, SIP.C.causes.CONNECTION_ERROR);\n          };\n\n        // Chrome might call onaddstream before accept() is called, which means\n        // mediaHandler.render() was called without a renderHint, so we need to\n        // re-render now that mediaHint.render has been set.\n        //\n        // Chrome seems to be in the right regarding this, see\n        // http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-onaddstream\n        self.mediaHandler.render();\n\n        extraHeaders.push('Contact: ' + self.contact);\n\n        if(!self.hasOffer) {\n          self.hasOffer = true;\n        } else {\n          self.hasAnswer = true;\n        }\n        response = request.reply(200, null, extraHeaders,\n                      body,\n                      replySucceeded,\n                      replyFailed\n                     );\n        if (self.status !== C.STATUS_TERMINATED) { // Didn't fail\n          self.accepted(response, SIP.C.REASON_PHRASE[200]);\n        }\n      },\n\n      sdpCreationFailed = function() {\n        if (self.status === C.STATUS_TERMINATED) {\n          return;\n        }\n        // TODO - fail out on error\n        //response = request.reply(480);\n        //self.failed(response, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n        self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n      };\n\n    // Check Session Status\n    if (this.status === C.STATUS_WAITING_FOR_PRACK) {\n      this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;\n      return this;\n    } else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {\n      this.status = C.STATUS_ANSWERED;\n    } else if (this.status !== C.STATUS_EARLY_MEDIA) {\n      throw new SIP.Exceptions.InvalidStateError(this.status);\n    }\n\n    // An error on dialog creation will fire 'failed' event\n    if(!this.createDialog(request, 'UAS')) {\n      request.reply(500, 'Missing Contact header field');\n      return this;\n    }\n\n    SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer);\n\n    // this hold-related code breaks FF accepting new calls - JMF 2014-1-21\n    /*\n    length = this.getRemoteStreams().length;\n\n    for (idx = 0; idx < length; idx++) {\n      if (this.mediaHandler.getRemoteStreams()[idx].getVideoTracks().length > 0) {\n        hasVideo = true;\n      }\n      if (this.mediaHandler.getRemoteStreams()[idx].getAudioTracks().length > 0) {\n        hasAudio = true;\n      }\n    }\n\n    if (!hasAudio && this.mediaConstraints.audio === true) {\n      this.mediaConstraints.audio = false;\n      if (mediaStream) {\n        length = mediaStream.getAudioTracks().length;\n        for (idx = 0; idx < length; idx++) {\n          mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);\n        }\n      }\n    }\n\n    if (!hasVideo && this.mediaConstraints.video === true) {\n      this.mediaConstraints.video = false;\n      if (mediaStream) {\n        length = mediaStream.getVideoTracks().length;\n        for (idx = 0; idx < length; idx++) {\n          mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);\n        }\n      }\n    }\n    */\n\n    if (this.status === C.STATUS_EARLY_MEDIA) {\n      sdpCreationSucceeded();\n    } else {\n      this.mediaHandler.getDescription(\n        sdpCreationSucceeded,\n        sdpCreationFailed,\n        self.mediaHint\n      );\n    }\n\n    return this;\n  },\n\n  receiveRequest: function(request) {\n\n    // ISC RECEIVE REQUEST\n\n    function confirmSession() {\n      var contentType;\n\n      SIP.Timers.clearTimeout(this.timers.ackTimer);\n      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n      this.status = C.STATUS_CONFIRMED;\n      this.unmute();\n\n      // TODO - this logic assumes Content-Disposition defaults\n      contentType = request.getHeader('Content-Type');\n      if (contentType !== 'application/sdp') {\n        this.renderbody = request.body;\n        this.rendertype = contentType;\n      }\n    }\n\n    switch(request.method) {\n    case SIP.C.CANCEL:\n      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL\n       * was in progress and that the UAC MAY continue with the session established by\n       * any 2xx response, or MAY terminate with BYE. SIP does continue with the\n       * established session. So the CANCEL is processed only if the session is not yet\n       * established.\n       */\n\n      /*\n       * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the\n       *request opening the session.\n       */\n      if(this.status === C.STATUS_WAITING_FOR_ANSWER ||\n         this.status === C.STATUS_WAITING_FOR_PRACK ||\n         this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||\n         this.status === C.STATUS_EARLY_MEDIA ||\n         this.status === C.STATUS_ANSWERED) {\n\n        this.status = C.STATUS_CANCELED;\n        this.request.reply(487);\n        this.canceled(request);\n        this.rejected(request, SIP.C.causes.CANCELED);\n        this.failed(request, SIP.C.causes.CANCELED);\n      }\n      break;\n    case SIP.C.ACK:\n      if(this.status === C.STATUS_WAITING_FOR_ACK) {\n        if (!this.hasAnswer) {\n          if(request.body && request.getHeader('content-type') === 'application/sdp') {\n            // ACK contains answer to an INVITE w/o SDP negotiation\n            SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);\n            SIP.Hacks.AllBrowsers.maskDtls(request);\n\n            this.hasAnswer = true;\n            this.mediaHandler.setDescription(\n              request.body,\n              /*\n               * onSuccess\n               * SDP Answer fits with Offer. Media will start\n               */\n              confirmSession.bind(this),\n              /*\n               * onFailure\n               * SDP Answer does not fit the Offer.  Terminate the call.\n               */\n              function (e) {\n                this.logger.warn(e);\n                this.terminate({\n                  statusCode: '488',\n                  reasonPhrase: 'Bad Media Description'\n                });\n                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n              }.bind(this)\n            );\n          } else if (this.early_sdp) {\n            confirmSession.apply(this);\n          } else {\n            //TODO: Pass to mediahandler\n            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n          }\n        } else {\n          confirmSession.apply(this);\n        }\n      }\n      break;\n    case SIP.C.PRACK:\n      if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n        //localMedia = session.mediaHandler.localMedia;\n        if(!this.hasAnswer) {\n          if(request.body && request.getHeader('content-type') === 'application/sdp') {\n            this.hasAnswer = true;\n            this.mediaHandler.setDescription(\n              request.body,\n              /*\n               * onSuccess\n               * SDP Answer fits with Offer. Media will start\n               */\n              function() {\n                SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n                SIP.Timers.clearTimeout(this.timers.prackTimer);\n                request.reply(200);\n                if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n                  this.status = C.STATUS_EARLY_MEDIA;\n                  this.accept();\n                }\n                this.status = C.STATUS_EARLY_MEDIA;\n                //REVISIT\n                this.mute();\n              }.bind(this),\n              function (e) {\n                //TODO: Send to media handler\n                this.logger.warn(e);\n                this.terminate({\n                  statusCode: '488',\n                  reasonPhrase: 'Bad Media Description'\n                });\n                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n              }.bind(this)\n            );\n          } else {\n            this.terminate({\n              statusCode: '488',\n              reasonPhrase: 'Bad Media Description'\n            });\n            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n          }\n        } else {\n          SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n          SIP.Timers.clearTimeout(this.timers.prackTimer);\n          request.reply(200);\n\n          if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n            this.status = C.STATUS_EARLY_MEDIA;\n            this.accept();\n          }\n          this.status = C.STATUS_EARLY_MEDIA;\n          //REVISIT\n          this.mute();\n        }\n      } else if(this.status === C.STATUS_EARLY_MEDIA) {\n        request.reply(200);\n      }\n      break;\n    default:\n      Session.prototype.receiveRequest.apply(this, [request]);\n      break;\n    }\n  }\n};\n\nSIP.InviteServerContext = InviteServerContext;\n\nInviteClientContext = function(ua, target, options) {\n  options = options || {};\n  var requestParams, iceServers,\n    extraHeaders = (options.extraHeaders || []).slice(),\n    stunServers = options.stunServers || null,\n    turnServers = options.turnServers || null,\n    isMediaSupported = ua.configuration.mediaHandlerFactory.isSupported;\n\n  // Check WebRTC support\n  if (isMediaSupported && !isMediaSupported()) {\n    throw new SIP.Exceptions.NotSupportedError('Media not supported');\n  }\n\n  this.RTCConstraints = options.RTCConstraints || {};\n  this.inviteWithoutSdp = options.inviteWithoutSdp || false;\n\n  // Set anonymous property\n  this.anonymous = options.anonymous || false;\n\n  // Custom data to be sent either in INVITE or in ACK\n  this.renderbody = options.renderbody || null;\n  this.rendertype = options.rendertype || 'text/plain';\n\n  requestParams = {from_tag: this.from_tag};\n\n  /* Do not add ;ob in initial forming dialog requests if the registration over\n   *  the current connection got a GRUU URI.\n   */\n  this.contact = ua.contact.toString({\n    anonymous: this.anonymous,\n    outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu\n  });\n\n  if (this.anonymous) {\n    requestParams.from_displayName = 'Anonymous';\n    requestParams.from_uri = 'sip:anonymous@anonymous.invalid';\n\n    extraHeaders.push('P-Preferred-Identity: '+ ua.configuration.uri.toString());\n    extraHeaders.push('Privacy: id');\n  }\n  extraHeaders.push('Contact: '+ this.contact);\n  extraHeaders.push('Allow: '+ SIP.Utils.getAllowedMethods(ua));\n  if (!this.inviteWithoutSdp) {\n    extraHeaders.push('Content-Type: application/sdp');\n  } else if (this.renderbody) {\n    extraHeaders.push('Content-Type: ' + this.rendertype);\n    extraHeaders.push('Content-Disposition: render;handling=optional');\n  }\n\n  if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {\n    extraHeaders.push('Require: 100rel');\n  }\n\n  options.extraHeaders = extraHeaders;\n  options.params = requestParams;\n\n  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);\n  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);\n\n  // Check Session Status\n  if (this.status !== C.STATUS_NULL) {\n    throw new SIP.Exceptions.InvalidStateError(this.status);\n  }\n\n  // Session parameter initialization\n  this.from_tag = SIP.Utils.newTag();\n\n  // OutgoingSession specific parameters\n  this.isCanceled = false;\n  this.received_100 = false;\n\n  this.method = SIP.C.INVITE;\n\n  this.receiveNonInviteResponse = this.receiveResponse;\n  this.receiveResponse = this.receiveInviteResponse;\n\n  this.logger = ua.getLogger('sip.inviteclientcontext');\n\n  if (stunServers) {\n    iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);\n    if (!iceServers) {\n      throw new TypeError('Invalid stunServers: '+ stunServers);\n    } else {\n      this.stunServers = iceServers;\n    }\n  }\n\n  if (turnServers) {\n    iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);\n    if (!iceServers) {\n      throw new TypeError('Invalid turnServers: '+ turnServers);\n    } else {\n      this.turnServers = iceServers;\n    }\n  }\n\n  ua.applicants[this] = this;\n\n  this.id = this.request.call_id + this.from_tag;\n\n  //Initialize Media Session\n  this.mediaHandler = this.mediaHandlerFactory(this, {\n    RTCConstraints: this.RTCConstraints,\n    stunServers: this.stunServers,\n    turnServers: this.turnServers\n  });\n\n  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {\n    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);\n    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);\n  }\n};\n\nInviteClientContext.prototype = {\n  /*\n   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n   */\n  invite: function (options) {\n    var self = this;\n    options = options || {};\n\n    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);\n    this.mediaHint = options.media;\n\n    //Save the session into the ua sessions collection.\n    //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway\n    this.ua.sessions[this.id] = this;\n\n    //Note: due to the way Firefox handles gUM calls, it is recommended to make the gUM call at the app level\n    // and hand sip.js a stream as the mediaHint\n    if (this.inviteWithoutSdp) {\n      //just send an invite with no sdp...\n      this.request.body = self.renderbody;\n      this.status = C.STATUS_INVITE_SENT;\n      this.send();\n    } else {\n      this.mediaHandler.getDescription(\n        function onSuccess(offer) {\n          if (self.isCanceled || self.status === C.STATUS_TERMINATED) {\n            return;\n          }\n          self.hasOffer = true;\n          self.request.body = offer;\n          self.status = C.STATUS_INVITE_SENT;\n          self.send();\n        },\n        function onFailure() {\n          if (self.status === C.STATUS_TERMINATED) {\n            return;\n          }\n          // TODO...fail out\n          //self.failed(null, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);\n          //self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n          self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n        },\n        self.mediaHint\n      );\n    }\n\n    return this;\n  },\n\n  receiveInviteResponse: function(response) {\n    var cause, //localMedia,\n      session = this,\n      id = response.call_id + response.from_tag + response.to_tag,\n      extraHeaders = [],\n      options = {};\n\n    if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {\n      return;\n    }\n\n    if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {\n      if (id !== this.dialog.id.toString() ) {\n        if (!this.createDialog(response, 'UAC', true)) {\n          return;\n        }\n        this.earlyDialogs[id].sendRequest(this, SIP.C.ACK,\n                                          {\n                                            body: SIP.Utils.generateFakeSDP(response.body)\n                                          });\n        this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);\n\n        /* NOTE: This fails because the forking proxy does not recognize that an unanswerable\n         * leg (due to peerConnection limitations) has been answered first. If your forking\n         * proxy does not hang up all unanswered branches on the first branch answered, remove this.\n         */\n        if(this.status !== C.STATUS_CONFIRMED) {\n          this.failed(response, SIP.C.causes.WEBRTC_ERROR);\n        }\n        return;\n      } else if (this.status === C.STATUS_CONFIRMED) {\n        this.sendRequest(SIP.C.ACK,{cseq: response.cseq});\n        return;\n      } else if (!this.hasAnswer) {\n        // invite w/o sdp is waiting for callback\n        //an invite with sdp must go on, and hasAnswer is true\n        return;\n      }\n    }\n\n    if (this.dialog && response.status_code < 200) {\n      /*\n        Early media has been set up with at least one other different branch,\n        but a final 2xx response hasn't been received\n      */\n      if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {\n        return;\n      }\n\n      extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n      this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n\n      this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n        extraHeaders: extraHeaders,\n        body: SIP.Utils.generateFakeSDP(response.body)\n      });\n      return;\n    }\n\n    // Proceed to cancellation if the user requested.\n    if(this.isCanceled) {\n      if(response.status_code >= 100 && response.status_code < 200) {\n        this.request.cancel(this.cancelReason);\n        this.canceled(null);\n      } else if(response.status_code >= 200 && response.status_code < 299) {\n        this.acceptAndTerminate(response);\n        this.emit('bye', this.request);\n      }\n      return;\n    }\n\n    switch(true) {\n      case /^100$/.test(response.status_code):\n        this.received_100 = true;\n        break;\n      case (/^1[0-9]{2}$/.test(response.status_code)):\n        // Do nothing with 1xx responses without To tag.\n        if(!response.to_tag) {\n          this.logger.warn('1xx response received without to tag');\n          break;\n        }\n\n        // Create Early Dialog if 1XX comes with contact\n        if(response.hasHeader('contact')) {\n          // An error on dialog creation will fire 'failed' event\n          if (!this.createDialog(response, 'UAC', true)) {\n            break;\n          }\n        }\n\n        this.status = C.STATUS_1XX_RECEIVED;\n\n        if(response.hasHeader('require') &&\n           response.getHeader('require').indexOf('100rel') !== -1) {\n\n          // Do nothing if this.dialog is already confirmed\n          if (this.dialog || !this.earlyDialogs[id]) {\n            break;\n          }\n\n          if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n              (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {\n            return;\n          }\n\n          SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);\n          SIP.Hacks.AllBrowsers.maskDtls(response);\n\n          if (!response.body) {\n            extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n            this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n              extraHeaders: extraHeaders\n            });\n            this.emit('progress', response);\n\n          } else if (this.hasOffer) {\n            if (!this.createDialog(response, 'UAC')) {\n              break;\n            }\n            this.hasAnswer = true;\n            this.mediaHandler.setDescription(\n              response.body,\n              /*\n               * onSuccess\n               * SDP Answer fits with Offer. Media will start\n               */\n              function () {\n                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n                session.dialog.pracked.push(response.getHeader('rseq'));\n\n                session.sendRequest(SIP.C.PRACK, {\n                  extraHeaders: extraHeaders,\n                  receiveResponse: function() {}\n                });\n                session.status = C.STATUS_EARLY_MEDIA;\n                session.mute();\n                session.emit('progress', response);\n                /*\n                if (session.status === C.STATUS_EARLY_MEDIA) {\n                  localMedia = session.mediaHandler.localMedia;\n                  if (localMedia.getAudioTracks().length > 0) {\n                    localMedia.getAudioTracks()[0].enabled = false;\n                  }\n                  if (localMedia.getVideoTracks().length > 0) {\n                    localMedia.getVideoTracks()[0].enabled = false;\n                  }\n                }*/\n              },\n              /*\n               * onFailure\n               * SDP Answer does not fit the Offer. Accept the call and Terminate.\n               */\n              function(e) {\n                session.logger.warn(e);\n                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n              }\n            );\n          } else {\n            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n            this.earlyDialogs[id].mediaHandler.setDescription(\n              response.body,\n              function onSuccess() {\n                session.earlyDialogs[id].mediaHandler.getDescription(\n                  function onSuccess(sdp) {\n                    extraHeaders.push('Content-Type: application/sdp');\n                    extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n                    session.earlyDialogs[id].sendRequest(session, SIP.C.PRACK, {\n                      extraHeaders: extraHeaders,\n                      body: sdp\n                    });\n                    session.status = C.STATUS_EARLY_MEDIA;\n                    session.emit('progress', response);\n                  },\n                  function onFailure() {\n                    session.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n                    if (session.status === C.STATUS_TERMINATED) {\n                      return;\n                    }\n                    // TODO - fail out on error\n                    // session.failed(gum error);\n                    session.failed(null, SIP.C.causes.WEBRTC_ERROR);\n                  },\n                  session.mediaHint\n                );\n              },\n              function onFailure(e) {\n                session.earlyDialogs[id].pracked.splice(session.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')), 1);\n                // Could not set remote description\n                session.logger.warn('invalid SDP');\n                session.logger.warn(e);\n              }\n            );\n          }\n        } else {\n          this.emit('progress', response);\n        }\n        break;\n      case /^2[0-9]{2}$/.test(response.status_code):\n        var cseq = this.request.cseq + ' ' + this.request.method;\n        if (cseq !== response.getHeader('cseq')) {\n          break;\n        }\n\n        if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {\n          this.status = C.STATUS_CONFIRMED;\n          this.unmute();\n          /*localMedia = this.mediaHandler.localMedia;\n          if (localMedia.getAudioTracks().length > 0) {\n            localMedia.getAudioTracks()[0].enabled = true;\n          }\n          if (localMedia.getVideoTracks().length > 0) {\n            localMedia.getVideoTracks()[0].enabled = true;\n          }*/\n          options = {};\n          if (this.renderbody) {\n            extraHeaders.push('Content-Type: ' + this.rendertype);\n            options.extraHeaders = extraHeaders;\n            options.body = this.renderbody;\n          }\n          options.cseq = response.cseq;\n          this.sendRequest(SIP.C.ACK, options);\n          this.accepted(response);\n          break;\n        }\n        // Do nothing if this.dialog is already confirmed\n        if (this.dialog) {\n          break;\n        }\n\n        SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);\n        SIP.Hacks.AllBrowsers.maskDtls(response);\n\n        // This is an invite without sdp\n        if (!this.hasOffer) {\n          if (this.earlyDialogs[id] && this.earlyDialogs[id].mediaHandler.localMedia) {\n            //REVISIT\n            this.hasOffer = true;\n            this.hasAnswer = true;\n            this.mediaHandler = this.earlyDialogs[id].mediaHandler;\n            if (!this.createDialog(response, 'UAC')) {\n              break;\n            }\n            this.status = C.STATUS_CONFIRMED;\n            this.sendRequest(SIP.C.ACK, {cseq:response.cseq});\n\n            this.unmute();\n            /*\n            localMedia = session.mediaHandler.localMedia;\n            if (localMedia.getAudioTracks().length > 0) {\n              localMedia.getAudioTracks()[0].enabled = true;\n            }\n            if (localMedia.getVideoTracks().length > 0) {\n              localMedia.getVideoTracks()[0].enabled = true;\n            }*/\n            this.accepted(response);\n          } else {\n            if(!response.body) {\n              this.acceptAndTerminate(response, 400, 'Missing session description');\n              this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n              break;\n            }\n            if (!this.createDialog(response, 'UAC')) {\n              break;\n            }\n            this.hasOffer = true;\n            this.mediaHandler.setDescription(\n              response.body,\n              function onSuccess() {\n                session.mediaHandler.getDescription(\n                  function onSuccess(sdp) {\n                    //var localMedia;\n                    if(session.isCanceled || session.status === C.STATUS_TERMINATED) {\n                      return;\n                    }\n\n                    sdp = SIP.Hacks.Firefox.hasMissingCLineInSDP(sdp);\n\n                    session.status = C.STATUS_CONFIRMED;\n                    session.hasAnswer = true;\n\n                    session.unmute();\n                    /*localMedia = session.mediaHandler.localMedia;\n                    if (localMedia.getAudioTracks().length > 0) {\n                      localMedia.getAudioTracks()[0].enabled = true;\n                    }\n                    if (localMedia.getVideoTracks().length > 0) {\n                      localMedia.getVideoTracks()[0].enabled = true;\n                    }*/\n                    session.sendRequest(SIP.C.ACK,{\n                      body: sdp,\n                      extraHeaders:['Content-Type: application/sdp'],\n                      cseq:response.cseq\n                    });\n                    session.accepted(response);\n                  },\n                  function onFailure() {\n                    // TODO do something here\n                    session.logger.warn(\"there was a problem\");\n                  },\n                  session.mediaHint\n                );\n              },\n              function onFailure(e) {\n                session.logger.warn('invalid SDP');\n                session.logger.warn(e);\n                response.reply(488);\n              }\n            );\n          }\n        } else if (this.hasAnswer){\n          if (this.renderbody) {\n            extraHeaders.push('Content-Type: ' + session.rendertype);\n            options.extraHeaders = extraHeaders;\n            options.body = this.renderbody;\n          }\n          this.sendRequest(SIP.C.ACK, options);\n        } else {\n          if(!response.body) {\n            this.acceptAndTerminate(response, 400, 'Missing session description');\n            this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n            break;\n          }\n          if (!this.createDialog(response, 'UAC')) {\n            break;\n          }\n          this.hasAnswer = true;\n          this.mediaHandler.setDescription(\n            response.body,\n            /*\n             * onSuccess\n             * SDP Answer fits with Offer. Media will start\n             */\n            function() {\n              var options = {};//,localMedia;\n              session.status = C.STATUS_CONFIRMED;\n              session.unmute();\n              /*localMedia = session.mediaHandler.localMedia;\n              if (localMedia.getAudioTracks().length > 0) {\n                localMedia.getAudioTracks()[0].enabled = true;\n              }\n              if (localMedia.getVideoTracks().length > 0) {\n                localMedia.getVideoTracks()[0].enabled = true;\n              }*/\n              if (session.renderbody) {\n                extraHeaders.push('Content-Type: ' + session.rendertype);\n                options.extraHeaders = extraHeaders;\n                options.body = session.renderbody;\n              }\n              options.cseq = response.cseq;\n              session.sendRequest(SIP.C.ACK, options);\n              session.accepted(response);\n            },\n            /*\n             * onFailure\n             * SDP Answer does not fit the Offer. Accept the call and Terminate.\n             */\n            function(e) {\n              session.logger.warn(e);\n              session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n              session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n            }\n          );\n        }\n        break;\n      default:\n        cause = SIP.Utils.sipErrorCause(response.status_code);\n        this.failed(response, cause);\n        this.rejected(response, cause);\n    }\n  },\n\n  cancel: function(options) {\n    options = options || {};\n\n    var\n    statusCode = options.status_code,\n    reasonPhrase = options.reasonPhrase,\n    cancel_reason;\n\n    // Check Session Status\n    if (this.status === C.STATUS_TERMINATED) {\n      throw new SIP.Exceptions.InvalidStateError(this.status);\n    }\n\n    this.logger.log('canceling RTCSession');\n\n    if (statusCode && (statusCode < 200 || statusCode >= 700)) {\n      throw new TypeError('Invalid status_code: '+ statusCode);\n    } else if (statusCode) {\n      reasonPhrase = reasonPhrase || SIP.C.REASON_PHRASE[statusCode] || '';\n      cancel_reason = 'SIP ;cause=' + statusCode + ' ;text=\"' + reasonPhrase + '\"';\n    }\n\n    // Check Session Status\n    if (this.status === C.STATUS_NULL ||\n        (this.status === C.STATUS_INVITE_SENT && !this.received_100)) {\n      this.isCanceled = true;\n      this.cancelReason = cancel_reason;\n    } else if (this.status === C.STATUS_INVITE_SENT ||\n               this.status === C.STATUS_1XX_RECEIVED ||\n               this.status === C.STATUS_EARLY_MEDIA) {\n      this.request.cancel(cancel_reason);\n    }\n\n    return this.canceled();\n  },\n\n  terminate: function(options) {\n    if (this.status === C.STATUS_TERMINATED) {\n      return this;\n    }\n\n    if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {\n      this.bye(options);\n    } else {\n      this.cancel(options);\n    }\n\n    return this.terminated();\n  },\n\n  receiveRequest: function(request) {\n    // ICC RECEIVE REQUEST\n\n    // Reject CANCELs\n    if (request.method === SIP.C.CANCEL) {\n      // TODO; make this a switch when it gets added\n    }\n\n    if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {\n      SIP.Timers.clearTimeout(this.timers.ackTimer);\n      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n      this.status = C.STATUS_CONFIRMED;\n      this.unmute();\n\n      this.accepted();\n    }\n\n    return Session.prototype.receiveRequest.apply(this, [request]);\n  }\n};\n\nSIP.InviteClientContext = InviteClientContext;\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Session.js\n ** module id = 25\n ** module chunks = 0\n **/","\n/**\n * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)\n */\n\n/**\n * @augments SIP\n * @class Class creating a SIP Subscription.\n */\nmodule.exports = function (SIP) {\nSIP.Subscription = function (ua, target, event, options) {\n  var events;\n\n  options = options || {};\n  options.extraHeaders = (options.extraHeaders || []).slice();\n\n  events = ['notify'];\n  this.id = null;\n  this.state = 'init';\n\n  if (!event) {\n    throw new TypeError('Event necessary to create a subscription.');\n  } else {\n    //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?\n    //The check may need to/should probably occur on the other side,\n    this.event = event;\n  }\n\n  if(typeof options.expires !== 'number'){\n    ua.logger.warn('expires must be a number. Using default of 3600.');\n    this.expires = 3600;\n  } else {\n    this.expires = options.expires;\n  }\n\n  options.extraHeaders.push('Event: ' + this.event);\n  options.extraHeaders.push('Expires: ' + this.expires);\n\n  if (options.body) {\n    this.body = options.body;\n  }\n\n  this.contact = ua.contact.toString();\n\n  options.extraHeaders.push('Contact: '+ this.contact);\n  options.extraHeaders.push('Allow: '+ SIP.Utils.getAllowedMethods(ua));\n\n  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);\n\n  this.logger = ua.getLogger('sip.subscription');\n\n  this.dialog = null;\n  this.timers = {N: null, sub_duration: null};\n  this.errorCodes  = [404,405,410,416,480,481,482,483,484,485,489,501,604];\n\n  this.initMoreEvents(events);\n};\n\nSIP.Subscription.prototype = {\n  subscribe: function() {\n    var sub = this;\n\n    SIP.Timers.clearTimeout(this.timers.sub_duration);\n    SIP.Timers.clearTimeout(this.timers.N);\n    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n\n    this.send();\n\n    this.state = 'notify_wait';\n\n    return this;\n  },\n\n  receiveResponse: function(response) {\n    var expires, sub = this,\n        cause = SIP.C.REASON_PHRASE[response.status_code] || '';\n\n    if (this.errorCodes.indexOf(response.status_code) !== -1) {\n      this.failed(response, null);\n    } else if (/^2[0-9]{2}$/.test(response.status_code)){\n      expires = response.getHeader('Expires');\n      SIP.Timers.clearTimeout(this.timers.N);\n\n      if (this.createConfirmedDialog(response,'UAC')) {\n        this.id = this.dialog.id.toString();\n        this.ua.subscriptions[this.id] = this;\n        this.emit('accepted', response, cause);\n        // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?\n      }\n\n      if (expires && expires <= this.expires) {\n        this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), expires * 1000);\n      } else {\n        if (!expires) {\n          this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');\n          this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);\n        } else {\n          this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');\n          this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);\n        }\n      }\n    } //Used to just ignore provisional responses; now ignores everything except errorCodes and 2xx\n  },\n\n  unsubscribe: function() {\n    var extraHeaders = [], sub = this;\n\n    this.state = 'terminated';\n\n    extraHeaders.push('Event: ' + this.event);\n    extraHeaders.push('Expires: 0');\n\n    extraHeaders.push('Contact: '+ this.contact);\n    extraHeaders.push('Allow: '+ SIP.Utils.getAllowedMethods(this.ua));\n\n    this.request = new SIP.OutgoingRequest(this.method, this.request.to.uri.toString(), this.ua, null, extraHeaders);\n\n    //MAYBE, may want to see state\n    this.receiveResponse = function(){};\n\n    SIP.Timers.clearTimeout(this.timers.sub_duration);\n    SIP.Timers.clearTimeout(this.timers.N);\n    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n\n    this.send();\n  },\n\n  /**\n  * @private\n  */\n  timer_fire: function(){\n    if (this.state === 'terminated') {\n      this.close();\n    } else if (this.state === 'pending' || this.state === 'notify_wait') {\n      this.state = 'terminated';\n      this.close();\n    } else {\n      this.subscribe();\n    }\n  },\n\n  /**\n  * @private\n  */\n  close: function() {\n    if(this.state !== 'terminated') {\n      this.unsubscribe();\n    }\n\n    this.terminateDialog();\n    SIP.Timers.clearTimeout(this.timers.N);\n    SIP.Timers.clearTimeout(this.timers.sub_duration);\n\n    delete this.ua.subscriptions[this.id];\n  },\n\n  /**\n  * @private\n  */\n  createConfirmedDialog: function(message, type) {\n    var dialog;\n\n    this.terminateDialog();\n    dialog = new SIP.Dialog(this, message, type);\n\n    if(!dialog.error) {\n      this.dialog = dialog;\n      return true;\n    }\n    // Dialog not created due to an error\n    else {\n      return false;\n    }\n  },\n\n  /**\n  * @private\n  */\n  terminateDialog: function() {\n    if(this.dialog) {\n      delete this.ua.subscriptions[this.id];\n      this.dialog.terminate();\n      delete this.dialog;\n    }\n  },\n\n  /**\n  * @private\n  */\n  receiveRequest: function(request) {\n    var sub_state, sub = this;\n\n    function setExpiresTimeout() {\n      if (sub_state.expires) {\n        sub_state.expires = Math.min(sub.expires,\n                                     Math.max(sub_state.expires, 0));\n        sub.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub),\n                                                    sub_state.expires * 1000);\n      }\n    }\n\n    if (!this.matchEvent(request)) { //checks event and subscription_state headers\n      request.reply(489);\n      return;\n    }\n\n    sub_state = request.parseHeader('Subscription-State');\n\n    request.reply(200, SIP.C.REASON_200);\n\n    SIP.Timers.clearTimeout(this.timers.N);\n    SIP.Timers.clearTimeout(this.timers.sub_duration);\n\n    this.emit('notify', {request: request});\n\n    switch (sub_state.state) {\n      case 'active':\n        this.state = 'active';\n        setExpiresTimeout();\n        break;\n      case 'pending':\n        if (this.state === 'notify_wait') {\n          setExpiresTimeout();\n        }\n        this.state = 'pending';\n        break;\n      case 'terminated':\n        if (sub_state.reason) {\n          this.logger.log('terminating subscription with reason '+ sub_state.reason);\n          switch (sub_state.reason) {\n            case 'deactivated':\n            case 'timeout':\n              this.subscribe();\n              return;\n            case 'probation':\n            case 'giveup':\n              if(sub_state.params && sub_state.params['retry-after']) {\n                this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);\n              } else {\n                this.subscribe();\n              }\n              return;\n            case 'rejected':\n            case 'noresource':\n            case 'invariant':\n              break;\n          }\n        }\n        this.close();\n        break;\n    }\n  },\n\n  failed: function(response, cause) {\n    this.close();\n    return this.emit('failed', response, cause);\n  },\n\n  /**\n  * @private\n  */\n  matchEvent: function(request) {\n    var event;\n\n    // Check mandatory header Event\n    if (!request.hasHeader('Event')) {\n      this.logger.warn('missing Event header');\n      return false;\n    }\n    // Check mandatory header Subscription-State\n    if (!request.hasHeader('Subscription-State')) {\n      this.logger.warn('missing Subscription-State header');\n      return false;\n    }\n\n    // Check whether the event in NOTIFY matches the event in SUBSCRIBE\n    event = request.parseHeader('event').event;\n\n    if (this.event !== event) {\n      this.logger.warn('event match failed');\n      request.reply(481, 'Event Match Failed');\n      return false;\n    } else {\n      return true;\n    }\n  }\n};\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Subscription.js\n ** module id = 26\n ** module chunks = 0\n **/","/**\n * @fileoverview MediaHandler\n */\n\n/* MediaHandler\n * @class PeerConnection helper Class.\n * @param {SIP.Session} session\n * @param {Object} [options]\n * @param {SIP.WebRTC.MediaStreamManager} [options.mediaStreamManager]\n *        The MediaStreamManager to acquire/release streams from/to.\n *        If not provided, a default MediaStreamManager will be used.\n */\nmodule.exports = function (SIP) {\n\nvar MediaHandler = function(session, options) {\n  var events = [\n    'userMediaRequest',\n    'userMedia',\n    'userMediaFailed',\n    'iceGathering',\n    'iceCandidate',\n    'iceComplete',\n    'iceFailed',\n    'getDescription',\n    'setDescription',\n    'dataChannel',\n    'addStream'\n  ];\n  options = options || {};\n\n  this.logger = session.ua.getLogger('sip.invitecontext.mediahandler', session.id);\n  this.session = session;\n  this.localMedia = null;\n  this.ready = true;\n  this.mediaStreamManager = options.mediaStreamManager || new SIP.WebRTC.MediaStreamManager(this.logger);\n  this.audioMuted = false;\n  this.videoMuted = false;\n\n  // old init() from here on\n  var idx, length, server,\n    self = this,\n    servers = [],\n    stunServers = options.stunServers || null,\n    turnServers = options.turnServers || null,\n    config = this.session.ua.configuration;\n  this.RTCConstraints = options.RTCConstraints || {};\n\n  if (!stunServers) {\n    stunServers = config.stunServers;\n  }\n\n  if(!turnServers) {\n    turnServers = config.turnServers;\n  }\n\n  /* Change 'url' to 'urls' whenever this issue is solved:\n   * https://code.google.com/p/webrtc/issues/detail?id=2096\n   */\n  [].concat(stunServers).forEach(function (server) {\n    servers.push({'url': server});\n  });\n\n  length = turnServers.length;\n  for (idx = 0; idx < length; idx++) {\n    server = turnServers[idx];\n    servers.push({\n      'url': server.urls,\n      'username': server.username,\n      'credential': server.password\n    });\n  }\n\n  this.peerConnection = new SIP.WebRTC.RTCPeerConnection({'iceServers': servers}, this.RTCConstraints);\n\n  this.peerConnection.onaddstream = function(e) {\n    self.logger.log('stream added: '+ e.stream.id);\n    self.render();\n    self.emit('addStream', e);\n  };\n\n  this.peerConnection.onremovestream = function(e) {\n    self.logger.log('stream removed: '+ e.stream.id);\n  };\n\n  this.peerConnection.onicecandidate = function(e) {\n    self.emit('iceCandidate', e);\n    if (e.candidate) {\n      self.logger.log('ICE candidate received: '+ (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));\n    } else if (self.onIceCompleted !== undefined) {\n      self.onIceCompleted(this);\n    } else {\n      self.callOnIceCompleted = true;\n    }\n  };\n\n  this.peerConnection.onicegatheringstatechange = function () {\n    self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);\n    if (this.iceGatheringState === 'gathering') {\n      self.emit('iceGathering', this);\n    }\n    if (this.iceGatheringState === 'complete') {\n      if (self.onIceCompleted !== undefined) {\n        self.onIceCompleted(this);\n      } else {\n        self.callOnIceCompleted = true;\n      }\n    }\n  };\n\n  this.peerConnection.oniceconnectionstatechange = function() {  //need e for commented out case\n    self.logger.log('ICE connection state changed to \"'+ this.iceConnectionState +'\"');\n\n    if (this.iceConnectionState === 'failed') {\n      self.emit('iceFailed', this);\n    }\n\n    //Bria state changes are always connected -> disconnected -> connected on accept, so session gets terminated\n    //normal calls switch from failed to connected in some cases, so checking for failed and terminated\n    /*if (this.iceConnectionState === 'failed') {\n      self.session.terminate({\n        cause: SIP.C.causes.RTP_TIMEOUT,\n        status_code: 200,\n        reason_phrase: SIP.C.causes.RTP_TIMEOUT\n      });\n    } else if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {\n      self.onIceCompleted(this);\n    }*/\n  };\n\n  this.peerConnection.onstatechange = function() {\n    self.logger.log('PeerConnection state changed to \"'+ this.readyState +'\"');\n  };\n\n  this.initEvents(events);\n\n  function selfEmit(mh, event) {\n    if (mh.mediaStreamManager.on &&\n        mh.mediaStreamManager.checkEvent &&\n        mh.mediaStreamManager.checkEvent(event)) {\n      mh.mediaStreamManager.on(event, function () {\n        mh.emit.apply(mh, [event].concat(Array.prototype.slice.call(arguments)));\n      });\n    }\n  }\n\n  selfEmit(this, 'userMediaRequest');\n  selfEmit(this, 'userMedia');\n  selfEmit(this, 'userMediaFailed');\n};\n\nMediaHandler.defaultFactory = function defaultFactory (session, options) {\n  return new MediaHandler(session, options);\n};\nMediaHandler.defaultFactory.isSupported = function () {\n  return SIP.WebRTC.isSupported();\n};\n\nMediaHandler.prototype = Object.create(SIP.MediaHandler.prototype, {\n// Functions the session can use\n  isReady: {writable: true, value: function isReady () {\n    return this.ready;\n  }},\n\n  close: {writable: true, value: function close () {\n    this.logger.log('closing PeerConnection');\n    // have to check signalingState since this.close() gets called multiple times\n    // TODO figure out why that happens\n    if(this.peerConnection && this.peerConnection.signalingState !== 'closed') {\n      this.peerConnection.close();\n\n      if(this.localMedia) {\n        this.mediaStreamManager.release(this.localMedia);\n      }\n    }\n  }},\n\n  /**\n   * @param {Function} onSuccess\n   * @param {Function} onFailure\n   * @param {SIP.WebRTC.MediaStream | (getUserMedia constraints)} [mediaHint]\n   *        the MediaStream (or the constraints describing it) to be used for the session\n   */\n  getDescription: {writable: true, value: function getDescription (onSuccess, onFailure, mediaHint) {\n    var self = this;\n    mediaHint = mediaHint || {};\n    if (mediaHint.dataChannel === true) {\n      mediaHint.dataChannel = {};\n    }\n    this.mediaHint = mediaHint;\n\n    /*\n     * 1. acquire stream (skip if MediaStream passed in)\n     * 2. addStream\n     * 3. createOffer/createAnswer\n     * 4. call onSuccess()\n     */\n\n    /* Last functions first, to quiet JSLint */\n    function streamAdditionSucceeded() {\n      if (self.hasOffer('remote')) {\n        self.peerConnection.ondatachannel = function (evt) {\n          self.dataChannel = evt.channel;\n          self.emit('dataChannel', self.dataChannel);\n        };\n      } else if (mediaHint.dataChannel &&\n                 self.peerConnection.createDataChannel) {\n        self.dataChannel = self.peerConnection.createDataChannel(\n          'sipjs',\n          mediaHint.dataChannel\n        );\n        self.emit('dataChannel', self.dataChannel);\n      }\n\n      self.render();\n      self.createOfferOrAnswer(onSuccess, onFailure, self.RTCConstraints);\n    }\n\n    function acquireSucceeded(stream) {\n      self.logger.log('acquired local media stream');\n      self.localMedia = stream;\n      self.session.connecting();\n      self.addStream(\n        stream,\n        streamAdditionSucceeded,\n        onFailure\n      );\n    }\n\n    if (self.localMedia) {\n      self.logger.log('already have local media');\n      streamAdditionSucceeded();\n      return;\n    }\n\n    self.logger.log('acquiring local media');\n    self.mediaStreamManager.acquire(\n      acquireSucceeded,\n      function acquireFailed(err) {\n        self.logger.error('unable to acquire stream');\n        self.logger.error(err);\n        self.session.connecting();\n        onFailure(err);\n      },\n      mediaHint\n    );\n  }},\n\n  /**\n  * Message reception.\n  * @param {String} type\n  * @param {String} sdp\n  * @param {Function} onSuccess\n  * @param {Function} onFailure\n  */\n  setDescription: {writable: true, value: function setDescription (sdp, onSuccess, onFailure) {\n    var rawDescription = {\n      type: this.hasOffer('local') ? 'answer' : 'offer',\n      sdp: sdp\n    };\n\n    this.emit('setDescription', rawDescription);\n\n    var description = new SIP.WebRTC.RTCSessionDescription(rawDescription);\n    this.peerConnection.setRemoteDescription(description, onSuccess, onFailure);\n  }},\n\n// Functions the session can use, but only because it's convenient for the application\n  isMuted: {writable: true, value: function isMuted () {\n    return {\n      audio: this.audioMuted,\n      video: this.videoMuted\n    };\n  }},\n\n  mute: {writable: true, value: function mute (options) {\n    if (this.getLocalStreams().length === 0) {\n      return;\n    }\n\n    options = options || {\n      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n      video: this.getLocalStreams()[0].getVideoTracks().length > 0\n    };\n\n    var audioMuted = false,\n        videoMuted = false;\n\n    if (options.audio && !this.audioMuted) {\n      audioMuted = true;\n      this.audioMuted = true;\n      this.toggleMuteAudio(true);\n    }\n\n    if (options.video && !this.videoMuted) {\n      videoMuted = true;\n      this.videoMuted = true;\n      this.toggleMuteVideo(true);\n    }\n\n    //REVISIT\n    if (audioMuted || videoMuted) {\n      return {\n        audio: audioMuted,\n        video: videoMuted\n      };\n      /*this.session.onmute({\n        audio: audioMuted,\n        video: videoMuted\n      });*/\n    }\n  }},\n\n  unmute: {writable: true, value: function unmute (options) {\n    if (this.getLocalStreams().length === 0) {\n      return;\n    }\n\n    options = options || {\n      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,\n      video: this.getLocalStreams()[0].getVideoTracks().length > 0\n    };\n\n    var audioUnMuted = false,\n        videoUnMuted = false;\n\n    if (options.audio && this.audioMuted) {\n      audioUnMuted = true;\n      this.audioMuted = false;\n      this.toggleMuteAudio(false);\n    }\n\n    if (options.video && this.videoMuted) {\n      videoUnMuted = true;\n      this.videoMuted = false;\n      this.toggleMuteVideo(false);\n    }\n\n    //REVISIT\n    if (audioUnMuted || videoUnMuted) {\n      return {\n        audio: audioUnMuted,\n        video: videoUnMuted\n      };\n      /*this.session.onunmute({\n        audio: audioUnMuted,\n        video: videoUnMuted\n      });*/\n    }\n  }},\n\n  hold: {writable: true, value: function hold () {\n    this.toggleMuteAudio(true);\n    this.toggleMuteVideo(true);\n  }},\n\n  unhold: {writable: true, value: function unhold () {\n    if (!this.audioMuted) {\n      this.toggleMuteAudio(false);\n    }\n\n    if (!this.videoMuted) {\n      this.toggleMuteVideo(false);\n    }\n  }},\n\n// Functions the application can use, but not the session\n  getLocalStreams: {writable: true, value: function getLocalStreams () {\n    var pc = this.peerConnection;\n    if (pc && pc.signalingState === 'closed') {\n      this.logger.warn('peerConnection is closed, getLocalStreams returning []');\n      return [];\n    }\n    return (pc.getLocalStreams && pc.getLocalStreams()) ||\n      pc.localStreams || [];\n  }},\n\n  getRemoteStreams: {writable: true, value: function getRemoteStreams () {\n    var pc = this.peerConnection;\n    if (pc && pc.signalingState === 'closed') {\n      this.logger.warn('peerConnection is closed, getRemoteStreams returning []');\n      return [];\n    }\n    return(pc.getRemoteStreams && pc.getRemoteStreams()) ||\n      pc.remoteStreams || [];\n  }},\n\n  render: {writable: true, value: function render (renderHint) {\n    renderHint = renderHint || (this.mediaHint && this.mediaHint.render);\n    if (!renderHint) {\n      return false;\n    }\n    var streamGetters = {\n      local: 'getLocalStreams',\n      remote: 'getRemoteStreams'\n    };\n    Object.keys(streamGetters).forEach(function (loc) {\n      var streamGetter = streamGetters[loc];\n      var streams = this[streamGetter]();\n      if (streams.length) {\n        SIP.WebRTC.MediaStreamManager.render(streams[0], renderHint[loc]);\n      }\n    }.bind(this));\n  }},\n\n// Internal functions\n  hasOffer: {writable: true, value: function hasOffer (where) {\n    var offerState = 'have-' + where + '-offer';\n    return this.peerConnection.signalingState === offerState;\n    // TODO consider signalingStates with 'pranswer'?\n  }},\n\n  createOfferOrAnswer: {writable: true, value: function createOfferOrAnswer (onSuccess, onFailure, constraints) {\n    var self = this;\n    var methodName;\n\n    function readySuccess () {\n      var sdp = self.peerConnection.localDescription.sdp;\n\n      sdp = SIP.Hacks.Chrome.needsExplicitlyInactiveSDP(sdp);\n      sdp = SIP.Hacks.AllBrowsers.unmaskDtls(sdp);\n      sdp = SIP.Hacks.Firefox.hasIncompatibleCLineWithSomeSIPEndpoints(sdp);\n\n      var sdpWrapper = {\n        type: methodName === 'createOffer' ? 'offer' : 'answer',\n        sdp: sdp\n      };\n\n      self.emit('getDescription', sdpWrapper);\n\n      self.ready = true;\n      onSuccess(sdpWrapper.sdp);\n    }\n\n    function onSetLocalDescriptionSuccess() {\n      if (self.peerConnection.iceGatheringState === 'complete' && (self.peerConnection.iceConnectionState === 'connected' || self.peerConnection.iceConnectionState === 'completed')) {\n        readySuccess();\n      } else {\n        self.onIceCompleted = function(pc) {\n          self.logger.log('ICE Gathering Completed');\n          self.onIceCompleted = undefined;\n          self.emit('iceComplete', pc);\n          readySuccess();\n        };\n        if (self.callOnIceCompleted) {\n          self.onIceCompleted();\n        }\n      }\n    }\n\n    function methodFailed (methodName, e) {\n      self.logger.error('peerConnection.' + methodName + ' failed');\n      self.logger.error(e);\n      self.ready = true;\n      onFailure(e);\n    }\n\n    self.ready = false;\n\n    methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';\n\n    self.peerConnection[methodName](\n      function(sessionDescription){\n        self.peerConnection.setLocalDescription(\n          sessionDescription,\n          onSetLocalDescriptionSuccess,\n          methodFailed.bind(null, 'setLocalDescription')\n        );\n      },\n      methodFailed.bind(null, methodName),\n      constraints\n    );\n  }},\n\n  addStream: {writable: true, value: function addStream (stream, onSuccess, onFailure) {\n    try {\n      this.peerConnection.addStream(stream);\n    } catch(e) {\n      this.logger.error('error adding stream');\n      this.logger.error(e);\n      onFailure(e);\n      return;\n    }\n\n    onSuccess();\n  }},\n\n  toggleMuteHelper: {writable: true, value: function toggleMuteHelper (trackGetter, mute) {\n    this.getLocalStreams().forEach(function (stream) {\n      stream[trackGetter]().forEach(function (track) {\n        track.enabled = !mute;\n      });\n    });\n  }},\n\n  toggleMuteAudio: {writable: true, value: function toggleMuteAudio (mute) {\n    this.toggleMuteHelper('getAudioTracks', mute);\n  }},\n\n  toggleMuteVideo: {writable: true, value: function toggleMuteVideo (mute) {\n    this.toggleMuteHelper('getVideoTracks', mute);\n  }}\n});\n\n// Return since it will be assigned to a variable.\nreturn MediaHandler;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/WebRTC/MediaHandler.js\n ** module id = 27\n ** module chunks = 0\n **/","/**\n * @fileoverview MediaStreamManager\n */\n\n/* MediaStreamManager\n * @class Manages the acquisition and release of MediaStreams.\n * @param {mediaHint} [defaultMediaHint] The mediaHint to use if none is provided to acquire()\n */\nmodule.exports = function (SIP) {\n\n// Default MediaStreamManager provides single-use streams created with getUserMedia\nvar MediaStreamManager = function MediaStreamManager (logger, defaultMediaHint) {\n  if (!SIP.WebRTC.isSupported()) {\n    throw new SIP.Exceptions.NotSupportedError('Media not supported');\n  }\n\n  var events = [\n    'userMediaRequest',\n    'userMedia',\n    'userMediaFailed'\n  ];\n  this.mediaHint = defaultMediaHint || {\n    constraints: {audio: true, video: true}\n  };\n\n  this.logger = logger;\n  this.initEvents(events);\n\n  // map of streams to acquisition manner:\n  // true -> passed in as mediaHint.stream\n  // false -> getUserMedia\n  this.acquisitions = {};\n};\nMediaStreamManager.streamId = function (stream) {\n  return stream.getAudioTracks().concat(stream.getVideoTracks())\n    .map(function trackId (track) {\n      return track.id;\n    })\n    .join('');\n};\n\nMediaStreamManager.render = function render (stream, elements) {\n  if (!elements) {\n    return false;\n  }\n\n  function attachAndPlay (element, stream) {\n    (window.attachMediaStream || attachMediaStream)(element, stream);\n    ensureMediaPlaying(element);\n  }\n\n  function attachMediaStream(element, stream) {\n    if (typeof element.src !== 'undefined') {\n      URL.revokeObjectURL(element.src);\n      element.src = URL.createObjectURL(stream);\n    } else if (typeof (element.srcObject || element.mozSrcObject) !== 'undefined') {\n      element.srcObject = element.mozSrcObject = stream;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  function ensureMediaPlaying (mediaElement) {\n    var interval = 100;\n    mediaElement.ensurePlayingIntervalId = SIP.Timers.setInterval(function () {\n      if (mediaElement.paused) {\n        mediaElement.play();\n      }\n      else {\n        SIP.Timers.clearInterval(mediaElement.ensurePlayingIntervalId);\n      }\n    }, interval);\n  }\n\n  if (elements.video) {\n    if (elements.audio) {\n      elements.video.volume = 0;\n    }\n    attachAndPlay(elements.video, stream);\n  }\n  if (elements.audio) {\n    attachAndPlay(elements.audio, stream);\n  }\n};\n\nMediaStreamManager.prototype = Object.create(SIP.EventEmitter.prototype, {\n  'acquire': {value: function acquire (onSuccess, onFailure, mediaHint) {\n    mediaHint = Object.keys(mediaHint || {}).length ? mediaHint : this.mediaHint;\n\n    var saveSuccess = function (onSuccess, stream, isHintStream) {\n      var streamId = MediaStreamManager.streamId(stream);\n      this.acquisitions[streamId] = !!isHintStream;\n      onSuccess(stream);\n    }.bind(this, onSuccess);\n\n    if (mediaHint.stream) {\n      saveSuccess(mediaHint.stream, true);\n    } else {\n      // Fallback to audio/video enabled if no mediaHint can be found.\n      var constraints = mediaHint.constraints ||\n        (this.mediaHint && this.mediaHint.constraints) ||\n        {audio: true, video: true};\n\n      /*\n       * Make the call asynchronous, so that ICCs have a chance\n       * to define callbacks to `userMediaRequest`\n       */\n      SIP.Timers.setTimeout(function () {\n        this.emit('userMediaRequest', constraints);\n\n        var emitThenCall = function (eventName, callback) {\n          var callbackArgs = Array.prototype.slice.call(arguments, 2);\n          // Emit with all of the arguments from the real callback.\n          var newArgs = [eventName].concat(callbackArgs);\n\n          this.emit.apply(this, newArgs);\n\n          callback.apply(null, callbackArgs);\n        }.bind(this);\n\n        SIP.WebRTC.getUserMedia(\n          constraints,\n          emitThenCall.bind(this, 'userMedia', saveSuccess),\n          emitThenCall.bind(this, 'userMediaFailed', onFailure)\n        );\n      }.bind(this), 0);\n    }\n  }},\n\n  'release': {value: function release (stream) {\n    var streamId = MediaStreamManager.streamId(stream);\n    if (this.acquisitions[streamId] === false) {\n      stream.stop();\n    }\n    delete this.acquisitions[streamId];\n  }},\n});\n\n// Return since it will be assigned to a variable.\nreturn MediaStreamManager;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/WebRTC/MediaStreamManager.js\n ** module id = 28\n ** module chunks = 0\n **/","/**\n * @fileoverview WebRTC\n */\n\nmodule.exports = function (Utils, window, MediaHandler, MediaStreamManager) {\nvar WebRTC;\n\nWebRTC = {};\n\nWebRTC.MediaHandler = MediaHandler;\nWebRTC.MediaStreamManager = MediaStreamManager;\n\nvar _isSupported;\n\nWebRTC.isSupported = function () {\n  if (_isSupported !== undefined) {\n    return _isSupported;\n  }\n\n  WebRTC.MediaStream = Utils.getPrefixedProperty(window, 'MediaStream');\n  WebRTC.getUserMedia = Utils.getPrefixedProperty(window.navigator, 'getUserMedia');\n  WebRTC.RTCPeerConnection = Utils.getPrefixedProperty(window, 'RTCPeerConnection');\n  WebRTC.RTCSessionDescription = Utils.getPrefixedProperty(window, 'RTCSessionDescription');\n\n  if (WebRTC.getUserMedia && WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {\n    WebRTC.getUserMedia = WebRTC.getUserMedia.bind(window.navigator);\n    _isSupported = true;\n  }\n  else {\n    _isSupported = false;\n  }\n  return _isSupported;\n};\n\nreturn WebRTC;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/WebRTC.js\n ** module id = 29\n ** module chunks = 0\n **/","/**\n * @augments SIP\n * @class Class creating a SIP User Agent.\n * @param {function returning SIP.MediaHandler} [configuration.mediaHandlerFactory]\n *        A function will be invoked by each of the UA's Sessions to build the MediaHandler for that Session.\n *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) MediaHandler.\n *\n * @param {Object} [configuration.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n */\nmodule.exports = function (SIP) {\nvar UA,\n  C = {\n    // UA status codes\n    STATUS_INIT :                0,\n    STATUS_READY:                1,\n    STATUS_USER_CLOSED:          2,\n    STATUS_NOT_READY:            3,\n\n    // UA error codes\n    CONFIGURATION_ERROR:  1,\n    NETWORK_ERROR:        2,\n\n    /* UA events and corresponding SIP Methods.\n     * Dynamically added to 'Allow' header field if the\n     * corresponding event handler is set.\n     */\n    EVENT_METHODS: {\n      'invite': 'INVITE',\n      'message': 'MESSAGE'\n    },\n\n    ALLOWED_METHODS: [\n      'ACK',\n      'CANCEL',\n      'BYE',\n      'OPTIONS',\n      'INFO',\n      'NOTIFY'\n    ],\n\n    ACCEPTED_BODY_TYPES: [\n      'application/sdp',\n      'application/dtmf-relay'\n    ],\n\n    MAX_FORWARDS: 70,\n    TAG_LENGTH: 10\n  };\n\nUA = function(configuration) {\n  var self = this,\n  events = [\n    'connecting',\n    'connected',\n    'disconnected',\n    'newTransaction',\n    'transactionDestroyed',\n    'registered',\n    'unregistered',\n    'registrationFailed',\n    'invite',\n    'newSession',\n    'message'\n  ], i, len;\n\n  // Helper function for forwarding events\n  function selfEmit(type) {\n    //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments\n    return self.emit.bind(self, type);\n  }\n\n  for (i = 0, len = C.ALLOWED_METHODS.length; i < len; i++) {\n    events.push(C.ALLOWED_METHODS[i].toLowerCase());\n  }\n\n  // Set Accepted Body Types\n  C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();\n\n  this.log = new SIP.LoggerFactory();\n  this.logger = this.getLogger('sip.ua');\n\n  this.cache = {\n    credentials: {}\n  };\n\n  this.configuration = {};\n  this.dialogs = {};\n\n  //User actions outside any session/dialog (MESSAGE)\n  this.applicants = {};\n\n  this.data = {};\n  this.sessions = {};\n  this.subscriptions = {};\n  this.transport = null;\n  this.contact = null;\n  this.status = C.STATUS_INIT;\n  this.error = null;\n  this.transactions = {\n    nist: {},\n    nict: {},\n    ist: {},\n    ict: {}\n  };\n\n  this.transportRecoverAttempts = 0;\n  this.transportRecoveryTimer = null;\n\n  Object.defineProperties(this, {\n    transactionsCount: {\n      get: function() {\n        var type,\n          transactions = ['nist','nict','ist','ict'],\n          count = 0;\n\n        for (type in transactions) {\n          count += Object.keys(this.transactions[transactions[type]]).length;\n        }\n\n        return count;\n      }\n    },\n\n    nictTransactionsCount: {\n      get: function() {\n        return Object.keys(this.transactions['nict']).length;\n      }\n    },\n\n    nistTransactionsCount: {\n      get: function() {\n        return Object.keys(this.transactions['nist']).length;\n      }\n    },\n\n    ictTransactionsCount: {\n      get: function() {\n        return Object.keys(this.transactions['ict']).length;\n      }\n    },\n\n    istTransactionsCount: {\n      get: function() {\n        return Object.keys(this.transactions['ist']).length;\n      }\n    }\n  });\n\n  /**\n   * Load configuration\n   *\n   * @throws {SIP.Exceptions.ConfigurationError}\n   * @throws {TypeError}\n   */\n\n  if(configuration === undefined) {\n    configuration = {};\n  } else if (typeof configuration === 'string' || configuration instanceof String) {\n    configuration = {\n      uri: configuration\n    };\n  }\n\n  // Apply log configuration if present\n  if (configuration.log) {\n    if (configuration.log.hasOwnProperty('builtinEnabled')) {\n      this.log.builtinEnabled = configuration.log.builtinEnabled;\n    }\n\n    if (configuration.log.hasOwnProperty('level')) {\n      this.log.level = configuration.log.level;\n    }\n\n    if (configuration.log.hasOwnProperty('connector')) {\n      this.log.connector = configuration.log.connector;\n    }\n  }\n\n  try {\n    this.loadConfig(configuration);\n    this.initEvents(events);\n  } catch(e) {\n    this.status = C.STATUS_NOT_READY;\n    this.error = C.CONFIGURATION_ERROR;\n    throw e;\n  }\n\n  // Initialize registerContext\n  this.registerContext = new SIP.RegisterContext(this);\n  this.registerContext.on('failed', selfEmit('registrationFailed'));\n  this.registerContext.on('registered', selfEmit('registered'));\n  this.registerContext.on('unregistered', selfEmit('unregistered'));\n\n  if(this.configuration.autostart) {\n    this.start();\n  }\n\n  if (typeof global.addEventListener === 'function') {\n    global.addEventListener('unload', this.stop.bind(this));\n  }\n};\nUA.prototype = new SIP.EventEmitter();\n\n//=================\n//  High Level API\n//=================\n\nUA.prototype.register = function(options) {\n  this.configuration.register = true;\n  this.registerContext.register(options);\n\n  return this;\n};\n\n/**\n * Unregister.\n *\n * @param {Boolean} [all] unregister all user bindings.\n *\n */\nUA.prototype.unregister = function(options) {\n  this.configuration.register = false;\n  this.registerContext.unregister(options);\n\n  return this;\n};\n\nUA.prototype.isRegistered = function() {\n  return this.registerContext.registered;\n};\n\n/**\n * Connection state.\n * @param {Boolean}\n */\nUA.prototype.isConnected = function() {\n  return this.transport ? this.transport.connected : false;\n};\n\n/**\n * Make an outgoing call.\n *\n * @param {String} target\n * @param {Object} views\n * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint\n *\n * @throws {TypeError}\n *\n */\nUA.prototype.invite = function(target, options) {\n  options = options || {};\n  options = SIP.Utils.desugarSessionOptions(options);\n  SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger);\n\n  var context = new SIP.InviteClientContext(this, target, options);\n\n  if (this.isConnected()) {\n    context.invite({media: options.media});\n  } else {\n    this.once('connected', function() {\n      context.invite({media: options.media});\n    });\n  }\n  return context;\n};\n\nUA.prototype.subscribe = function(target, event, options) {\n  var sub = new SIP.Subscription(this, target, event, options);\n\n  if (this.isConnected()) {\n    sub.subscribe();\n  } else {\n    this.once('connected', function() {\n      sub.subscribe();\n    });\n  }\n  return sub;\n};\n\n/**\n * Send a message.\n *\n * @param {String} target\n * @param {String} body\n * @param {Object} [options]\n *\n * @throws {TypeError}\n *\n */\nUA.prototype.message = function(target, body, options) {\n  if (body === undefined) {\n    throw new TypeError('Not enough arguments');\n  }\n\n  options = options || {};\n  options.contentType = options.contentType || 'text/plain';\n  options.body = body;\n\n  var mes = new SIP.ClientContext(this, SIP.C.MESSAGE, target, options);\n\n  if (this.isConnected()) {\n    mes.send();\n  } else {\n    this.once('connected', function() {\n      mes.send();\n    });\n  }\n\n  return mes;\n};\n\nUA.prototype.request = function (method, target, options) {\n  var req = new SIP.ClientContext(this, method, target, options);\n\n  if (this.isConnected()) {\n    req.send();\n  } else {\n    this.once('connected', function() {\n      req.send();\n    });\n  }\n\n  return req;\n};\n\n/**\n * Gracefully close.\n *\n */\nUA.prototype.stop = function() {\n  var session, subscription, applicant,\n    ua = this;\n\n  function transactionsListener() {\n    if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {\n        ua.off('transactionDestroyed', transactionsListener);\n        ua.transport.disconnect();\n    }\n  }\n\n  this.logger.log('user requested closure...');\n\n  if(this.status === C.STATUS_USER_CLOSED) {\n    this.logger.warn('UA already closed');\n    return this;\n  }\n\n  // Clear transportRecoveryTimer\n  SIP.Timers.clearTimeout(this.transportRecoveryTimer);\n\n  // Close registerContext\n  this.logger.log('closing registerContext');\n  this.registerContext.close();\n\n  // Run  _terminate_ on every Session\n  for(session in this.sessions) {\n    this.logger.log('closing session ' + session);\n    this.sessions[session].terminate();\n  }\n\n  //Run _close_ on every Subscription\n  for(subscription in this.subscriptions) {\n    this.logger.log('unsubscribing from subscription ' + subscription);\n    this.subscriptions[subscription].close();\n  }\n\n  // Run  _close_ on every applicant\n  for(applicant in this.applicants) {\n    this.applicants[applicant].close();\n  }\n\n  this.status = C.STATUS_USER_CLOSED;\n\n  /*\n   * If the remaining transactions are all INVITE transactions, there is no need to\n   * wait anymore because every session has already been closed by this method.\n   * - locally originated sessions where terminated (CANCEL or BYE)\n   * - remotely originated sessions where rejected (4XX) or terminated (BYE)\n   * Remaining INVITE transactions belong tho sessions that where answered. This are in\n   * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]\n   */\n  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {\n    this.transport.disconnect();\n  } else {\n    this.on('transactionDestroyed', transactionsListener);\n  }\n\n  return this;\n};\n\n/**\n * Connect to the WS server if status = STATUS_INIT.\n * Resume UA after being closed.\n *\n */\nUA.prototype.start = function() {\n  var server;\n\n  this.logger.log('user requested startup...');\n  if (this.status === C.STATUS_INIT) {\n    server = this.getNextWsServer();\n    new SIP.Transport(this, server);\n  } else if(this.status === C.STATUS_USER_CLOSED) {\n    this.logger.log('resuming');\n    this.status = C.STATUS_READY;\n    this.transport.connect();\n  } else if (this.status === C.STATUS_READY) {\n    this.logger.log('UA is in READY status, not resuming');\n  } else {\n    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');\n  }\n\n  return this;\n};\n\n/**\n * Normalize a string into a valid SIP request URI\n *\n * @param {String} target\n *\n * @returns {SIP.URI|undefined}\n */\nUA.prototype.normalizeTarget = function(target) {\n  return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);\n};\n\n\n//===============================\n//  Private (For internal use)\n//===============================\n\nUA.prototype.saveCredentials = function(credentials) {\n  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};\n  this.cache.credentials[credentials.realm][credentials.uri] = credentials;\n\n  return this;\n};\n\nUA.prototype.getCredentials = function(request) {\n  var realm, credentials;\n\n  realm = request.ruri.host;\n\n  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {\n    credentials = this.cache.credentials[realm][request.ruri];\n    credentials.method = request.method;\n  }\n\n  return credentials;\n};\n\nUA.prototype.getLogger = function(category, label) {\n  return this.log.getLogger(category, label);\n};\n\n\n//==============================\n// Event Handlers\n//==============================\n\n/**\n * Transport Close event\n * @private\n * @event\n * @param {SIP.Transport} transport.\n */\nUA.prototype.onTransportClosed = function(transport) {\n  // Run _onTransportError_ callback on every client transaction using _transport_\n  var type, idx, length,\n    client_transactions = ['nict', 'ict', 'nist', 'ist'];\n\n  transport.server.status = SIP.Transport.C.STATUS_DISCONNECTED;\n  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_DISCONNECTED);\n\n  length = client_transactions.length;\n  for (type = 0; type < length; type++) {\n    for(idx in this.transactions[client_transactions[type]]) {\n      this.transactions[client_transactions[type]][idx].onTransportError();\n    }\n  }\n\n  // Close sessions if GRUU is not being used\n  if (!this.contact.pub_gruu) {\n    this.closeSessionsOnTransportError();\n  }\n\n};\n\n/**\n * Unrecoverable transport event.\n * Connection reattempt logic has been done and didn't success.\n * @private\n * @event\n * @param {SIP.Transport} transport.\n */\nUA.prototype.onTransportError = function(transport) {\n  var server;\n\n  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to '+ SIP.Transport.C.STATUS_ERROR);\n\n  // Close sessions.\n  //Mark this transport as 'down'\n  transport.server.status = SIP.Transport.C.STATUS_ERROR;\n\n  this.emit('disconnected', {\n    transport: transport\n  });\n\n  // try the next transport if the UA isn't closed\n  if(this.status === C.STATUS_USER_CLOSED) {\n    return;\n  }\n\n  server = this.getNextWsServer();\n\n  if(server) {\n    new SIP.Transport(this, server);\n  }else {\n    this.closeSessionsOnTransportError();\n    if (!this.error || this.error !== C.NETWORK_ERROR) {\n      this.status = C.STATUS_NOT_READY;\n      this.error = C.NETWORK_ERROR;\n    }\n    // Transport Recovery process\n    this.recoverTransport();\n  }\n};\n\n/**\n * Transport connection event.\n * @private\n * @event\n * @param {SIP.Transport} transport.\n */\nUA.prototype.onTransportConnected = function(transport) {\n  this.transport = transport;\n\n  // Reset transport recovery counter\n  this.transportRecoverAttempts = 0;\n\n  transport.server.status = SIP.Transport.C.STATUS_READY;\n  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_READY);\n\n  if(this.status === C.STATUS_USER_CLOSED) {\n    return;\n  }\n\n  this.status = C.STATUS_READY;\n  this.error = null;\n\n  if(this.configuration.register) {\n    this.registerContext.onTransportConnected();\n  }\n\n  this.emit('connected', {\n    transport: transport\n  });\n};\n\n\n/**\n * Transport connecting event\n * @private\n * @param {SIP.Transport} transport.\n * #param {Integer} attempts.\n */\n  UA.prototype.onTransportConnecting = function(transport, attempts) {\n    this.emit('connecting', {\n      transport: transport,\n      attempts: attempts\n    });\n  };\n\n\n/**\n * new Transaction\n * @private\n * @param {SIP.Transaction} transaction.\n */\nUA.prototype.newTransaction = function(transaction) {\n  this.transactions[transaction.type][transaction.id] = transaction;\n  this.emit('newTransaction', {transaction: transaction});\n};\n\n\n/**\n * destroy Transaction\n * @private\n * @param {SIP.Transaction} transaction.\n */\nUA.prototype.destroyTransaction = function(transaction) {\n  delete this.transactions[transaction.type][transaction.id];\n  this.emit('transactionDestroyed', {\n    transaction: transaction\n  });\n};\n\n\n//=========================\n// receiveRequest\n//=========================\n\n/**\n * Request reception\n * @private\n * @param {SIP.IncomingRequest} request.\n */\nUA.prototype.receiveRequest = function(request) {\n  var dialog, session, message,\n    method = request.method,\n    transaction,\n    methodLower = request.method.toLowerCase(),\n    self = this;\n\n  function ruriMatches (uri) {\n    return uri && uri.user === request.ruri.user;\n  }\n\n  // Check that request URI points to us\n  if(!(ruriMatches(this.configuration.uri) ||\n       ruriMatches(this.contact.uri) ||\n       ruriMatches(this.contact.pub_gruu) ||\n       ruriMatches(this.contact.temp_gruu))) {\n    this.logger.warn('Request-URI does not point to us');\n    if (request.method !== SIP.C.ACK) {\n      request.reply_sl(404);\n    }\n    return;\n  }\n\n  // Check request URI scheme\n  if(request.ruri.scheme === SIP.C.SIPS) {\n    request.reply_sl(416);\n    return;\n  }\n\n  // Check transaction\n  if(SIP.Transactions.checkTransaction(this, request)) {\n    return;\n  }\n\n  /* RFC3261 12.2.2\n   * Requests that do not change in any way the state of a dialog may be\n   * received within a dialog (for example, an OPTIONS request).\n   * They are processed as if they had been received outside the dialog.\n   */\n  if(method === SIP.C.OPTIONS) {\n    new SIP.Transactions.NonInviteServerTransaction(request, this);\n    request.reply(200, null, [\n      'Allow: '+ SIP.Utils.getAllowedMethods(this),\n      'Accept: '+ C.ACCEPTED_BODY_TYPES\n    ]);\n  } else if (method === SIP.C.MESSAGE) {\n    if (!this.checkListener(methodLower)) {\n      // UA is not listening for this.  Reject immediately.\n      new SIP.Transactions.NonInviteServerTransaction(request, this);\n      request.reply(405, null, ['Allow: '+ SIP.Utils.getAllowedMethods(this)]);\n      return;\n    }\n    message = new SIP.ServerContext(this, request);\n    message.body = request.body;\n    message.content_type = request.getHeader('Content-Type') || 'text/plain';\n\n    request.reply(200, null);\n    this.emit('message', message);\n  } else if (method !== SIP.C.INVITE &&\n             method !== SIP.C.ACK) {\n    // Let those methods pass through to normal processing for now.\n    transaction = new SIP.ServerContext(this, request);\n  }\n\n  // Initial Request\n  if(!request.to_tag) {\n    switch(method) {\n      case SIP.C.INVITE:\n        var isMediaSupported = this.configuration.mediaHandlerFactory.isSupported;\n        if(!isMediaSupported || isMediaSupported()) {\n          session = new SIP.InviteServerContext(this, request)\n            .on('invite', function() {\n              self.emit('invite', this);\n            });\n        } else {\n          this.logger.warn('INVITE received but WebRTC is not supported');\n          request.reply(488);\n        }\n        break;\n      case SIP.C.BYE:\n        // Out of dialog BYE received\n        request.reply(481);\n        break;\n      case SIP.C.CANCEL:\n        session = this.findSession(request);\n        if(session) {\n          session.receiveRequest(request);\n        } else {\n          this.logger.warn('received CANCEL request for a non existent session');\n        }\n        break;\n      case SIP.C.ACK:\n        /* Absorb it.\n         * ACK request without a corresponding Invite Transaction\n         * and without To tag.\n         */\n        break;\n      default:\n        request.reply(405);\n        break;\n    }\n  }\n  // In-dialog request\n  else {\n    dialog = this.findDialog(request);\n\n    if(dialog) {\n      if (method === SIP.C.INVITE) {\n        new SIP.Transactions.InviteServerTransaction(request, this);\n      }\n      dialog.receiveRequest(request);\n    } else if (method === SIP.C.NOTIFY) {\n      session = this.findSession(request);\n      if(session) {\n        session.receiveRequest(request);\n      } else {\n        this.logger.warn('received NOTIFY request for a non existent session');\n        request.reply(481, 'Subscription does not exist');\n      }\n    }\n    /* RFC3261 12.2.2\n     * Request with to tag, but no matching dialog found.\n     * Exception: ACK for an Invite request for which a dialog has not\n     * been created.\n     */\n    else {\n      if(method !== SIP.C.ACK) {\n        request.reply(481);\n      }\n    }\n  }\n};\n\n//=================\n// Utils\n//=================\n\n/**\n * Get the session to which the request belongs to, if any.\n * @private\n * @param {SIP.IncomingRequest} request.\n * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}\n */\nUA.prototype.findSession = function(request) {\n  return this.sessions[request.call_id + request.from_tag] ||\n          this.sessions[request.call_id + request.to_tag] ||\n          null;\n};\n\n/**\n * Get the dialog to which the request belongs to, if any.\n * @private\n * @param {SIP.IncomingRequest}\n * @returns {SIP.Dialog|null}\n */\nUA.prototype.findDialog = function(request) {\n  return this.dialogs[request.call_id + request.from_tag + request.to_tag] ||\n          this.dialogs[request.call_id + request.to_tag + request.from_tag] ||\n          null;\n};\n\n/**\n * Retrieve the next server to which connect.\n * @private\n * @returns {Object} ws_server\n */\nUA.prototype.getNextWsServer = function() {\n  // Order servers by weight\n  var idx, length, ws_server,\n    candidates = [];\n\n  length = this.configuration.wsServers.length;\n  for (idx = 0; idx < length; idx++) {\n    ws_server = this.configuration.wsServers[idx];\n\n    if (ws_server.status === SIP.Transport.C.STATUS_ERROR) {\n      continue;\n    } else if (candidates.length === 0) {\n      candidates.push(ws_server);\n    } else if (ws_server.weight > candidates[0].weight) {\n      candidates = [ws_server];\n    } else if (ws_server.weight === candidates[0].weight) {\n      candidates.push(ws_server);\n    }\n  }\n\n  idx = Math.floor(Math.random() * candidates.length);\n\n  return candidates[idx];\n};\n\n/**\n * Close all sessions on transport error.\n * @private\n */\nUA.prototype.closeSessionsOnTransportError = function() {\n  var idx;\n\n  // Run _transportError_ for every Session\n  for(idx in this.sessions) {\n    this.sessions[idx].onTransportError();\n  }\n  // Call registerContext _onTransportClosed_\n  this.registerContext.onTransportClosed();\n};\n\nUA.prototype.recoverTransport = function(ua) {\n  var idx, length, k, nextRetry, count, server;\n\n  ua = ua || this;\n  count = ua.transportRecoverAttempts;\n\n  length = ua.configuration.wsServers.length;\n  for (idx = 0; idx < length; idx++) {\n    ua.configuration.wsServers[idx].status = 0;\n  }\n\n  server = ua.getNextWsServer();\n\n  k = Math.floor((Math.random() * Math.pow(2,count)) +1);\n  nextRetry = k * ua.configuration.connectionRecoveryMinInterval;\n\n  if (nextRetry > ua.configuration.connectionRecoveryMaxInterval) {\n    this.logger.log('time for next connection attempt exceeds connectionRecoveryMaxInterval, resetting counter');\n    nextRetry = ua.configuration.connectionRecoveryMinInterval;\n    count = 0;\n  }\n\n  this.logger.log('next connection attempt in '+ nextRetry +' seconds');\n\n  this.transportRecoveryTimer = SIP.Timers.setTimeout(\n    function(){\n      ua.transportRecoverAttempts = count + 1;\n      new SIP.Transport(ua, server);\n    }, nextRetry * 1000);\n};\n\n/**\n * Configuration load.\n * @private\n * returns {Boolean}\n */\nUA.prototype.loadConfig = function(configuration) {\n  // Settings and default values\n  var parameter, value, checked_value, hostportParams, registrarServer,\n    settings = {\n      /* Host address\n      * Value to be set in Via sent_by and host part of Contact FQDN\n      */\n      viaHost: SIP.Utils.createRandomToken(12) + '.invalid',\n\n      uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),\n      wsServers: [{\n        scheme: 'WSS',\n        sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',\n        status: 0,\n        weight: 0,\n        ws_uri: 'wss://edge.sip.onsip.com'\n      }],\n\n      // Password\n      password: null,\n\n      // Registration parameters\n      registerExpires: 600,\n      register: true,\n      registrarServer: null,\n\n      // Transport related parameters\n      wsServerMaxReconnection: 3,\n      wsServerReconnectionTimeout: 4,\n\n      connectionRecoveryMinInterval: 2,\n      connectionRecoveryMaxInterval: 30,\n\n      usePreloadedRoute: false,\n\n      //string to be inserted into User-Agent request header\n      userAgentString: SIP.C.USER_AGENT,\n\n      // Session parameters\n      noAnswerTimeout: 60,\n      stunServers: ['stun:stun.l.google.com:19302'],\n      turnServers: [],\n\n      // Logging parameters\n      traceSip: false,\n\n      // Hacks\n      hackViaTcp: false,\n      hackIpInContact: false,\n      hackWssInTransport: false,\n\n      //autostarting\n      autostart: true,\n\n      //Reliable Provisional Responses\n      rel100: SIP.C.supported.UNSUPPORTED,\n\n      mediaHandlerFactory: SIP.WebRTC.MediaHandler.defaultFactory\n    };\n\n  // Pre-Configuration\n  function aliasUnderscored (parameter, logger) {\n    var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {\n      return m[0] + '_' + m[1].toLowerCase();\n    });\n\n    if (parameter === underscored) {\n      return;\n    }\n\n    var hasParameter = configuration.hasOwnProperty(parameter);\n    if (configuration.hasOwnProperty(underscored)) {\n      logger.warn(underscored + ' is deprecated, please use ' + parameter);\n      if (hasParameter) {\n        logger.warn(parameter + ' overriding ' + underscored);\n      }\n    }\n\n    configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];\n  }\n\n  // Check Mandatory parameters\n  for(parameter in UA.configuration_check.mandatory) {\n    aliasUnderscored(parameter, this.logger);\n    if(!configuration.hasOwnProperty(parameter)) {\n      throw new SIP.Exceptions.ConfigurationError(parameter);\n    } else {\n      value = configuration[parameter];\n      checked_value = UA.configuration_check.mandatory[parameter](value);\n      if (checked_value !== undefined) {\n        settings[parameter] = checked_value;\n      } else {\n        throw new SIP.Exceptions.ConfigurationError(parameter, value);\n      }\n    }\n  }\n\n  SIP.Utils.optionsOverride(configuration, 'rel100', 'reliable', true, this.logger, SIP.C.supported.UNSUPPORTED);\n\n  var emptyArraysAllowed = ['stunServers', 'turnServers'];\n\n  // Check Optional parameters\n  for(parameter in UA.configuration_check.optional) {\n    aliasUnderscored(parameter, this.logger);\n    if(configuration.hasOwnProperty(parameter)) {\n      value = configuration[parameter];\n\n      // If the parameter value is an empty array, but shouldn't be, apply its default value.\n      if (value instanceof Array && value.length === 0 && emptyArraysAllowed.indexOf(parameter) < 0) { continue; }\n\n      // If the parameter value is null, empty string, or undefined then apply its default value.\n      if(value === null || value === \"\" || value === undefined) { continue; }\n      // If it's a number with NaN value then also apply its default value.\n      // NOTE: JS does not allow \"value === NaN\", the following does the work:\n      else if(typeof(value) === 'number' && isNaN(value)) { continue; }\n\n      checked_value = UA.configuration_check.optional[parameter](value);\n      if (checked_value !== undefined) {\n        settings[parameter] = checked_value;\n      } else {\n        throw new SIP.Exceptions.ConfigurationError(parameter, value);\n      }\n    }\n  }\n\n  // Sanity Checks\n\n  // Connection recovery intervals\n  if(settings.connectionRecoveryMaxInterval < settings.connectionRecoveryMinInterval) {\n    throw new SIP.Exceptions.ConfigurationError('connectionRecoveryMaxInterval', settings.connectionRecoveryMaxInterval);\n  }\n\n  // Post Configuration Process\n\n  // Allow passing 0 number as displayName.\n  if (settings.displayName === 0) {\n    settings.displayName = '0';\n  }\n\n  // Instance-id for GRUU\n  if (!settings.instanceId) {\n    settings.instanceId = SIP.Utils.newUUID();\n  }\n\n  // sipjsId instance parameter. Static random tag of length 5\n  settings.sipjsId = SIP.Utils.createRandomToken(5);\n\n  // String containing settings.uri without scheme and user.\n  hostportParams = settings.uri.clone();\n  hostportParams.user = null;\n  settings.hostportParams = hostportParams.toString().replace(/^sip:/i, '');\n\n  /* Check whether authorizationUser is explicitly defined.\n   * Take 'settings.uri.user' value if not.\n   */\n  if (!settings.authorizationUser) {\n    settings.authorizationUser = settings.uri.user;\n  }\n\n  /* If no 'registrarServer' is set use the 'uri' value without user portion. */\n  if (!settings.registrarServer) {\n    registrarServer = settings.uri.clone();\n    registrarServer.user = null;\n    settings.registrarServer = registrarServer;\n  }\n\n  // User noAnswerTimeout\n  settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;\n\n  // Via Host\n  if (settings.hackIpInContact) {\n    settings.viaHost = SIP.Utils.getRandomTestNetIP();\n  }\n\n  this.contact = {\n    pub_gruu: null,\n    temp_gruu: null,\n    uri: new SIP.URI('sip', SIP.Utils.createRandomToken(8), settings.viaHost, null, {transport: ((settings.hackWssInTransport)?'wss':'ws')}),\n    toString: function(options){\n      options = options || {};\n\n      var\n        anonymous = options.anonymous || null,\n        outbound = options.outbound || null,\n        contact = '<';\n\n      if (anonymous) {\n        contact += (this.temp_gruu || ('sip:anonymous@anonymous.invalid;transport='+(settings.hackWssInTransport)?'wss':'ws')).toString();\n      } else {\n        contact += (this.pub_gruu || this.uri).toString();\n      }\n\n      if (outbound) {\n        contact += ';ob';\n      }\n\n      contact += '>';\n\n      return contact;\n    }\n  };\n\n  // media overrides mediaConstraints\n  SIP.Utils.optionsOverride(settings, 'media', 'mediaConstraints', true, this.logger);\n\n  // Fill the value of the configuration_skeleton\n  for(parameter in settings) {\n    UA.configuration_skeleton[parameter].value = settings[parameter];\n  }\n\n  Object.defineProperties(this.configuration, UA.configuration_skeleton);\n\n  // Clean UA.configuration_skeleton\n  for(parameter in settings) {\n    UA.configuration_skeleton[parameter].value = '';\n  }\n\n  this.logger.log('configuration parameters after validation:');\n  for(parameter in settings) {\n    switch(parameter) {\n      case 'uri':\n      case 'registrarServer':\n      case 'mediaHandlerFactory':\n        this.logger.log('· ' + parameter + ': ' + settings[parameter]);\n        break;\n      case 'password':\n        this.logger.log('· ' + parameter + ': ' + 'NOT SHOWN');\n        break;\n      default:\n        this.logger.log('· ' + parameter + ': ' + JSON.stringify(settings[parameter]));\n    }\n  }\n\n  return;\n};\n\n/**\n * Configuration Object skeleton.\n * @private\n */\nUA.configuration_skeleton = (function() {\n  var idx,  parameter,\n    skeleton = {},\n    parameters = [\n      // Internal parameters\n      \"sipjsId\",\n      \"hostportParams\",\n\n      // Optional user configurable parameters\n      \"uri\",\n      \"wsServers\",\n      \"authorizationUser\",\n      \"connectionRecoveryMaxInterval\",\n      \"connectionRecoveryMinInterval\",\n      \"displayName\",\n      \"hackViaTcp\", // false.\n      \"hackIpInContact\", //false\n      \"hackWssInTransport\", //false\n      \"instanceId\",\n      \"noAnswerTimeout\", // 30 seconds.\n      \"password\",\n      \"registerExpires\", // 600 seconds.\n      \"registrarServer\",\n      \"reliable\",\n      \"rel100\",\n      \"userAgentString\", //SIP.C.USER_AGENT\n      \"autostart\",\n      \"stunServers\",\n      \"traceSip\",\n      \"turnServers\",\n      \"usePreloadedRoute\",\n      \"wsServerMaxReconnection\",\n      \"wsServerReconnectionTimeout\",\n      \"mediaHandlerFactory\",\n      \"media\",\n      \"mediaConstraints\",\n\n      // Post-configuration generated parameters\n      \"via_core_value\",\n      \"viaHost\"\n    ];\n\n  for(idx in parameters) {\n    parameter = parameters[idx];\n    skeleton[parameter] = {\n      value: '',\n      writable: false,\n      configurable: false\n    };\n  }\n\n  skeleton['register'] = {\n    value: '',\n    writable: true,\n    configurable: false\n  };\n\n  return skeleton;\n}());\n\n/**\n * Configuration checker.\n * @private\n * @return {Boolean}\n */\nUA.configuration_check = {\n  mandatory: {\n  },\n\n  optional: {\n\n    uri: function(uri) {\n      var parsed;\n\n      if (!(/^sip:/i).test(uri)) {\n        uri = SIP.C.SIP + ':' + uri;\n      }\n      parsed = SIP.URI.parse(uri);\n\n      if(!parsed) {\n        return;\n      } else if(!parsed.user) {\n        return;\n      } else {\n        return parsed;\n      }\n    },\n\n    //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid\n    wsServers: function(wsServers) {\n      var idx, length, url;\n\n      /* Allow defining wsServers parameter as:\n       *  String: \"host\"\n       *  Array of Strings: [\"host1\", \"host2\"]\n       *  Array of Objects: [{ws_uri:\"host1\", weight:1}, {ws_uri:\"host2\", weight:0}]\n       *  Array of Objects and Strings: [{ws_uri:\"host1\"}, \"host2\"]\n       */\n      if (typeof wsServers === 'string') {\n        wsServers = [{ws_uri: wsServers}];\n      } else if (wsServers instanceof Array) {\n        length = wsServers.length;\n        for (idx = 0; idx < length; idx++) {\n          if (typeof wsServers[idx] === 'string'){\n            wsServers[idx] = {ws_uri: wsServers[idx]};\n          }\n        }\n      } else {\n        return;\n      }\n\n      if (wsServers.length === 0) {\n        return false;\n      }\n\n      length = wsServers.length;\n      for (idx = 0; idx < length; idx++) {\n        if (!wsServers[idx].ws_uri) {\n          return;\n        }\n        if (wsServers[idx].weight && !Number(wsServers[idx].weight)) {\n          return;\n        }\n\n        url = SIP.Grammar.parse(wsServers[idx].ws_uri, 'absoluteURI');\n\n        if(url === -1) {\n          return;\n        } else if(url.scheme !== 'wss' && url.scheme !== 'ws') {\n          return;\n        } else {\n          wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=ws;lr>';\n\n          if (!wsServers[idx].weight) {\n            wsServers[idx].weight = 0;\n          }\n\n          wsServers[idx].status = 0;\n          wsServers[idx].scheme = url.scheme.toUpperCase();\n        }\n      }\n      return wsServers;\n    },\n\n    authorizationUser: function(authorizationUser) {\n      if(SIP.Grammar.parse('\"'+ authorizationUser +'\"', 'quoted_string') === -1) {\n        return;\n      } else {\n        return authorizationUser;\n      }\n    },\n\n    connectionRecoveryMaxInterval: function(connectionRecoveryMaxInterval) {\n      var value;\n      if(SIP.Utils.isDecimal(connectionRecoveryMaxInterval)) {\n        value = Number(connectionRecoveryMaxInterval);\n        if(value > 0) {\n          return value;\n        }\n      }\n    },\n\n    connectionRecoveryMinInterval: function(connectionRecoveryMinInterval) {\n      var value;\n      if(SIP.Utils.isDecimal(connectionRecoveryMinInterval)) {\n        value = Number(connectionRecoveryMinInterval);\n        if(value > 0) {\n          return value;\n        }\n      }\n    },\n\n    displayName: function(displayName) {\n      if(SIP.Grammar.parse('\"' + displayName + '\"', 'displayName') === -1) {\n        return;\n      } else {\n        return displayName;\n      }\n    },\n\n    hackViaTcp: function(hackViaTcp) {\n      if (typeof hackViaTcp === 'boolean') {\n        return hackViaTcp;\n      }\n    },\n\n    hackIpInContact: function(hackIpInContact) {\n      if (typeof hackIpInContact === 'boolean') {\n        return hackIpInContact;\n      }\n    },\n\n    hackWssInTransport: function(hackWssInTransport) {\n      if (typeof hackWssInTransport === 'boolean') {\n        return hackWssInTransport;\n      }\n    },\n\n    instanceId: function(instanceId) {\n      if(typeof instanceId !== 'string') {\n        return;\n      }\n\n      if ((/^uuid:/i.test(instanceId))) {\n        instanceId = instanceId.substr(5);\n      }\n\n      if(SIP.Grammar.parse(instanceId, 'uuid') === -1) {\n        return;\n      } else {\n        return instanceId;\n      }\n    },\n\n    noAnswerTimeout: function(noAnswerTimeout) {\n      var value;\n      if (SIP.Utils.isDecimal(noAnswerTimeout)) {\n        value = Number(noAnswerTimeout);\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n\n    password: function(password) {\n      return String(password);\n    },\n\n    rel100: function(rel100) {\n      if(rel100 === SIP.C.supported.REQUIRED) {\n        return SIP.C.supported.REQUIRED;\n      } else if (rel100 === SIP.C.supported.SUPPORTED) {\n        return SIP.C.supported.SUPPORTED;\n      } else  {\n        return SIP.C.supported.UNSUPPORTED;\n      }\n    },\n\n    register: function(register) {\n      if (typeof register === 'boolean') {\n        return register;\n      }\n    },\n\n    registerExpires: function(registerExpires) {\n      var value;\n      if (SIP.Utils.isDecimal(registerExpires)) {\n        value = Number(registerExpires);\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n\n    registrarServer: function(registrarServer) {\n      var parsed;\n\n      if(typeof registrarServer !== 'string') {\n        return;\n      }\n\n      if (!/^sip:/i.test(registrarServer)) {\n        registrarServer = SIP.C.SIP + ':' + registrarServer;\n      }\n      parsed = SIP.URI.parse(registrarServer);\n\n      if(!parsed) {\n        return;\n      } else if(parsed.user) {\n        return;\n      } else {\n        return parsed;\n      }\n    },\n\n    stunServers: function(stunServers) {\n      var idx, length, stun_server;\n\n      if (typeof stunServers === 'string') {\n        stunServers = [stunServers];\n      } else if (!(stunServers instanceof Array)) {\n        return;\n      }\n\n      length = stunServers.length;\n      for (idx = 0; idx < length; idx++) {\n        stun_server = stunServers[idx];\n        if (!(/^stuns?:/.test(stun_server))) {\n          stun_server = 'stun:' + stun_server;\n        }\n\n        if(SIP.Grammar.parse(stun_server, 'stun_URI') === -1) {\n          return;\n        } else {\n          stunServers[idx] = stun_server;\n        }\n      }\n      return stunServers;\n    },\n\n    traceSip: function(traceSip) {\n      if (typeof traceSip === 'boolean') {\n        return traceSip;\n      }\n    },\n\n    turnServers: function(turnServers) {\n      var idx, length, turn_server, url;\n\n      if (turnServers instanceof Array) {\n        // Do nothing\n      } else {\n        turnServers = [turnServers];\n      }\n\n      length = turnServers.length;\n      for (idx = 0; idx < length; idx++) {\n        turn_server = turnServers[idx];\n        //Backwards compatibility: Allow defining the turn_server url with the 'server' property.\n        if (turn_server.server) {\n          turn_server.urls = [turn_server.server];\n        }\n\n        if (!turn_server.urls || !turn_server.username || !turn_server.password) {\n          return;\n        }\n\n        if (!(turn_server.urls instanceof Array)) {\n          turn_server.urls = [turn_server.urls];\n        }\n\n        length = turn_server.urls.length;\n        for (idx = 0; idx < length; idx++) {\n          url = turn_server.urls[idx];\n\n          if (!(/^turns?:/.test(url))) {\n            url = 'turn:' + url;\n          }\n\n          if(SIP.Grammar.parse(url, 'turn_URI') === -1) {\n            return;\n          }\n        }\n      }\n      return turnServers;\n    },\n\n    userAgentString: function(userAgentString) {\n      if (typeof userAgentString === 'string') {\n        return userAgentString;\n      }\n    },\n\n    usePreloadedRoute: function(usePreloadedRoute) {\n      if (typeof usePreloadedRoute === 'boolean') {\n        return usePreloadedRoute;\n      }\n    },\n\n    wsServerMaxReconnection: function(wsServerMaxReconnection) {\n      var value;\n      if (SIP.Utils.isDecimal(wsServerMaxReconnection)) {\n        value = Number(wsServerMaxReconnection);\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n\n    wsServerReconnectionTimeout: function(wsServerReconnectionTimeout) {\n      var value;\n      if (SIP.Utils.isDecimal(wsServerReconnectionTimeout)) {\n        value = Number(wsServerReconnectionTimeout);\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n\n    autostart: function(autostart) {\n      if (typeof autostart === 'boolean') {\n        return autostart;\n      }\n    },\n\n    mediaHandlerFactory: function(mediaHandlerFactory) {\n      if (mediaHandlerFactory instanceof Function) {\n        return mediaHandlerFactory;\n      }\n    }\n  }\n};\n\nUA.C = C;\nSIP.UA = UA;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/UA.js\n ** module id = 30\n ** module chunks = 0\n **/","/**\n * @fileoverview Hacks - This file contains all of the things we\n * wish we didn't have to do, just for interop.  It is similar to\n * Utils, which provides actually useful and relevant functions for\n * a SIP library. Methods in this file are grouped by vendor, so\n * as to most easily track when particular hacks may not be necessary anymore.\n */\n\nmodule.exports = function (SIP) {\nvar Hacks = {\n  AllBrowsers: {\n    maskDtls: function (message) {\n      if (message.body) {\n        message.body = message.body.replace(/ UDP\\/TLS\\/RTP\\/SAVP/gmi, \" RTP/SAVP\");\n      }\n    },\n    unmaskDtls: function (sdp) {\n      /**\n       * Chrome does not handle DTLS correctly (Canaray does, but not production)\n       * keeping Chrome as SDES until DTLS is fixed (comment out 'is_opera' condition)\n       *\n       * UPDATE: May 21, 2014\n       * Chrome 35 now properly defaults to DTLS.  Only Opera remains using SDES\n       *\n       * UPDATE: 2014-09-24\n       * Opera now supports DTLS by default as well.\n       *\n       **/\n      return sdp.replace(/ RTP\\/SAVP/gmi, \" UDP/TLS/RTP/SAVP\");\n    }\n  },\n  Firefox: {\n    /* Condition to detect if hacks are applicable */\n    isFirefox: function () {\n      return window.mozRTCPeerConnection !== undefined;\n    },\n\n    cannotHandleExtraWhitespace: function (message) {\n      if (this.isFirefox() && message.body) {\n        message.body = message.body.replace(/ \\r\\n/g, \"\\r\\n\");\n      }\n    },\n\n    hasMissingCLineInSDP: function (sdp) {\n      /*\n       * This is a Firefox hack to insert valid sdp when getDescription is\n       * called with the constraint offerToReceiveVideo = false.\n       * We search for either a c-line at the top of the sdp above all\n       * m-lines. If that does not exist then we search for a c-line\n       * beneath each m-line. If it is missing a c-line, we insert\n       * a fake c-line with the ip address 0.0.0.0. This is then valid\n       * sdp and no media will be sent for that m-line.\n       *\n       * Valid SDP is:\n       * m=\n       * i=\n       * c=\n       */\n      var insertAt, mlines;\n      if (sdp.indexOf('c=') > sdp.indexOf('m=')) {\n\n        // Find all m= lines\n        mlines = sdp.match(/m=.*\\r\\n.*/g);\n        for (var i=0; i<mlines.length; i++) {\n\n          // If it has an i= line, check if the next line is the c= line\n          if (mlines[i].toString().search(/i=.*/) >= 0) {\n            insertAt = sdp.indexOf(mlines[i].toString())+mlines[i].toString().length;\n            if (sdp.substr(insertAt,2)!=='c=') {\n              sdp = sdp.substr(0,insertAt) + '\\r\\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);\n            }\n\n          // else add the C line if it's missing\n          } else if (mlines[i].toString().search(/c=.*/) < 0) {\n            insertAt = sdp.indexOf(mlines[i].toString().match(/.*/))+mlines[i].toString().match(/.*/).toString().length;\n            sdp = sdp.substr(0,insertAt) + '\\r\\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);\n          }\n        }\n      }\n      return sdp;\n    },\n\n    hasIncompatibleCLineWithSomeSIPEndpoints: function(sdp) {\n      /*\n       * Firefox appears to be following https://tools.ietf.org/html/rfc5245#section-9.1.1.1\n       * and using a c line IP address of 0.0.0.0. This is completely valid, however it is\n       * causing some endpoints (such as FreeSWITCH) to interpret the SDP as being on hold\n       * https://freeswitch.org/jira/browse/FS-6955. To get around this issue we pull the\n       * replace the c line with 1.1.1.1 which SIP clients do not interpret as hold.\n       * This makes the other endpoint believe that the call is not on hold and audio flows\n       * because ICE determines the media pathway (not the c line).\n       */\n      return sdp.replace(/(0\\.0\\.0\\.0)/gmi, SIP.Utils.getRandomTestNetIP());\n    }\n  },\n\n  Chrome: {\n    needsExplicitlyInactiveSDP: function (sdp) {\n      var sub, index;\n\n      if (Hacks.Firefox.isFirefox()) { // Fix this in Firefox before sending\n        index = sdp.indexOf('m=video 0');\n        if (index !== -1) {\n          sub = sdp.substr(index);\n          sub = sub.replace(/\\r\\nc=IN IP4.*\\r\\n$/,\n                            '\\r\\nc=IN IP4 0.0.0.0\\r\\na=inactive\\r\\n');\n          return sdp.substr(0, index) + sub;\n        }\n      }\n      return sdp;\n    },\n\n    getsConfusedAboutGUM: function (session) {\n      if (session.mediaHandler) {\n        session.mediaHandler.close();\n      }\n    }\n  }\n};\n\nreturn Hacks;\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Hacks.js\n ** module id = 31\n ** module chunks = 0\n **/","/**\n * @fileoverview Incoming SIP Message Sanity Check\n */\n\n/**\n * SIP message sanity check.\n * @augments SIP\n * @function\n * @param {SIP.IncomingMessage} message\n * @param {SIP.UA} ua\n * @param {SIP.Transport} transport\n * @returns {Boolean}\n */\nmodule.exports = function (SIP) {\nvar sanityCheck,\n logger,\n message, ua, transport,\n requests = [],\n responses = [],\n all = [];\n\n/*\n * Sanity Check for incoming Messages\n *\n * Requests:\n *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme\n *  - _rfc3261_16_3_4_ Receive a Request already sent by us\n *   Does not look at via sent-by but at sipjsId, which is inserted as\n *   a prefix in all initial requests generated by the ua\n *  - _rfc3261_18_3_request_ Body Content-Length\n *  - _rfc3261_8_2_2_2_ Merged Requests\n *\n * Responses:\n *  - _rfc3261_8_1_3_3_ Multiple Via headers\n *  - _rfc3261_18_1_2_ sent-by mismatch\n *  - _rfc3261_18_3_response_ Body Content-Length\n *\n * All:\n *  - Minimum headers in a SIP message\n */\n\n// Sanity Check functions for requests\nfunction rfc3261_8_2_2_1() {\n  if(!message.ruri || message.ruri.scheme !== 'sip') {\n    reply(416);\n    return false;\n  }\n}\n\nfunction rfc3261_16_3_4() {\n  if(!message.to_tag) {\n    if(message.call_id.substr(0, 5) === ua.configuration.sipjsId) {\n      reply(482);\n      return false;\n    }\n  }\n}\n\nfunction rfc3261_18_3_request() {\n  var len = SIP.Utils.str_utf8_length(message.body),\n  contentLength = message.getHeader('content-length');\n\n  if(len < contentLength) {\n    reply(400);\n    return false;\n  }\n}\n\nfunction rfc3261_8_2_2_2() {\n  var tr, idx,\n    fromTag = message.from_tag,\n    call_id = message.call_id,\n    cseq = message.cseq;\n\n  if(!message.to_tag) {\n    if(message.method === SIP.C.INVITE) {\n      tr = ua.transactions.ist[message.via_branch];\n      if(tr) {\n        return;\n      } else {\n        for(idx in ua.transactions.ist) {\n          tr = ua.transactions.ist[idx];\n          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n            reply(482);\n            return false;\n          }\n        }\n      }\n    } else {\n      tr = ua.transactions.nist[message.via_branch];\n      if(tr) {\n        return;\n      } else {\n        for(idx in ua.transactions.nist) {\n          tr = ua.transactions.nist[idx];\n          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n            reply(482);\n            return false;\n          }\n        }\n      }\n    }\n  }\n}\n\n// Sanity Check functions for responses\nfunction rfc3261_8_1_3_3() {\n  if(message.getHeaders('via').length > 1) {\n    logger.warn('More than one Via header field present in the response. Dropping the response');\n    return false;\n  }\n}\n\nfunction rfc3261_18_1_2() {\n  var viaHost = ua.configuration.viaHost;\n  if(message.via.host !== viaHost || message.via.port !== undefined) {\n    logger.warn('Via sent-by in the response does not match UA Via host value. Dropping the response');\n    return false;\n  }\n}\n\nfunction rfc3261_18_3_response() {\n  var\n    len = SIP.Utils.str_utf8_length(message.body),\n    contentLength = message.getHeader('content-length');\n\n    if(len < contentLength) {\n      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');\n      return false;\n    }\n}\n\n// Sanity Check functions for requests and responses\nfunction minimumHeaders() {\n  var\n    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],\n    idx = mandatoryHeaders.length;\n\n  while(idx--) {\n    if(!message.hasHeader(mandatoryHeaders[idx])) {\n      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');\n      return false;\n    }\n  }\n}\n\n// Reply\nfunction reply(status_code) {\n  var to,\n    response = \"SIP/2.0 \" + status_code + \" \" + SIP.C.REASON_PHRASE[status_code] + \"\\r\\n\",\n    vias = message.getHeaders('via'),\n    length = vias.length,\n    idx = 0;\n\n  for(idx; idx < length; idx++) {\n    response += \"Via: \" + vias[idx] + \"\\r\\n\";\n  }\n\n  to = message.getHeader('To');\n\n  if(!message.to_tag) {\n    to += ';tag=' + SIP.Utils.newTag();\n  }\n\n  response += \"To: \" + to + \"\\r\\n\";\n  response += \"From: \" + message.getHeader('From') + \"\\r\\n\";\n  response += \"Call-ID: \" + message.call_id + \"\\r\\n\";\n  response += \"CSeq: \" + message.cseq + \" \" + message.method + \"\\r\\n\";\n  response += \"\\r\\n\";\n\n  transport.send(response);\n}\n\nrequests.push(rfc3261_8_2_2_1);\nrequests.push(rfc3261_16_3_4);\nrequests.push(rfc3261_18_3_request);\nrequests.push(rfc3261_8_2_2_2);\n\nresponses.push(rfc3261_8_1_3_3);\nresponses.push(rfc3261_18_1_2);\nresponses.push(rfc3261_18_3_response);\n\nall.push(minimumHeaders);\n\nsanityCheck = function(m, u, t) {\n  var len, pass;\n\n  message = m;\n  ua = u;\n  transport = t;\n\n  logger = ua.getLogger('sip.sanitycheck');\n\n  len = all.length;\n  while(len--) {\n    pass = all[len](message);\n    if(pass === false) {\n      return false;\n    }\n  }\n\n  if(message instanceof SIP.IncomingRequest) {\n    len = requests.length;\n    while(len--) {\n      pass = requests[len](message);\n      if(pass === false) {\n        return false;\n      }\n    }\n  }\n\n  else if(message instanceof SIP.IncomingResponse) {\n    len = responses.length;\n    while(len--) {\n      pass = responses[len](message);\n      if(pass === false) {\n        return false;\n      }\n    }\n  }\n\n  //Everything is OK\n  return true;\n};\n\nSIP.sanityCheck = sanityCheck;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/SanityCheck.js\n ** module id = 32\n ** module chunks = 0\n **/","\n/**\n * @fileoverview SIP Digest Authentication\n */\n\n/**\n * SIP Digest Authentication.\n * @augments SIP.\n * @function Digest Authentication\n * @param {SIP.UA} ua\n */\nmodule.exports = function (Utils) {\nvar DigestAuthentication;\n\nDigestAuthentication = function(ua) {\n  this.logger = ua.getLogger('sipjs.digestauthentication');\n  this.username = ua.configuration.authorizationUser;\n  this.password = ua.configuration.password;\n  this.cnonce = null;\n  this.nc = 0;\n  this.ncHex = '00000000';\n  this.response = null;\n};\n\n\n/**\n* Performs Digest authentication given a SIP request and the challenge\n* received in a response to that request.\n* Returns true if credentials were successfully generated, false otherwise.\n*\n* @param {SIP.OutgoingRequest} request\n* @param {Object} challenge\n*/\nDigestAuthentication.prototype.authenticate = function(request, challenge) {\n  // Inspect and validate the challenge.\n\n  this.algorithm = challenge.algorithm;\n  this.realm = challenge.realm;\n  this.nonce = challenge.nonce;\n  this.opaque = challenge.opaque;\n  this.stale = challenge.stale;\n\n  if (this.algorithm) {\n    if (this.algorithm !== 'MD5') {\n      this.logger.warn('challenge with Digest algorithm different than \"MD5\", authentication aborted');\n      return false;\n    }\n  } else {\n    this.algorithm = 'MD5';\n  }\n\n  if (! this.realm) {\n    this.logger.warn('challenge without Digest realm, authentication aborted');\n    return false;\n  }\n\n  if (! this.nonce) {\n    this.logger.warn('challenge without Digest nonce, authentication aborted');\n    return false;\n  }\n\n  // 'qop' can contain a list of values (Array). Let's choose just one.\n  if (challenge.qop) {\n    if (challenge.qop.indexOf('auth') > -1) {\n      this.qop = 'auth';\n    } else if (challenge.qop.indexOf('auth-int') > -1) {\n      this.qop = 'auth-int';\n    } else {\n      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.\n      this.logger.warn('challenge without Digest qop different than \"auth\" or \"auth-int\", authentication aborted');\n      return false;\n    }\n  } else {\n    this.qop = null;\n  }\n\n  // Fill other attributes.\n\n  this.method = request.method;\n  this.uri = request.ruri;\n  this.cnonce = Utils.createRandomToken(12);\n  this.nc += 1;\n  this.updateNcHex();\n\n  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.\n  if (this.nc === 4294967296) {\n    this.nc = 1;\n    this.ncHex = '00000001';\n  }\n\n  // Calculate the Digest \"response\" value.\n  this.calculateResponse();\n\n  return true;\n};\n\n\n/**\n* Generate Digest 'response' value.\n* @private\n*/\nDigestAuthentication.prototype.calculateResponse = function() {\n  var ha1, ha2;\n\n  // HA1 = MD5(A1) = MD5(username:realm:password)\n  ha1 = Utils.calculateMD5(this.username + \":\" + this.realm + \":\" + this.password);\n\n  if (this.qop === 'auth') {\n    // HA2 = MD5(A2) = MD5(method:digestURI)\n    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri);\n    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth:\" + ha2);\n\n  } else if (this.qop === 'auth-int') {\n    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))\n    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri + \":\" + Utils.calculateMD5(this.body ? this.body : \"\"));\n    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth-int:\" + ha2);\n\n  } else if (this.qop === null) {\n    // HA2 = MD5(A2) = MD5(method:digestURI)\n    ha2 = Utils.calculateMD5(this.method + \":\" + this.uri);\n    // response = MD5(HA1:nonce:HA2)\n    this.response = Utils.calculateMD5(ha1 + \":\" + this.nonce + \":\" + ha2);\n  }\n};\n\n\n/**\n* Return the Proxy-Authorization or WWW-Authorization header value.\n*/\nDigestAuthentication.prototype.toString = function() {\n  var auth_params = [];\n\n  if (! this.response) {\n    throw new Error('response field does not exist, cannot generate Authorization header');\n  }\n\n  auth_params.push('algorithm=' + this.algorithm);\n  auth_params.push('username=\"' + this.username + '\"');\n  auth_params.push('realm=\"' + this.realm + '\"');\n  auth_params.push('nonce=\"' + this.nonce + '\"');\n  auth_params.push('uri=\"' + this.uri + '\"');\n  auth_params.push('response=\"' + this.response + '\"');\n  if (this.opaque) {\n    auth_params.push('opaque=\"' + this.opaque + '\"');\n  }\n  if (this.qop) {\n    auth_params.push('qop=' + this.qop);\n    auth_params.push('cnonce=\"' + this.cnonce + '\"');\n    auth_params.push('nc=' + this.ncHex);\n  }\n\n  return 'Digest ' + auth_params.join(', ');\n};\n\n\n/**\n* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.\n* @private\n*/\nDigestAuthentication.prototype.updateNcHex = function() {\n  var hex = Number(this.nc).toString(16);\n  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;\n};\n\nreturn DigestAuthentication;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/DigestAuthentication.js\n ** module id = 33\n ** module chunks = 0\n **/","/* jshint ignore:start */\nmodule.exports = function(SIP) {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleIndices = { Contact: 118, Name_Addr_Header: 155, Record_Route: 175, Request_Response: 81, SIP_URI: 45, Subscription_State: 182, Via: 190, absoluteURI: 84, Call_ID: 117, Content_Disposition: 129, Content_Length: 134, Content_Type: 135, CSeq: 145, displayName: 121, Event: 148, From: 150, host: 52, Max_Forwards: 153, Proxy_Authenticate: 156, quoted_string: 40, Refer_To: 177, stun_URI: 209, To: 188, turn_URI: 216, uuid: 219, WWW_Authenticate: 205, challenge: 157 },\n        peg$startRuleIndex   = 118,\n\n        peg$consts = [\n          \"\\r\\n\",\n          { type: \"literal\", value: \"\\r\\n\", description: \"\\\"\\\\r\\\\n\\\"\" },\n          /^[0-9]/,\n          { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n          /^[a-zA-Z]/,\n          { type: \"class\", value: \"[a-zA-Z]\", description: \"[a-zA-Z]\" },\n          /^[0-9a-fA-F]/,\n          { type: \"class\", value: \"[0-9a-fA-F]\", description: \"[0-9a-fA-F]\" },\n          /^[\\0-\\xFF]/,\n          { type: \"class\", value: \"[\\\\0-\\\\xFF]\", description: \"[\\\\0-\\\\xFF]\" },\n          /^[\"]/,\n          { type: \"class\", value: \"[\\\"]\", description: \"[\\\"]\" },\n          \" \",\n          { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n          \"\\t\",\n          { type: \"literal\", value: \"\\t\", description: \"\\\"\\\\t\\\"\" },\n          /^[a-zA-Z0-9]/,\n          { type: \"class\", value: \"[a-zA-Z0-9]\", description: \"[a-zA-Z0-9]\" },\n          \";\",\n          { type: \"literal\", value: \";\", description: \"\\\";\\\"\" },\n          \"/\",\n          { type: \"literal\", value: \"/\", description: \"\\\"/\\\"\" },\n          \"?\",\n          { type: \"literal\", value: \"?\", description: \"\\\"?\\\"\" },\n          \":\",\n          { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n          \"@\",\n          { type: \"literal\", value: \"@\", description: \"\\\"@\\\"\" },\n          \"&\",\n          { type: \"literal\", value: \"&\", description: \"\\\"&\\\"\" },\n          \"=\",\n          { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n          \"+\",\n          { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\n          \"$\",\n          { type: \"literal\", value: \"$\", description: \"\\\"$\\\"\" },\n          \",\",\n          { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n          \"-\",\n          { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n          \"_\",\n          { type: \"literal\", value: \"_\", description: \"\\\"_\\\"\" },\n          \".\",\n          { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n          \"!\",\n          { type: \"literal\", value: \"!\", description: \"\\\"!\\\"\" },\n          \"~\",\n          { type: \"literal\", value: \"~\", description: \"\\\"~\\\"\" },\n          \"*\",\n          { type: \"literal\", value: \"*\", description: \"\\\"*\\\"\" },\n          \"'\",\n          { type: \"literal\", value: \"'\", description: \"\\\"'\\\"\" },\n          \"(\",\n          { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n          \")\",\n          { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n          peg$FAILED,\n          \"%\",\n          { type: \"literal\", value: \"%\", description: \"\\\"%\\\"\" },\n          function(escaped) {return escaped.join(''); },\n          null,\n          [],\n          function() {return \" \"; },\n          function() {return ':'; },\n          function() {\n                              return text(); },\n          /^[!-~]/,\n          { type: \"class\", value: \"[!-~]\", description: \"[!-~]\" },\n          /^[\\x80-\\uFFFF]/,\n          { type: \"class\", value: \"[\\\\x80-\\\\uFFFF]\", description: \"[\\\\x80-\\\\uFFFF]\" },\n          /^[\\x80-\\xBF]/,\n          { type: \"class\", value: \"[\\\\x80-\\\\xBF]\", description: \"[\\\\x80-\\\\xBF]\" },\n          /^[a-f]/,\n          { type: \"class\", value: \"[a-f]\", description: \"[a-f]\" },\n          \"`\",\n          { type: \"literal\", value: \"`\", description: \"\\\"`\\\"\" },\n          function() {\n                            return text(); },\n          \"<\",\n          { type: \"literal\", value: \"<\", description: \"\\\"<\\\"\" },\n          \">\",\n          { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n          \"\\\\\",\n          { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\n          \"[\",\n          { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n          \"]\",\n          { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n          \"{\",\n          { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\n          \"}\",\n          { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n          function() {return \"*\"; },\n          function() {return \"/\"; },\n          function() {return \"=\"; },\n          function() {return \"(\"; },\n          function() {return \")\"; },\n          function() {return \">\"; },\n          function() {return \"<\"; },\n          function() {return \",\"; },\n          function() {return \";\"; },\n          function() {return \":\"; },\n          function() {return \"\\\"\"; },\n          /^[!-']/,\n          { type: \"class\", value: \"[!-']\", description: \"[!-']\" },\n          /^[*-[]/,\n          { type: \"class\", value: \"[*-[]\", description: \"[*-[]\" },\n          /^[\\]-~]/,\n          { type: \"class\", value: \"[\\\\]-~]\", description: \"[\\\\]-~]\" },\n          function(contents) {\n                                  return contents; },\n          /^[#-[]/,\n          { type: \"class\", value: \"[#-[]\", description: \"[#-[]\" },\n          /^[\\0-\\t]/,\n          { type: \"class\", value: \"[\\\\0-\\\\t]\", description: \"[\\\\0-\\\\t]\" },\n          /^[\\x0B-\\f]/,\n          { type: \"class\", value: \"[\\\\x0B-\\\\f]\", description: \"[\\\\x0B-\\\\f]\" },\n          /^[\\x0E-]/,\n          { type: \"class\", value: \"[\\\\x0E-]\", description: \"[\\\\x0E-]\" },\n          function() {\n                                  data.uri = new SIP.URI(data.scheme, data.user, data.host, data.port);\n                                  delete data.scheme;\n                                  delete data.user;\n                                  delete data.host;\n                                  delete data.host_type;\n                                  delete data.port;\n                                },\n          function() {\n                                  data.uri = new SIP.URI(data.scheme, data.user, data.host, data.port, data.uri_params, data.uri_headers);\n                                  delete data.scheme;\n                                  delete data.user;\n                                  delete data.host;\n                                  delete data.host_type;\n                                  delete data.port;\n                                  delete data.uri_params;\n\n                                  if (options.startRule === 'SIP_URI') { data = data.uri;}\n                                },\n          \"sips\",\n          { type: \"literal\", value: \"sips\", description: \"\\\"sips\\\"\" },\n          \"sip\",\n          { type: \"literal\", value: \"sip\", description: \"\\\"sip\\\"\" },\n          function(uri_scheme) {\n                              data.scheme = uri_scheme.toLowerCase(); },\n          function() {\n                              data.user = decodeURIComponent(text().slice(0, -1));},\n          function() {\n                              data.password = text(); },\n          function() {\n                              data.host = text().toLowerCase();\n                              return data.host; },\n          function() {\n                            data.host_type = 'domain';\n                            return text(); },\n          /^[a-zA-Z0-9_\\-]/,\n          { type: \"class\", value: \"[a-zA-Z0-9_\\\\-]\", description: \"[a-zA-Z0-9_\\\\-]\" },\n          /^[a-zA-Z0-9\\-]/,\n          { type: \"class\", value: \"[a-zA-Z0-9\\\\-]\", description: \"[a-zA-Z0-9\\\\-]\" },\n          function() {\n                              data.host_type = 'IPv6';\n                              return text(); },\n          \"::\",\n          { type: \"literal\", value: \"::\", description: \"\\\"::\\\"\" },\n          function() {\n                            data.host_type = 'IPv6';\n                            return text(); },\n          function() {\n                              data.host_type = 'IPv4';\n                              return text(); },\n          \"25\",\n          { type: \"literal\", value: \"25\", description: \"\\\"25\\\"\" },\n          /^[0-5]/,\n          { type: \"class\", value: \"[0-5]\", description: \"[0-5]\" },\n          \"2\",\n          { type: \"literal\", value: \"2\", description: \"\\\"2\\\"\" },\n          /^[0-4]/,\n          { type: \"class\", value: \"[0-4]\", description: \"[0-4]\" },\n          \"1\",\n          { type: \"literal\", value: \"1\", description: \"\\\"1\\\"\" },\n          /^[1-9]/,\n          { type: \"class\", value: \"[1-9]\", description: \"[1-9]\" },\n          function(port) {\n                              port = parseInt(port.join(''));\n                              data.port = port;\n                              return port; },\n          \"transport=\",\n          { type: \"literal\", value: \"transport=\", description: \"\\\"transport=\\\"\" },\n          \"udp\",\n          { type: \"literal\", value: \"udp\", description: \"\\\"udp\\\"\" },\n          \"tcp\",\n          { type: \"literal\", value: \"tcp\", description: \"\\\"tcp\\\"\" },\n          \"sctp\",\n          { type: \"literal\", value: \"sctp\", description: \"\\\"sctp\\\"\" },\n          \"tls\",\n          { type: \"literal\", value: \"tls\", description: \"\\\"tls\\\"\" },\n          function(transport) {\n                                if(!data.uri_params) data.uri_params={};\n                                data.uri_params['transport'] = transport.toLowerCase(); },\n          \"user=\",\n          { type: \"literal\", value: \"user=\", description: \"\\\"user=\\\"\" },\n          \"phone\",\n          { type: \"literal\", value: \"phone\", description: \"\\\"phone\\\"\" },\n          \"ip\",\n          { type: \"literal\", value: \"ip\", description: \"\\\"ip\\\"\" },\n          function(user) {\n                                if(!data.uri_params) data.uri_params={};\n                                data.uri_params['user'] = user.toLowerCase(); },\n          \"method=\",\n          { type: \"literal\", value: \"method=\", description: \"\\\"method=\\\"\" },\n          function(method) {\n                                if(!data.uri_params) data.uri_params={};\n                                data.uri_params['method'] = method; },\n          \"ttl=\",\n          { type: \"literal\", value: \"ttl=\", description: \"\\\"ttl=\\\"\" },\n          function(ttl) {\n                                if(!data.params) data.params={};\n                                data.params['ttl'] = ttl; },\n          \"maddr=\",\n          { type: \"literal\", value: \"maddr=\", description: \"\\\"maddr=\\\"\" },\n          function(maddr) {\n                                if(!data.uri_params) data.uri_params={};\n                                data.uri_params['maddr'] = maddr; },\n          \"lr\",\n          { type: \"literal\", value: \"lr\", description: \"\\\"lr\\\"\" },\n          function() {\n                                if(!data.uri_params) data.uri_params={};\n                                data.uri_params['lr'] = undefined; },\n          function(param, value) {\n                                if(!data.uri_params) data.uri_params = {};\n                                if (value === null){\n                                  value = undefined;\n                                }\n                                else {\n                                  value = value[1];\n                                }\n                                data.uri_params[param.toLowerCase()] = value && value.toLowerCase();},\n          function(pname) {return pname.join(''); },\n          function(pvalue) {return pvalue.join(''); },\n          function(hname, hvalue) {\n                                hname = hname.join('').toLowerCase();\n                                hvalue = hvalue.join('');\n                                if(!data.uri_headers) data.uri_headers = {};\n                                if (!data.uri_headers[hname]) {\n                                  data.uri_headers[hname] = [hvalue];\n                                } else {\n                                  data.uri_headers[hname].push(hvalue);\n                                }},\n          function() {\n                                // lots of tests fail if this isn't guarded...\n                                if (options.startRule === 'Refer_To') {\n                                  data.uri = new SIP.URI(data.scheme, data.user, data.host, data.port, data.uri_params, data.uri_headers);\n                                  delete data.scheme;\n                                  delete data.user;\n                                  delete data.host;\n                                  delete data.host_type;\n                                  delete data.port;\n                                  delete data.uri_params;\n                                }\n                              },\n          \"//\",\n          { type: \"literal\", value: \"//\", description: \"\\\"//\\\"\" },\n          function() {\n                              data.scheme= text(); },\n          { type: \"literal\", value: \"SIP\", description: \"\\\"SIP\\\"\" },\n          function() {\n                              data.sip_version = text(); },\n          \"INVITE\",\n          { type: \"literal\", value: \"INVITE\", description: \"\\\"INVITE\\\"\" },\n          \"ACK\",\n          { type: \"literal\", value: \"ACK\", description: \"\\\"ACK\\\"\" },\n          \"VXACH\",\n          { type: \"literal\", value: \"VXACH\", description: \"\\\"VXACH\\\"\" },\n          \"OPTIONS\",\n          { type: \"literal\", value: \"OPTIONS\", description: \"\\\"OPTIONS\\\"\" },\n          \"BYE\",\n          { type: \"literal\", value: \"BYE\", description: \"\\\"BYE\\\"\" },\n          \"CANCEL\",\n          { type: \"literal\", value: \"CANCEL\", description: \"\\\"CANCEL\\\"\" },\n          \"REGISTER\",\n          { type: \"literal\", value: \"REGISTER\", description: \"\\\"REGISTER\\\"\" },\n          \"SUBSCRIBE\",\n          { type: \"literal\", value: \"SUBSCRIBE\", description: \"\\\"SUBSCRIBE\\\"\" },\n          \"NOTIFY\",\n          { type: \"literal\", value: \"NOTIFY\", description: \"\\\"NOTIFY\\\"\" },\n          \"REFER\",\n          { type: \"literal\", value: \"REFER\", description: \"\\\"REFER\\\"\" },\n          function() {\n\n                              data.method = text();\n                              return data.method; },\n          function(status_code) {\n                            data.status_code = parseInt(status_code.join('')); },\n          function() {\n                            data.reason_phrase = text(); },\n          function() {\n                        data = text(); },\n          function() {\n                                  var idx, length;\n                                  length = data.multi_header.length;\n                                  for (idx = 0; idx < length; idx++) {\n                                    if (data.multi_header[idx].parsed === null) {\n                                      data = null;\n                                      break;\n                                    }\n                                  }\n                                  if (data !== null) {\n                                    data = data.multi_header;\n                                  } else {\n                                    data = -1;\n                                  }},\n          function() {\n                                  var header;\n                                  if(!data.multi_header) data.multi_header = [];\n                                  try {\n                                    header = new SIP.NameAddrHeader(data.uri, data.displayName, data.params);\n                                    delete data.uri;\n                                    delete data.displayName;\n                                    delete data.params;\n                                  } catch(e) {\n                                    header = null;\n                                  }\n                                  data.multi_header.push( { 'position': peg$currPos,\n                                                            'offset': offset(),\n                                                            'parsed': header\n                                                          });},\n          function(displayName) {\n                                  displayName = text().trim();\n                                  if (displayName[0] === '\\\"') {\n                                    displayName = displayName.substring(1, displayName.length-1);\n                                  }\n                                  data.displayName = displayName; },\n          \"q\",\n          { type: \"literal\", value: \"q\", description: \"\\\"q\\\"\" },\n          function(q) {\n                                  if(!data.params) data.params = {};\n                                  data.params['q'] = q; },\n          \"expires\",\n          { type: \"literal\", value: \"expires\", description: \"\\\"expires\\\"\" },\n          function(expires) {\n                                  if(!data.params) data.params = {};\n                                  data.params['expires'] = expires; },\n          function(delta_seconds) {\n                                  return parseInt(delta_seconds.join('')); },\n          \"0\",\n          { type: \"literal\", value: \"0\", description: \"\\\"0\\\"\" },\n          function() {\n                                  return parseFloat(text()); },\n          function(param, value) {\n                                  if(!data.params) data.params = {};\n                                  if (value === null){\n                                    value = undefined;\n                                  }\n                                  else {\n                                    value = value[1];\n                                  }\n                                  data.params[param.toLowerCase()] = value;},\n          \"render\",\n          { type: \"literal\", value: \"render\", description: \"\\\"render\\\"\" },\n          \"session\",\n          { type: \"literal\", value: \"session\", description: \"\\\"session\\\"\" },\n          \"icon\",\n          { type: \"literal\", value: \"icon\", description: \"\\\"icon\\\"\" },\n          \"alert\",\n          { type: \"literal\", value: \"alert\", description: \"\\\"alert\\\"\" },\n          function() {\n                                      if (options.startRule === 'Content_Disposition') {\n                                        data.type = text().toLowerCase();\n                                      }\n                                    },\n          \"handling\",\n          { type: \"literal\", value: \"handling\", description: \"\\\"handling\\\"\" },\n          \"optional\",\n          { type: \"literal\", value: \"optional\", description: \"\\\"optional\\\"\" },\n          \"required\",\n          { type: \"literal\", value: \"required\", description: \"\\\"required\\\"\" },\n          function(length) {\n                                  data = parseInt(length.join('')); },\n          function() {\n                                  data = text(); },\n          \"text\",\n          { type: \"literal\", value: \"text\", description: \"\\\"text\\\"\" },\n          \"image\",\n          { type: \"literal\", value: \"image\", description: \"\\\"image\\\"\" },\n          \"audio\",\n          { type: \"literal\", value: \"audio\", description: \"\\\"audio\\\"\" },\n          \"video\",\n          { type: \"literal\", value: \"video\", description: \"\\\"video\\\"\" },\n          \"application\",\n          { type: \"literal\", value: \"application\", description: \"\\\"application\\\"\" },\n          \"message\",\n          { type: \"literal\", value: \"message\", description: \"\\\"message\\\"\" },\n          \"multipart\",\n          { type: \"literal\", value: \"multipart\", description: \"\\\"multipart\\\"\" },\n          \"x-\",\n          { type: \"literal\", value: \"x-\", description: \"\\\"x-\\\"\" },\n          function(cseq_value) {\n                            data.value=parseInt(cseq_value.join('')); },\n          function(expires) {data = expires; },\n          function(event_type) {\n                                 data.event = event_type.toLowerCase(); },\n          function() {\n                          var tag = data.tag;\n                            data = new SIP.NameAddrHeader(data.uri, data.displayName, data.params);\n                            if (tag) {data.setParam('tag',tag)}\n                          },\n          \"tag\",\n          { type: \"literal\", value: \"tag\", description: \"\\\"tag\\\"\" },\n          function(tag) {data.tag = tag; },\n          function(forwards) {\n                            data = parseInt(forwards.join('')); },\n          function(min_expires) {data = min_expires; },\n          function() {\n                                  data = new SIP.NameAddrHeader(data.uri, data.displayName, data.params);\n                                },\n          \"digest\",\n          { type: \"literal\", value: \"Digest\", description: \"\\\"Digest\\\"\" },\n          \"realm\",\n          { type: \"literal\", value: \"realm\", description: \"\\\"realm\\\"\" },\n          function(realm) { data.realm = realm; },\n          \"domain\",\n          { type: \"literal\", value: \"domain\", description: \"\\\"domain\\\"\" },\n          \"nonce\",\n          { type: \"literal\", value: \"nonce\", description: \"\\\"nonce\\\"\" },\n          function(nonce) { data.nonce=nonce; },\n          \"opaque\",\n          { type: \"literal\", value: \"opaque\", description: \"\\\"opaque\\\"\" },\n          function(opaque) { data.opaque=opaque; },\n          \"stale\",\n          { type: \"literal\", value: \"stale\", description: \"\\\"stale\\\"\" },\n          \"true\",\n          { type: \"literal\", value: \"true\", description: \"\\\"true\\\"\" },\n          function() { data.stale=true; },\n          \"false\",\n          { type: \"literal\", value: \"false\", description: \"\\\"false\\\"\" },\n          function() { data.stale=false; },\n          \"algorithm\",\n          { type: \"literal\", value: \"algorithm\", description: \"\\\"algorithm\\\"\" },\n          \"md5\",\n          { type: \"literal\", value: \"MD5\", description: \"\\\"MD5\\\"\" },\n          \"md5-sess\",\n          { type: \"literal\", value: \"MD5-sess\", description: \"\\\"MD5-sess\\\"\" },\n          function(algorithm) {\n                                data.algorithm=algorithm.toUpperCase(); },\n          \"qop\",\n          { type: \"literal\", value: \"qop\", description: \"\\\"qop\\\"\" },\n          \"auth-int\",\n          { type: \"literal\", value: \"auth-int\", description: \"\\\"auth-int\\\"\" },\n          \"auth\",\n          { type: \"literal\", value: \"auth\", description: \"\\\"auth\\\"\" },\n          function(qop_value) {\n                                  data.qop || (data.qop=[]);\n                                  data.qop.push(qop_value.toLowerCase()); },\n          function(rack_value) {\n                            data.value=parseInt(rack_value.join('')); },\n          function() {\n                            var idx, length;\n                            length = data.multi_header.length;\n                            for (idx = 0; idx < length; idx++) {\n                              if (data.multi_header[idx].parsed === null) {\n                                data = null;\n                                break;\n                              }\n                            }\n                            if (data !== null) {\n                              data = data.multi_header;\n                            } else {\n                              data = -1;\n                            }},\n          function() {\n                            var header;\n                            if(!data.multi_header) data.multi_header = [];\n                            try {\n                              header = new SIP.NameAddrHeader(data.uri, data.displayName, data.params);\n                              delete data.uri;\n                              delete data.displayName;\n                              delete data.params;\n                            } catch(e) {\n                              header = null;\n                            }\n                            data.multi_header.push( { 'position': peg$currPos,\n                                                      'offset': offset(),\n                                                      'parsed': header\n                                                    });},\n          function() {\n                        data = new SIP.NameAddrHeader(data.uri, data.displayName, data.params);\n                      },\n          function(rseq_value) {\n                            data.value=parseInt(rseq_value.join('')); },\n          \"active\",\n          { type: \"literal\", value: \"active\", description: \"\\\"active\\\"\" },\n          \"pending\",\n          { type: \"literal\", value: \"pending\", description: \"\\\"pending\\\"\" },\n          \"terminated\",\n          { type: \"literal\", value: \"terminated\", description: \"\\\"terminated\\\"\" },\n          function() {\n                                  data.state = text(); },\n          \"reason\",\n          { type: \"literal\", value: \"reason\", description: \"\\\"reason\\\"\" },\n          function(reason) {\n                                  if (typeof reason !== 'undefined') data.reason = reason; },\n          function(expires) {\n                                  if (typeof expires !== 'undefined') data.expires = expires; },\n          \"retry_after\",\n          { type: \"literal\", value: \"retry_after\", description: \"\\\"retry_after\\\"\" },\n          function(retry_after) {\n                                  if (typeof retry_after !== 'undefined') data.retry_after = retry_after; },\n          \"deactivated\",\n          { type: \"literal\", value: \"deactivated\", description: \"\\\"deactivated\\\"\" },\n          \"probation\",\n          { type: \"literal\", value: \"probation\", description: \"\\\"probation\\\"\" },\n          \"rejected\",\n          { type: \"literal\", value: \"rejected\", description: \"\\\"rejected\\\"\" },\n          \"timeout\",\n          { type: \"literal\", value: \"timeout\", description: \"\\\"timeout\\\"\" },\n          \"giveup\",\n          { type: \"literal\", value: \"giveup\", description: \"\\\"giveup\\\"\" },\n          \"noresource\",\n          { type: \"literal\", value: \"noresource\", description: \"\\\"noresource\\\"\" },\n          \"invariant\",\n          { type: \"literal\", value: \"invariant\", description: \"\\\"invariant\\\"\" },\n          function() {\n                        var tag = data.tag;\n                          data = new SIP.NameAddrHeader(data.uri, data.displayName, data.params);\n                          if (tag) {data.setParam('tag',tag)}\n                        },\n          \"ttl\",\n          { type: \"literal\", value: \"ttl\", description: \"\\\"ttl\\\"\" },\n          function(via_ttl_value) {\n                                data.ttl = via_ttl_value; },\n          \"maddr\",\n          { type: \"literal\", value: \"maddr\", description: \"\\\"maddr\\\"\" },\n          function(via_maddr) {\n                                data.maddr = via_maddr; },\n          \"received\",\n          { type: \"literal\", value: \"received\", description: \"\\\"received\\\"\" },\n          function(via_received) {\n                                data.received = via_received; },\n          \"branch\",\n          { type: \"literal\", value: \"branch\", description: \"\\\"branch\\\"\" },\n          function(via_branch) {\n                                data.branch = via_branch; },\n          \"rport\",\n          { type: \"literal\", value: \"rport\", description: \"\\\"rport\\\"\" },\n          function() {\n                                if(typeof response_port !== 'undefined')\n                                  data.rport = response_port.join(''); },\n          function(via_protocol) {\n                                data.protocol = via_protocol; },\n          { type: \"literal\", value: \"UDP\", description: \"\\\"UDP\\\"\" },\n          { type: \"literal\", value: \"TCP\", description: \"\\\"TCP\\\"\" },\n          { type: \"literal\", value: \"TLS\", description: \"\\\"TLS\\\"\" },\n          { type: \"literal\", value: \"SCTP\", description: \"\\\"SCTP\\\"\" },\n          function(via_transport) {\n                                data.transport = via_transport; },\n          function() {\n                                data.host = text(); },\n          function(via_sent_by_port) {\n                                data.port = parseInt(via_sent_by_port.join('')); },\n          function(ttl) {\n                                return parseInt(ttl.join('')); },\n          \"stuns\",\n          { type: \"literal\", value: \"stuns\", description: \"\\\"stuns\\\"\" },\n          \"stun\",\n          { type: \"literal\", value: \"stun\", description: \"\\\"stun\\\"\" },\n          function(scheme) {\n                                data.scheme = scheme; },\n          function(host) {\n                                data.host = host; },\n          function() {\n                                return text(); },\n          \"?transport=\",\n          { type: \"literal\", value: \"?transport=\", description: \"\\\"?transport=\\\"\" },\n          \"turns\",\n          { type: \"literal\", value: \"turns\", description: \"\\\"turns\\\"\" },\n          \"turn\",\n          { type: \"literal\", value: \"turn\", description: \"\\\"turn\\\"\" },\n          function() {\n                                data.transport = transport; },\n          function() {\n                            data = text(); }\n        ],\n\n        peg$bytecode = [\n          peg$decode(\". \\\"\\\"2 3!\"),\n          peg$decode(\"0\\\"\\\"\\\"1!3#\"),\n          peg$decode(\"0$\\\"\\\"1!3%\"),\n          peg$decode(\"0&\\\"\\\"1!3'\"),\n          peg$decode(\"7'*# \\\"7(\"),\n          peg$decode(\"0(\\\"\\\"1!3)\"),\n          peg$decode(\"0*\\\"\\\"1!3+\"),\n          peg$decode(\".,\\\"\\\"2,3-\"),\n          peg$decode(\"..\\\"\\\"2.3/\"),\n          peg$decode(\"00\\\"\\\"1!31\"),\n          peg$decode(\".2\\\"\\\"2233*\\x89 \\\".4\\\"\\\"2435*} \\\".6\\\"\\\"2637*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n          peg$decode(\"7)*# \\\"7,\"),\n          peg$decode(\".F\\\"\\\"2F3G*} \\\".H\\\"\\\"2H3I*q \\\".J\\\"\\\"2J3K*e \\\".L\\\"\\\"2L3M*Y \\\".N\\\"\\\"2N3O*M \\\".P\\\"\\\"2P3Q*A \\\".R\\\"\\\"2R3S*5 \\\".T\\\"\\\"2T3U*) \\\".V\\\"\\\"2V3W\"),\n          peg$decode(\"!!.Y\\\"\\\"2Y3Z+7$7#+-%7#+#%'#%$## X$\\\"# X\\\"# X+' 4!6[!! %\"),\n          peg$decode(\"!! ]7$,#&7$\\\"+-$7 +#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+@$ ]7$+&$,#&7$\\\"\\\"\\\" X+'%4\\\"6^\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"7.*# \\\" \\\\\"),\n          peg$decode(\"! ]7'*# \\\"7(,)&7'*# \\\"7(\\\"+A$.8\\\"\\\"2839+1%7/+'%4#6_# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]72+&$,#&72\\\"\\\"\\\" X+s$ ]! ]7.,#&7.\\\"+-$72+#%'\\\"%$\\\"# X\\\"# X,@&! ]7.,#&7.\\\"+-$72+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6`\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"0a\\\"\\\"1!3b*# \\\"73\"),\n          peg$decode(\"0c\\\"\\\"1!3d\"),\n          peg$decode(\"0e\\\"\\\"1!3f\"),\n          peg$decode(\"7!*) \\\"0g\\\"\\\"1!3h\"),\n          peg$decode(\"! ]7)*\\x95 \\\".F\\\"\\\"2F3G*\\x89 \\\".J\\\"\\\"2J3K*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".i\\\"\\\"2i3j*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O+\\x9E$,\\x9B&7)*\\x95 \\\".F\\\"\\\"2F3G*\\x89 \\\".J\\\"\\\"2J3K*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".i\\\"\\\"2i3j*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O\\\"\\\"\\\" X+& 4!6k! %\"),\n          peg$decode(\"! ]7)*\\x89 \\\".F\\\"\\\"2F3G*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".i\\\"\\\"2i3j*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O+\\x92$,\\x8F&7)*\\x89 \\\".F\\\"\\\"2F3G*} \\\".L\\\"\\\"2L3M*q \\\".Y\\\"\\\"2Y3Z*e \\\".P\\\"\\\"2P3Q*Y \\\".H\\\"\\\"2H3I*M \\\".@\\\"\\\"2@3A*A \\\".i\\\"\\\"2i3j*5 \\\".R\\\"\\\"2R3S*) \\\".N\\\"\\\"2N3O\\\"\\\"\\\" X+& 4!6k! %\"),\n          peg$decode(\".T\\\"\\\"2T3U*\\xE3 \\\".V\\\"\\\"2V3W*\\xD7 \\\".l\\\"\\\"2l3m*\\xCB \\\".n\\\"\\\"2n3o*\\xBF \\\".:\\\"\\\"2:3;*\\xB3 \\\".D\\\"\\\"2D3E*\\xA7 \\\".2\\\"\\\"2233*\\x9B \\\".8\\\"\\\"2839*\\x8F \\\".p\\\"\\\"2p3q*\\x83 \\\"7&*} \\\".4\\\"\\\"2435*q \\\".r\\\"\\\"2r3s*e \\\".t\\\"\\\"2t3u*Y \\\".6\\\"\\\"2637*M \\\".>\\\"\\\"2>3?*A \\\".v\\\"\\\"2v3w*5 \\\".x\\\"\\\"2x3y*) \\\"7'*# \\\"7(\"),\n          peg$decode(\"! ]7)*\\u012B \\\".F\\\"\\\"2F3G*\\u011F \\\".J\\\"\\\"2J3K*\\u0113 \\\".L\\\"\\\"2L3M*\\u0107 \\\".Y\\\"\\\"2Y3Z*\\xFB \\\".P\\\"\\\"2P3Q*\\xEF \\\".H\\\"\\\"2H3I*\\xE3 \\\".@\\\"\\\"2@3A*\\xD7 \\\".i\\\"\\\"2i3j*\\xCB \\\".R\\\"\\\"2R3S*\\xBF \\\".N\\\"\\\"2N3O*\\xB3 \\\".T\\\"\\\"2T3U*\\xA7 \\\".V\\\"\\\"2V3W*\\x9B \\\".l\\\"\\\"2l3m*\\x8F \\\".n\\\"\\\"2n3o*\\x83 \\\".8\\\"\\\"2839*w \\\".p\\\"\\\"2p3q*k \\\"7&*e \\\".4\\\"\\\"2435*Y \\\".r\\\"\\\"2r3s*M \\\".t\\\"\\\"2t3u*A \\\".6\\\"\\\"2637*5 \\\".v\\\"\\\"2v3w*) \\\".x\\\"\\\"2x3y+\\u0134$,\\u0131&7)*\\u012B \\\".F\\\"\\\"2F3G*\\u011F \\\".J\\\"\\\"2J3K*\\u0113 \\\".L\\\"\\\"2L3M*\\u0107 \\\".Y\\\"\\\"2Y3Z*\\xFB \\\".P\\\"\\\"2P3Q*\\xEF \\\".H\\\"\\\"2H3I*\\xE3 \\\".@\\\"\\\"2@3A*\\xD7 \\\".i\\\"\\\"2i3j*\\xCB \\\".R\\\"\\\"2R3S*\\xBF \\\".N\\\"\\\"2N3O*\\xB3 \\\".T\\\"\\\"2T3U*\\xA7 \\\".V\\\"\\\"2V3W*\\x9B \\\".l\\\"\\\"2l3m*\\x8F \\\".n\\\"\\\"2n3o*\\x83 \\\".8\\\"\\\"2839*w \\\".p\\\"\\\"2p3q*k \\\"7&*e \\\".4\\\"\\\"2435*Y \\\".r\\\"\\\"2r3s*M \\\".t\\\"\\\"2t3u*A \\\".6\\\"\\\"2637*5 \\\".v\\\"\\\"2v3w*) \\\".x\\\"\\\"2x3y\\\"\\\"\\\" X+& 4!6k! %\"),\n          peg$decode(\"!7/+A$.P\\\"\\\"2P3Q+1%7/+'%4#6z# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.4\\\"\\\"2435+1%7/+'%4#6{# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.>\\\"\\\"2>3?+1%7/+'%4#6|# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.T\\\"\\\"2T3U+1%7/+'%4#6}# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.V\\\"\\\"2V3W+1%7/+'%4#6~# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!.n\\\"\\\"2n3o+1$7/+'%4\\\"6\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+7$.l\\\"\\\"2l3m+'%4\\\"6\\x80\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.D\\\"\\\"2D3E+1%7/+'%4#6\\x81# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.2\\\"\\\"2233+1%7/+'%4#6\\x82# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+A$.8\\\"\\\"2839+1%7/+'%4#6\\x83# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+1$7&+'%4\\\"6\\x84\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7&+1$7/+'%4\\\"6\\x84\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7=+W$ ]7G*) \\\"7K*# \\\"7F,/&7G*) \\\"7K*# \\\"7F\\\"+-%7>+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"0\\x85\\\"\\\"1!3\\x86*A \\\"0\\x87\\\"\\\"1!3\\x88*5 \\\"0\\x89\\\"\\\"1!3\\x8A*) \\\"73*# \\\"7.\"),\n          peg$decode(\"!7/+Y$7&+O% ]7J*# \\\"7K,)&7J*# \\\"7K\\\"+1%7&+'%4$6k$ %$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7/+`$7&+V%! ]7J*# \\\"7K,)&7J*# \\\"7K\\\"+! (%+2%7&+(%4$6\\x8B$!!%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7.*G \\\".L\\\"\\\"2L3M*; \\\"0\\x8C\\\"\\\"1!3\\x8D*/ \\\"0\\x89\\\"\\\"1!3\\x8A*# \\\"73\"),\n          peg$decode(\"!.p\\\"\\\"2p3q+K$0\\x8E\\\"\\\"1!3\\x8F*5 \\\"0\\x90\\\"\\\"1!3\\x91*) \\\"0\\x92\\\"\\\"1!3\\x93+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7N+Q$.8\\\"\\\"2839+A%7O*# \\\" \\\\+1%7S+'%4$6\\x94$ %$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7N+k$.8\\\"\\\"2839+[%7O*# \\\" \\\\+K%7S+A%7_+7%7l*# \\\" \\\\+'%4&6\\x95& %$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\x96\\\"\\\"1$3\\x97*) \\\"/\\x98\\\"\\\"1#3\\x99+' 4!6\\x9A!! %\"),\n          peg$decode(\"!7P+b$!.8\\\"\\\"2839+-$7R+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+7%.:\\\"\\\"2:3;+'%4#6\\x9B# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\" ]7+*) \\\"7-*# \\\"7Q+2$,/&7+*) \\\"7-*# \\\"7Q\\\"\\\"\\\" X\"),\n          peg$decode(\".<\\\"\\\"2<3=*q \\\".>\\\"\\\"2>3?*e \\\".@\\\"\\\"2@3A*Y \\\".B\\\"\\\"2B3C*M \\\".D\\\"\\\"2D3E*A \\\".2\\\"\\\"2233*5 \\\".6\\\"\\\"2637*) \\\".4\\\"\\\"2435\"),\n          peg$decode(\"! ]7+*_ \\\"7-*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E,e&7+*_ \\\"7-*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\\\"+& 4!6\\x9C! %\"),\n          peg$decode(\"!7T+N$!.8\\\"\\\"2839+-$7^+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7U*) \\\"7\\\\*# \\\"7X+& 4!6\\x9D! %\"),\n          peg$decode(\"! ]!7V+3$.J\\\"\\\"2J3K+#%'\\\"%$\\\"# X\\\"# X,>&!7V+3$.J\\\"\\\"2J3K+#%'\\\"%$\\\"# X\\\"# X\\\"+G$7W+=%.J\\\"\\\"2J3K*# \\\" \\\\+'%4#6\\x9E# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\" ]0\\x9F\\\"\\\"1!3\\xA0+,$,)&0\\x9F\\\"\\\"1!3\\xA0\\\"\\\"\\\" X\"),\n          peg$decode(\"!0$\\\"\\\"1!3%+A$ ]0\\xA1\\\"\\\"1!3\\xA2,)&0\\xA1\\\"\\\"1!3\\xA2\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!.r\\\"\\\"2r3s+A$7Y+7%.t\\\"\\\"2t3u+'%4#6\\xA3# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!!7Z+\\xBF$.8\\\"\\\"2839+\\xAF%7Z+\\xA5%.8\\\"\\\"2839+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'-%$-# X$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0838 \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+\\xAF$7Z+\\xA5%.8\\\"\\\"2839+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%',%$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0795 \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+\\x95$7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u070C \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+{$7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u069D \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+a$7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'&%$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0648 \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+G$7Z+=%.8\\\"\\\"2839+-%7[+#%'$%$$# X$## X$\\\"# X\\\"# X*\\u060D \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+-$7[+#%'\\\"%$\\\"# X\\\"# X*\\u05EC \\\"!.\\xA4\\\"\\\"2\\xA43\\xA5+-$7Z+#%'\\\"%$\\\"# X\\\"# X*\\u05CB \\\"!7Z+\\xA5$.\\xA4\\\"\\\"2\\xA43\\xA5+\\x95%7Z+\\x8B%.8\\\"\\\"2839+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'+%$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0538 \\\"!7Z+\\xB6$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\x8B%.\\xA4\\\"\\\"2\\xA43\\xA5+{%7Z+q%.8\\\"\\\"2839+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0494 \\\"!7Z+\\xC7$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\x9C%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+q%.\\xA4\\\"\\\"2\\xA43\\xA5+a%7Z+W%.8\\\"\\\"2839+G%7Z+=%.8\\\"\\\"2839+-%7[+#%')%$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u03DF \\\"!7Z+\\xD8$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\xAD%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\x82%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+W%.\\xA4\\\"\\\"2\\xA43\\xA5+G%7Z+=%.8\\\"\\\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0319 \\\"!7Z+\\xE9$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\xBE%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\x93%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+h%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+=%.\\xA4\\\"\\\"2\\xA43\\xA5+-%7[+#%''%$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0242 \\\"!7Z+\\u0114$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\xE9%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\xBE%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\x93%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+h%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+=%.\\xA4\\\"\\\"2\\xA43\\xA5+-%7Z+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X*\\u0140 \\\"!7Z+\\u0135$!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\u010A%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\xDF%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\xB4%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+\\x89%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+^%!.8\\\"\\\"2839+-$7Z+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+3%.\\xA4\\\"\\\"2\\xA43\\xA5+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X+& 4!6\\xA6! %\"),\n          peg$decode(\"!7#+S$7#*# \\\" \\\\+C%7#*# \\\" \\\\+3%7#*# \\\" \\\\+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7Z+=$.8\\\"\\\"2839+-%7Z+#%'#%$## X$\\\"# X\\\"# X*# \\\"7\\\\\"),\n          peg$decode(\"!7]+u$.J\\\"\\\"2J3K+e%7]+[%.J\\\"\\\"2J3K+K%7]+A%.J\\\"\\\"2J3K+1%7]+'%4'6\\xA7' %$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!.\\xA8\\\"\\\"2\\xA83\\xA9+3$0\\xAA\\\"\\\"1!3\\xAB+#%'\\\"%$\\\"# X\\\"# X*\\xA0 \\\"!.\\xAC\\\"\\\"2\\xAC3\\xAD+=$0\\xAE\\\"\\\"1!3\\xAF+-%7!+#%'#%$## X$\\\"# X\\\"# X*o \\\"!.\\xB0\\\"\\\"2\\xB03\\xB1+7$7!+-%7!+#%'#%$## X$\\\"# X\\\"# X*D \\\"!0\\xB2\\\"\\\"1!3\\xB3+-$7!+#%'\\\"%$\\\"# X\\\"# X*# \\\"7!\"),\n          peg$decode(\"!!7!*# \\\" \\\\+c$7!*# \\\" \\\\+S%7!*# \\\" \\\\+C%7!*# \\\" \\\\+3%7!*# \\\" \\\\+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X+' 4!6\\xB4!! %\"),\n          peg$decode(\" ]!.2\\\"\\\"2233+-$7`+#%'\\\"%$\\\"# X\\\"# X,>&!.2\\\"\\\"2233+-$7`+#%'\\\"%$\\\"# X\\\"# X\\\"\"),\n          peg$decode(\"7a*A \\\"7b*; \\\"7c*5 \\\"7d*/ \\\"7e*) \\\"7f*# \\\"7g\"),\n          peg$decode(\"!/\\xB5\\\"\\\"1*3\\xB6+b$/\\xB7\\\"\\\"1#3\\xB8*G \\\"/\\xB9\\\"\\\"1#3\\xBA*; \\\"/\\xBB\\\"\\\"1$3\\xBC*/ \\\"/\\xBD\\\"\\\"1#3\\xBE*# \\\"76+(%4\\\"6\\xBF\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\xC0\\\"\\\"1%3\\xC1+J$/\\xC2\\\"\\\"1%3\\xC3*/ \\\"/\\xC4\\\"\\\"1\\\"3\\xC5*# \\\"76+(%4\\\"6\\xC6\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\xC7\\\"\\\"1'3\\xC8+2$7\\x8F+(%4\\\"6\\xC9\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\xCA\\\"\\\"1$3\\xCB+2$7\\xEC+(%4\\\"6\\xCC\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\xCD\\\"\\\"1&3\\xCE+2$7T+(%4\\\"6\\xCF\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\xD0\\\"\\\"1\\\"3\\xD1+R$!.>\\\"\\\"2>3?+-$76+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+'%4\\\"6\\xD2\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7h+T$!.>\\\"\\\"2>3?+-$7i+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+)%4\\\"6\\xD3\\\"\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7j+&$,#&7j\\\"\\\"\\\" X+' 4!6\\xD4!! %\"),\n          peg$decode(\"! ]7j+&$,#&7j\\\"\\\"\\\" X+' 4!6\\xD5!! %\"),\n          peg$decode(\"7k*) \\\"7+*# \\\"7-\"),\n          peg$decode(\".r\\\"\\\"2r3s*e \\\".t\\\"\\\"2t3u*Y \\\".4\\\"\\\"2435*M \\\".8\\\"\\\"2839*A \\\".<\\\"\\\"2<3=*5 \\\".@\\\"\\\"2@3A*) \\\".B\\\"\\\"2B3C\"),\n          peg$decode(\"!.6\\\"\\\"2637+u$7m+k% ]!.<\\\"\\\"2<3=+-$7m+#%'\\\"%$\\\"# X\\\"# X,>&!.<\\\"\\\"2<3=+-$7m+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7n+C$.>\\\"\\\"2>3?+3%7o+)%4#6\\xD6#\\\"\\\" %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\" ]7p*) \\\"7+*# \\\"7-+2$,/&7p*) \\\"7+*# \\\"7-\\\"\\\"\\\" X\"),\n          peg$decode(\" ]7p*) \\\"7+*# \\\"7-,/&7p*) \\\"7+*# \\\"7-\\\"\"),\n          peg$decode(\".r\\\"\\\"2r3s*e \\\".t\\\"\\\"2t3u*Y \\\".4\\\"\\\"2435*M \\\".6\\\"\\\"2637*A \\\".8\\\"\\\"2839*5 \\\".@\\\"\\\"2@3A*) \\\".B\\\"\\\"2B3C\"),\n          peg$decode(\"7\\x90*# \\\"7r\"),\n          peg$decode(\"!7\\x8F+K$7'+A%7s+7%7'+-%7\\x84+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7M*# \\\"7t\"),\n          peg$decode(\"!7+G$.8\\\"\\\"2839+7%7u*# \\\"7x+'%4#6\\xD7# %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7v*# \\\"7w+N$!.6\\\"\\\"2637+-$7\\x83+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!.\\xD8\\\"\\\"2\\xD83\\xD9+=$7\\x80+3%7w*# \\\" \\\\+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!.4\\\"\\\"2435+-$7{+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7z+5$ ]7y,#&7y\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"7**) \\\"7+*# \\\"7-\"),\n          peg$decode(\"7+*\\x8F \\\"7-*\\x89 \\\".2\\\"\\\"2233*} \\\".6\\\"\\\"2637*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n          peg$decode(\"!7|+k$ ]!.4\\\"\\\"2435+-$7|+#%'\\\"%$\\\"# X\\\"# X,>&!.4\\\"\\\"2435+-$7|+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7~,#&7~\\\"+k$ ]!.2\\\"\\\"2233+-$7}+#%'\\\"%$\\\"# X\\\"# X,>&!.2\\\"\\\"2233+-$7}+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\" ]7~,#&7~\\\"\"),\n          peg$decode(\"7+*w \\\"7-*q \\\".8\\\"\\\"2839*e \\\".:\\\"\\\"2:3;*Y \\\".<\\\"\\\"2<3=*M \\\".>\\\"\\\"2>3?*A \\\".@\\\"\\\"2@3A*5 \\\".B\\\"\\\"2B3C*) \\\".D\\\"\\\"2D3E\"),\n          peg$decode(\"!7\\\"+\\x8D$ ]7\\\"*G \\\"7!*A \\\".@\\\"\\\"2@3A*5 \\\".F\\\"\\\"2F3G*) \\\".J\\\"\\\"2J3K,M&7\\\"*G \\\"7!*A \\\".@\\\"\\\"2@3A*5 \\\".F\\\"\\\"2F3G*) \\\".J\\\"\\\"2J3K\\\"+'%4\\\"6\\xDA\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\x81*# \\\"7\\x82\"),\n          peg$decode(\"!!7O+3$.:\\\"\\\"2:3;+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+-$7S+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\\"),\n          peg$decode(\" ]7+*\\x83 \\\"7-*} \\\".B\\\"\\\"2B3C*q \\\".D\\\"\\\"2D3E*e \\\".2\\\"\\\"2233*Y \\\".8\\\"\\\"2839*M \\\".:\\\"\\\"2:3;*A \\\".<\\\"\\\"2<3=*5 \\\".>\\\"\\\"2>3?*) \\\".@\\\"\\\"2@3A+\\x8C$,\\x89&7+*\\x83 \\\"7-*} \\\".B\\\"\\\"2B3C*q \\\".D\\\"\\\"2D3E*e \\\".2\\\"\\\"2233*Y \\\".8\\\"\\\"2839*M \\\".:\\\"\\\"2:3;*A \\\".<\\\"\\\"2<3=*5 \\\".>\\\"\\\"2>3?*) \\\".@\\\"\\\"2@3A\\\"\\\"\\\" X\"),\n          peg$decode(\" ]7y,#&7y\\\"\"),\n          peg$decode(\"!/\\x98\\\"\\\"1#3\\xDB+y$.4\\\"\\\"2435+i% ]7!+&$,#&7!\\\"\\\"\\\" X+P%.J\\\"\\\"2J3K+@% ]7!+&$,#&7!\\\"\\\"\\\" X+'%4%6\\xDC% %$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\".\\xDD\\\"\\\"2\\xDD3\\xDE\"),\n          peg$decode(\".\\xDF\\\"\\\"2\\xDF3\\xE0\"),\n          peg$decode(\".\\xE1\\\"\\\"2\\xE13\\xE2\"),\n          peg$decode(\".\\xE3\\\"\\\"2\\xE33\\xE4\"),\n          peg$decode(\".\\xE5\\\"\\\"2\\xE53\\xE6\"),\n          peg$decode(\".\\xE7\\\"\\\"2\\xE73\\xE8\"),\n          peg$decode(\".\\xE9\\\"\\\"2\\xE93\\xEA\"),\n          peg$decode(\".\\xEB\\\"\\\"2\\xEB3\\xEC\"),\n          peg$decode(\".\\xED\\\"\\\"2\\xED3\\xEE\"),\n          peg$decode(\".\\xEF\\\"\\\"2\\xEF3\\xF0\"),\n          peg$decode(\"!7\\x85*S \\\"7\\x86*M \\\"7\\x88*G \\\"7\\x89*A \\\"7\\x8A*; \\\"7\\x8B*5 \\\"7\\x8C*/ \\\"7\\x8D*) \\\"7\\x8E*# \\\"76+& 4!6\\xF1! %\"),\n          peg$decode(\"!7\\x84+K$7'+A%7\\x91+7%7'+-%7\\x93+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\x92+' 4!6\\xF2!! %\"),\n          peg$decode(\"!7!+7$7!+-%7!+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7**A \\\"7+*; \\\"7-*5 \\\"73*/ \\\"74*) \\\"7'*# \\\"7(,G&7**A \\\"7+*; \\\"7-*5 \\\"73*/ \\\"74*) \\\"7'*# \\\"7(\\\"+& 4!6\\xF3! %\"),\n          peg$decode(\"!7\\xB5+_$ ]!7A+-$7\\xB5+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xB5+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!79+R$!.:\\\"\\\"2:3;+-$79+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+'%4\\\"6\\xF4\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7:*j \\\"!7\\x97+_$ ]!7A+-$7\\x97+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\x97+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+& 4!6\\xF5! %\"),\n          peg$decode(\"!7L*# \\\"7\\x98+c$ ]!7B+-$7\\x9A+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9A+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\xF6\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\x99*# \\\" \\\\+A$7@+7%7M+-%7?+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!!76+_$ ]!7.+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7.+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\"7H+' 4!6\\xF7!! %\"),\n          peg$decode(\"7\\x9B*) \\\"7\\x9C*# \\\"7\\x9F\"),\n          peg$decode(\"!/\\xF8\\\"\\\"1!3\\xF9+<$7<+2%7\\x9E+(%4#6\\xFA#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\xFB\\\"\\\"1'3\\xFC+<$7<+2%7\\x9D+(%4#6\\xFD#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\xFE!! %\"),\n          peg$decode(\"!.\\xFF\\\"\\\"2\\xFF3\\u0100+x$!.J\\\"\\\"2J3K+S$7!*# \\\" \\\\+C%7!*# \\\" \\\\+3%7!*# \\\" \\\\+#%'$%$$# X$## X$\\\"# X\\\"# X*# \\\" \\\\+'%4\\\"6\\u0101\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!76+N$!7<+-$7\\xA0+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+)%4\\\"6\\u0102\\\"\\\"! %$\\\"# X\\\"# X\"),\n          peg$decode(\"76*) \\\"7T*# \\\"7H\"),\n          peg$decode(\"!7\\xA2+_$ ]!7B+-$7\\xA3+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xA3+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u0103\\\"\\\"1&3\\u0104*G \\\"/\\u0105\\\"\\\"1'3\\u0106*; \\\"/\\u0107\\\"\\\"1$3\\u0108*/ \\\"/\\u0109\\\"\\\"1%3\\u010A*# \\\"76+& 4!6\\u010B! %\"),\n          peg$decode(\"7\\xA4*# \\\"7\\x9F\"),\n          peg$decode(\"!/\\u010C\\\"\\\"1(3\\u010D+O$7<+E%/\\u010E\\\"\\\"1(3\\u010F*/ \\\"/\\u0110\\\"\\\"1(3\\u0111*# \\\"76+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!76+_$ ]!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u0112!! %\"),\n          peg$decode(\"!7\\xA8+& 4!6\\u0113! %\"),\n          peg$decode(\"!7\\xA9+s$7;+i%7\\xAE+_% ]!7B+-$7\\xAF+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xAF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xAA*# \\\"7\\xAB\"),\n          peg$decode(\"/\\u0114\\\"\\\"1$3\\u0115*S \\\"/\\u0116\\\"\\\"1%3\\u0117*G \\\"/\\u0118\\\"\\\"1%3\\u0119*; \\\"/\\u011A\\\"\\\"1%3\\u011B*/ \\\"/\\u011C\\\"\\\"1+3\\u011D*# \\\"7\\xAC\"),\n          peg$decode(\"/\\u011E\\\"\\\"1'3\\u011F*/ \\\"/\\u0120\\\"\\\"1)3\\u0121*# \\\"7\\xAC\"),\n          peg$decode(\"76*# \\\"7\\xAD\"),\n          peg$decode(\"!/\\u0122\\\"\\\"1\\\"3\\u0123+-$76+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xAC*# \\\"76\"),\n          peg$decode(\"!76+7$7<+-%7\\xB0+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"76*# \\\"7H\"),\n          peg$decode(\"!7\\xB2+7$7.+-%7\\x8F+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u0124!! %\"),\n          peg$decode(\"!7\\x9D+' 4!6\\u0125!! %\"),\n          peg$decode(\"!7\\xB5+d$ ]!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+(%4\\\"6\\u0126\\\"!!%$\\\"# X\\\"# X\"),\n          peg$decode(\"!!77+k$ ]!.J\\\"\\\"2J3K+-$77+#%'\\\"%$\\\"# X\\\"# X,>&!.J\\\"\\\"2J3K+-$77+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+! (%\"),\n          peg$decode(\"!7L*# \\\"7\\x98+c$ ]!7B+-$7\\xB7+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xB7+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0127\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xB8*# \\\"7\\x9F\"),\n          peg$decode(\"!/\\u0128\\\"\\\"1#3\\u0129+<$7<+2%76+(%4#6\\u012A#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u012B!! %\"),\n          peg$decode(\"!7\\x9D+' 4!6\\u012C!! %\"),\n          peg$decode(\"! ]7\\x99,#&7\\x99\\\"+\\x81$7@+w%7M+m%7?+c% ]!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4%6\\u012D% %$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xBD\"),\n          peg$decode(\"!/\\u012E\\\"\\\"1&3\\u012F+s$7.+i%7\\xC0+_% ]!7A+-$7\\xC0+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xC0+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X*# \\\"7\\xBE\"),\n          peg$decode(\"!76+s$7.+i%7\\xBF+_% ]!7A+-$7\\xBF+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xBF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!76+=$7<+3%76*# \\\"7H+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xC1*G \\\"7\\xC3*A \\\"7\\xC5*; \\\"7\\xC7*5 \\\"7\\xC8*/ \\\"7\\xC9*) \\\"7\\xCA*# \\\"7\\xBF\"),\n          peg$decode(\"!/\\u0130\\\"\\\"1%3\\u0131+7$7<+-%7\\xC2+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7I+' 4!6\\u0132!! %\"),\n          peg$decode(\"!/\\u0133\\\"\\\"1&3\\u0134+\\xA5$7<+\\x9B%7D+\\x91%7\\xC4+\\x87% ]! ]7'+&$,#&7'\\\"\\\"\\\" X+-$7\\xC4+#%'\\\"%$\\\"# X\\\"# X,G&! ]7'+&$,#&7'\\\"\\\"\\\" X+-$7\\xC4+#%'\\\"%$\\\"# X\\\"# X\\\"+-%7E+#%'&%$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7t*# \\\"7w\"),\n          peg$decode(\"!/\\u0135\\\"\\\"1%3\\u0136+7$7<+-%7\\xC6+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7I+' 4!6\\u0137!! %\"),\n          peg$decode(\"!/\\u0138\\\"\\\"1&3\\u0139+<$7<+2%7I+(%4#6\\u013A#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u013B\\\"\\\"1%3\\u013C+_$7<+U%!/\\u013D\\\"\\\"1$3\\u013E+& 4!6\\u013F! %*4 \\\"!/\\u0140\\\"\\\"1%3\\u0141+& 4!6\\u0142! %+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u0143\\\"\\\"1)3\\u0144+T$7<+J%/\\u0145\\\"\\\"1#3\\u0146*/ \\\"/\\u0147\\\"\\\"1(3\\u0148*# \\\"76+(%4#6\\u0149#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u014A\\\"\\\"1#3\\u014B+\\x9E$7<+\\x94%7D+\\x8A%!7\\xCB+k$ ]!.D\\\"\\\"2D3E+-$7\\xCB+#%'\\\"%$\\\"# X\\\"# X,>&!.D\\\"\\\"2D3E+-$7\\xCB+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X+-%7E+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u014C\\\"\\\"1(3\\u014D*/ \\\"/\\u014E\\\"\\\"1$3\\u014F*# \\\"76+' 4!6\\u0150!! %\"),\n          peg$decode(\"!76+_$ ]!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xCE+K$7.+A%7\\xCE+7%7.+-%7\\x8F+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u0151!! %\"),\n          peg$decode(\"!7\\xD0+c$ ]!7A+-$7\\xD0+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xD0+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0152\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\x98+c$ ]!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0153\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7L*) \\\"7\\x98*# \\\"7t+c$ ]!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0154\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!76+_$ ]!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xD4+_$ ]!7A+-$7\\xD4+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xD4+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\x98+_$ ]!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\x9F+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"! ]7!+&$,#&7!\\\"\\\"\\\" X+' 4!6\\u0155!! %\"),\n          peg$decode(\"!7\\xD7+_$ ]!7B+-$7\\xD8+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xD8+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u0156\\\"\\\"1&3\\u0157*; \\\"/\\u0158\\\"\\\"1'3\\u0159*/ \\\"/\\u015A\\\"\\\"1*3\\u015B*# \\\"76+& 4!6\\u015C! %\"),\n          peg$decode(\"!/\\u015D\\\"\\\"1&3\\u015E+<$7<+2%7\\xD9+(%4#6\\u015F#! %$## X$\\\"# X\\\"# X*\\x83 \\\"!/\\xFB\\\"\\\"1'3\\xFC+<$7<+2%7\\x9D+(%4#6\\u0160#! %$## X$\\\"# X\\\"# X*S \\\"!/\\u0161\\\"\\\"1+3\\u0162+<$7<+2%7\\x9D+(%4#6\\u0163#! %$## X$\\\"# X\\\"# X*# \\\"7\\x9F\"),\n          peg$decode(\"/\\u0164\\\"\\\"1+3\\u0165*k \\\"/\\u0166\\\"\\\"1)3\\u0167*_ \\\"/\\u0168\\\"\\\"1(3\\u0169*S \\\"/\\u016A\\\"\\\"1'3\\u016B*G \\\"/\\u016C\\\"\\\"1&3\\u016D*; \\\"/\\u016E\\\"\\\"1*3\\u016F*/ \\\"/\\u0170\\\"\\\"1)3\\u0171*# \\\"76\"),\n          peg$decode(\"71*# \\\" \\\\\"),\n          peg$decode(\"!76+_$ ]!7A+-$76+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$76+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\\"),\n          peg$decode(\"!7L*# \\\"7\\x98+c$ ]!7B+-$7\\xDD+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xDD+#%'\\\"%$\\\"# X\\\"# X\\\"+'%4\\\"6\\u0172\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xB8*# \\\"7\\x9F\"),\n          peg$decode(\"!7\\xDF+_$ ]!7A+-$7\\xDF+#%'\\\"%$\\\"# X\\\"# X,8&!7A+-$7\\xDF+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xE6+s$7.+i%7\\xE9+_% ]!7B+-$7\\xE0+#%'\\\"%$\\\"# X\\\"# X,8&!7B+-$7\\xE0+#%'\\\"%$\\\"# X\\\"# X\\\"+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"7\\xE1*; \\\"7\\xE2*5 \\\"7\\xE3*/ \\\"7\\xE4*) \\\"7\\xE5*# \\\"7\\x9F\"),\n          peg$decode(\"!/\\u0173\\\"\\\"1#3\\u0174+<$7<+2%7\\xEC+(%4#6\\u0175#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u0176\\\"\\\"1%3\\u0177+<$7<+2%7T+(%4#6\\u0178#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u0179\\\"\\\"1(3\\u017A+B$7<+8%7\\\\*# \\\"7Y+(%4#6\\u017B#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u017C\\\"\\\"1&3\\u017D+<$7<+2%76+(%4#6\\u017E#! %$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u017F\\\"\\\"1%3\\u0180+T$!7<+5$ ]7!,#&7!\\\"+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+'%4\\\"6\\u0181\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xE7+K$7;+A%76+7%7;+-%7\\xE8+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\x98\\\"\\\"1#3\\xDB*# \\\"76+' 4!6\\u0182!! %\"),\n          peg$decode(\"!/\\xB7\\\"\\\"1#3\\u0183*G \\\"/\\xB9\\\"\\\"1#3\\u0184*; \\\"/\\xBD\\\"\\\"1#3\\u0185*/ \\\"/\\xBB\\\"\\\"1$3\\u0186*# \\\"76+' 4!6\\u0187!! %\"),\n          peg$decode(\"!7\\xEA+H$!7C+-$7\\xEB+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7U*) \\\"7\\\\*# \\\"7X+& 4!6\\u0188! %\"),\n          peg$decode(\"!!7!*# \\\" \\\\+c$7!*# \\\" \\\\+S%7!*# \\\" \\\\+C%7!*# \\\" \\\\+3%7!*# \\\" \\\\+#%'%%$%# X$$# X$## X$\\\"# X\\\"# X+' 4!6\\u0189!! %\"),\n          peg$decode(\"!!7!+C$7!*# \\\" \\\\+3%7!*# \\\" \\\\+#%'#%$## X$\\\"# X\\\"# X+' 4!6\\u018A!! %\"),\n          peg$decode(\"7\\xBD\"),\n          peg$decode(\"!76+7$70+-%7\\xEF+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\" ]72*) \\\"74*# \\\"7.,/&72*) \\\"74*# \\\"7.\\\"\"),\n          peg$decode(\" ]7%,#&7%\\\"\"),\n          peg$decode(\"!7\\xF2+=$.8\\\"\\\"2839+-%7\\xF3+#%'#%$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u018B\\\"\\\"1%3\\u018C*) \\\"/\\u018D\\\"\\\"1$3\\u018E+' 4!6\\u018F!! %\"),\n          peg$decode(\"!7\\xF4+N$!.8\\\"\\\"2839+-$7^+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\\\*) \\\"7X*# \\\"7\\x82+' 4!6\\u0190!! %\"),\n          peg$decode(\"! ]7\\xF6*) \\\"7-*# \\\"7\\xF7,/&7\\xF6*) \\\"7-*# \\\"7\\xF7\\\"+& 4!6\\u0191! %\"),\n          peg$decode(\"7\\\"*S \\\"7!*M \\\".F\\\"\\\"2F3G*A \\\".J\\\"\\\"2J3K*5 \\\".H\\\"\\\"2H3I*) \\\".N\\\"\\\"2N3O\"),\n          peg$decode(\".L\\\"\\\"2L3M*\\x95 \\\".B\\\"\\\"2B3C*\\x89 \\\".<\\\"\\\"2<3=*} \\\".R\\\"\\\"2R3S*q \\\".T\\\"\\\"2T3U*e \\\".V\\\"\\\"2V3W*Y \\\".P\\\"\\\"2P3Q*M \\\".@\\\"\\\"2@3A*A \\\".D\\\"\\\"2D3E*5 \\\".2\\\"\\\"2233*) \\\".>\\\"\\\"2>3?\"),\n          peg$decode(\"!7\\xF9+h$.8\\\"\\\"2839+X%7\\xF3+N%!.\\u0192\\\"\\\"2\\u01923\\u0193+-$7\\xE8+#%'\\\"%$\\\"# X\\\"# X*# \\\" \\\\+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!/\\u0194\\\"\\\"1%3\\u0195*) \\\"/\\u0196\\\"\\\"1$3\\u0197+' 4!6\\u018F!! %\"),\n          peg$decode(\"!7\\xE8+Q$/\\xB7\\\"\\\"1#3\\xB8*7 \\\"/\\xB9\\\"\\\"1#3\\xBA*+ \\\" ]7+,#&7+\\\"+'%4\\\"6\\u0198\\\" %$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xFD+\\x8F$.F\\\"\\\"2F3G+%7\\xFC+u%.F\\\"\\\"2F3G+e%7\\xFC+[%.F\\\"\\\"2F3G+K%7\\xFC+A%.F\\\"\\\"2F3G+1%7\\xFE+'%4)6\\u0199) %$)# X$(# X$'# X$&# X$%# X$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7#+A$7#+7%7#+-%7#+#%'$%$$# X$## X$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xFC+-$7\\xFC+#%'\\\"%$\\\"# X\\\"# X\"),\n          peg$decode(\"!7\\xFC+7$7\\xFC+-%7\\xFC+#%'#%$## X$\\\"# X\\\"# X\")\n        ],\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleIndices)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleIndex = peg$startRuleIndices[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$decode(s) {\n      var bc = new Array(s.length), i;\n\n      for (i = 0; i < s.length; i++) {\n        bc[i] = s.charCodeAt(i) - 32;\n      }\n\n      return bc;\n    }\n\n    function peg$parseRule(index) {\n      var bc    = peg$bytecode[index],\n          ip    = 0,\n          ips   = [],\n          end   = bc.length,\n          ends  = [],\n          stack = [],\n          params, i;\n\n      function protect(object) {\n        return Object.prototype.toString.apply(object) === \"[object Array]\" ? [] : object;\n      }\n\n      while (true) {\n        while (ip < end) {\n          switch (bc[ip]) {\n            case 0:\n              stack.push(protect(peg$consts[bc[ip + 1]]));\n              ip += 2;\n              break;\n\n            case 1:\n              stack.push(peg$currPos);\n              ip++;\n              break;\n\n            case 2:\n              stack.pop();\n              ip++;\n              break;\n\n            case 3:\n              peg$currPos = stack.pop();\n              ip++;\n              break;\n\n            case 4:\n              stack.length -= bc[ip + 1];\n              ip += 2;\n              break;\n\n            case 5:\n              stack.splice(-2, 1);\n              ip++;\n              break;\n\n            case 6:\n              stack[stack.length - 2].push(stack.pop());\n              ip++;\n              break;\n\n            case 7:\n              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));\n              ip += 2;\n              break;\n\n            case 8:\n              stack.pop();\n              stack.push(input.substring(stack[stack.length - 1], peg$currPos));\n              ip++;\n              break;\n\n            case 9:\n              ends.push(end);\n              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n              if (stack[stack.length - 1]) {\n                end = ip + 3 + bc[ip + 1];\n                ip += 3;\n              } else {\n                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                ip += 3 + bc[ip + 1];\n              }\n\n              break;\n\n            case 10:\n              ends.push(end);\n              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n              if (stack[stack.length - 1] === peg$FAILED) {\n                end = ip + 3 + bc[ip + 1];\n                ip += 3;\n              } else {\n                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                ip += 3 + bc[ip + 1];\n              }\n\n              break;\n\n            case 11:\n              ends.push(end);\n              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n              if (stack[stack.length - 1] !== peg$FAILED) {\n                end = ip + 3 + bc[ip + 1];\n                ip += 3;\n              } else {\n                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                ip += 3 + bc[ip + 1];\n              }\n\n              break;\n\n            case 12:\n              if (stack[stack.length - 1] !== peg$FAILED) {\n                ends.push(end);\n                ips.push(ip);\n\n                end = ip + 2 + bc[ip + 1];\n                ip += 2;\n              } else {\n                ip += 2 + bc[ip + 1];\n              }\n\n              break;\n\n            case 13:\n              ends.push(end);\n              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n              if (input.length > peg$currPos) {\n                end = ip + 3 + bc[ip + 1];\n                ip += 3;\n              } else {\n                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                ip += 3 + bc[ip + 1];\n              }\n\n              break;\n\n            case 14:\n              ends.push(end);\n              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {\n                end = ip + 4 + bc[ip + 2];\n                ip += 4;\n              } else {\n                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n                ip += 4 + bc[ip + 2];\n              }\n\n              break;\n\n            case 15:\n              ends.push(end);\n              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {\n                end = ip + 4 + bc[ip + 2];\n                ip += 4;\n              } else {\n                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n                ip += 4 + bc[ip + 2];\n              }\n\n              break;\n\n            case 16:\n              ends.push(end);\n              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {\n                end = ip + 4 + bc[ip + 2];\n                ip += 4;\n              } else {\n                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n                ip += 4 + bc[ip + 2];\n              }\n\n              break;\n\n            case 17:\n              stack.push(input.substr(peg$currPos, bc[ip + 1]));\n              peg$currPos += bc[ip + 1];\n              ip += 2;\n              break;\n\n            case 18:\n              stack.push(peg$consts[bc[ip + 1]]);\n              peg$currPos += peg$consts[bc[ip + 1]].length;\n              ip += 2;\n              break;\n\n            case 19:\n              stack.push(peg$FAILED);\n              if (peg$silentFails === 0) {\n                peg$fail(peg$consts[bc[ip + 1]]);\n              }\n              ip += 2;\n              break;\n\n            case 20:\n              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];\n              ip += 2;\n              break;\n\n            case 21:\n              peg$reportedPos = peg$currPos;\n              ip++;\n              break;\n\n            case 22:\n              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);\n              for (i = 0; i < bc[ip + 3]; i++) {\n                params[i] = stack[stack.length - 1 - params[i]];\n              }\n\n              stack.splice(\n                stack.length - bc[ip + 2],\n                bc[ip + 2],\n                peg$consts[bc[ip + 1]].apply(null, params)\n              );\n\n              ip += 4 + bc[ip + 3];\n              break;\n\n            case 23:\n              stack.push(peg$parseRule(bc[ip + 1]));\n              ip += 2;\n              break;\n\n            case 24:\n              peg$silentFails++;\n              ip++;\n              break;\n\n            case 25:\n              peg$silentFails--;\n              ip++;\n              break;\n\n            default:\n              throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");\n          }\n        }\n\n        if (ends.length > 0) {\n          end = ends.pop();\n          ip = ips.pop();\n        } else {\n          break;\n        }\n      }\n\n      return stack[0];\n    }\n\n    var data = {};\n\n    peg$result = peg$parseRule(peg$startRuleIndex);\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return data;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      return -1;\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       function (input, startRule) {return parse(input, {startRule: startRule});}\n  };\n};\n/* jshint ignore:end */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sip.js/src/Grammar/dist/Grammar.js\n ** module id = 34\n ** module chunks = 0\n **/","var EventEmitter = function() {\n    this.handlers = {};\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nEventEmitter.prototype.emit = function(name /*, args */) {\n    var self = this, args = Array.prototype.slice.call(arguments, 1);\n    if (name in this.handlers) {\n        var list = this.handlers[name];\n        for (var i = 0; i < list.length; i++) {\n            setTimeout(executeListener(list[i]), 0);\n        }\n    }\n    function executeListener(listener) {\n        return function() {\n            listener.apply(self, args);\n        }\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nEventEmitter.prototype.on = function(name, listener) {\n    if (!Array.isArray(name)) name = [name];\n    for (var i = 0; i < name.length; i++) {\n        this.handlers[name[i]] = this.handlers[name[i]] || [];\n        var list = this.handlers[name[i]];\n        list.push(listener);\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nEventEmitter.prototype.off = function(name, listener) {\n    this.handlers[name] = this.handlers[name] || [];\n    var index = this.handlers[name].indexOf(listener);\n    if (index !== -1) {\n        this.handlers[name].splice(index, 1);\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\nEventEmitter.prototype.once = function(name, listener) {\n    var self = this;\n\n    function listenOnce() {\n        listener.apply(this, arguments);\n        self.off(name, listenOnce);\n    }\n\n    self.on(name, listenOnce);\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//FIXME Remove Angular-specific\n//monkey patching emit for assuring that $apply is called\nvar __emit = EventEmitter.prototype.emit;\nEventEmitter.prototype.emit = function() {\n    var self = this, args = arguments;\n    setTimeout(function() {\n        __emit.apply(self, args);\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nmodule.exports = EventEmitter;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/emitter.js\n ** module id = 35\n ** module chunks = 0\n **/","var SIP = require('sip.js');\nvar EventEmitter = require('./emitter');\nvar PhoneLine = require('./phoneLine');\nvar utils = require('./utils');\n\nvar extend = utils.extend;\nvar uuid = utils.uuid;\n\nvar EVENT_NAMES = require('./eventNames');\nvar DomAudio = require('./dom');\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n/**\n * @param options\n * @constructor\n */\nvar UserAgent = function(options) {\n    this.eventEmitter = new EventEmitter();\n    this.sipConfig = options ? (options.sipConfig || {}) : ({});\n    this.lines = {};\n    this.userAgent = undefined;\n    this.getUserMedia = undefined;\n    this.RTCPeerConnection = undefined;\n    this.RTCSessionDescription = undefined;\n    this.dom = new DomAudio();\n    this._x_userAgent = '';\n    this._client_id = '';\n    this.checkConfig();\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.checkConfig = function() {\n    // set mootools expands to non-enumerables under ES5\n    if (typeof this.sipConfig.wsServers === 'string') {\n        this.sipConfig.wsServers = [\n            {ws_uri: this.sipConfig.wsServers}\n        ];\n    }\n    var key, enums = {enumerable: false};\n    for (key in this.sipConfig.wsServers) this.sipConfig.wsServers.hasOwnProperty(key) || Object.defineProperty(Array.prototype, key, enums);\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.setSIPConfig = function(config) {\n    var wsServers = config.wsServers,\n        useSecureConnection = (document.location.protocol == 'https:');\n\n    for (var i = 0; i < wsServers.length; i++) {\n        if (\n            (useSecureConnection && /^wss:/.test(wsServers[i]))\n            ||\n            (!useSecureConnection && /^ws:/.test(wsServers[i]))\n        ) {\n            config.wsServers = [wsServers[i]];\n            break;\n        }\n    }\n\n    this.sipConfig = config;\n    this._x_userAgent = config.headers[1];\n    this._client_id =  config.headers[2]\n    this.checkConfig();\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.__createLine = function(session, type) {\n    var self = this;\n    session.data.id = uuid();\n    self.eventEmitter.emit(EVENT_NAMES.sipRTCSession, session);\n    var line = new PhoneLine({\n        session: session,\n        userAgent: self,\n        instanceId: self.sipConfig.authorizationUser,\n        eventEmitter: self.eventEmitter,\n        type: type,\n        _x_userAgent: self._x_userAgent,\n        _client_id : self._client_id\n    });\n    self.__clearInactiveLines();\n    self.lines[session.data.id] = line;\n    return line;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.getActiveLines = function() {\n    this.__clearInactiveLines();\n    return this.lines;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.getActiveLinesArray = function() {\n    var lines = this.getActiveLines();\n    var arr = [];\n    for (var id in lines) {\n        if (lines.hasOwnProperty(id)) {\n            arr.push(lines[id]);\n        }\n    }\n    return arr;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.getIncomingLinesArray = function() {\n    return this.getActiveLinesArray().filter(function(el) {\n        return el.isIncoming();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.__clearInactiveLines = function() {\n    for (var id in this.lines) {\n        if (this.lines.hasOwnProperty(id)) {\n            if (this.lines[id].isClosed()) {\n                delete this.lines[id];\n            }\n        }\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nvar __disconnectCount = 0;\n\n\nUserAgent.prototype.start = function(options) {\n    var self = this;\n\n    self.stop();\n    if (self.userAgent instanceof SIP.UA) {\n        self.userAgent.loadConfig(self.sipConfig);\n        self.userAgent.traceSip = true;\n    }\n    else {\n        self.userAgent = new SIP.UA(self.sipConfig);\n        self.__registerExtraOptions = options || {};\n        self.userAgent.on('connected', function(e) {\n            __disconnectCount = 0;\n            self.eventEmitter.emit(EVENT_NAMES.sipConnected, e);\n            self.userAgent.register({\n                extraHeaders: options.extraHeaders || []\n            });\n        });\n        self.userAgent.on('disconnected', function(e) {\n            if (++__disconnectCount >= (self.sipConfig.retryCount || 3)) {\n                __disconnectCount = 0;\n                self.stop();\n                self.eventEmitter.emit(EVENT_NAMES.sipConnectionFailed, new Error(\"Unable to connect to the WS server: exceeded number of attempts\"));\n            }\n            self.eventEmitter.emit(EVENT_NAMES.sipDisconnected, e);\n        });\n        self.userAgent.on('registered', function(e) {\n            self.eventEmitter.emit(EVENT_NAMES.sipRegistered, e);\n        });\n        self.userAgent.on('unregistered', function(e) {\n            self.eventEmitter.emit(EVENT_NAMES.sipUnRegistered, e);\n        });\n        self.userAgent.on('registrationFailed', function(e) {\n            self.eventEmitter.emit(EVENT_NAMES.sipRegistrationFailed, e);\n        });\n        //happens when call is incoming\n        self.userAgent.on('invite', function(session) {\n            var newLine;\n\n            if (session && session.request && session.request.hasHeader('replaces')) {\n                var replaces = session.request.getHeader('replaces').split(';'),\n                    callId = replaces[0],\n                    lines = self.getActiveLinesArray(),\n                    foundLine = null;\n                for (var i = 0; i < lines.length; i++) {\n                    if (lines[i].session.request.call_id) {\n                        if (callId === lines[i].session.request.call_id) {\n                            foundLine = lines[i];\n                            break;\n                        }\n                    }\n                }\n\n                if (foundLine) {\n                    var originalSessionId = foundLine.getId();\n                    newLine = self.__createLine(session, PhoneLine.types.incoming);\n                    newLine.answer().then(function() {\n                        self.eventEmitter.emit(EVENT_NAMES.callReplaced, newLine, foundLine);\n                        foundLine.cancel();\n                    });\n                }\n            }\n            else {\n                newLine = self.__createLine(session, PhoneLine.types.incoming);\n                self.eventEmitter.emit(EVENT_NAMES.sipIncomingCall, newLine);\n            }\n        });\n    }\n    //noop on transport connected (this will cause unwanted REGISTER)\n    self.userAgent.registerContext.onTransportConnected = function() {};\n    self.userAgent.start();\n\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.reregister = function(options, reconnect) {\n    var self = this, reconnect = !!reconnect;\n    options = extend(self.__registerExtraOptions, options);\n    if (!self.userAgent) {\n        self.start(options);\n    }\n    if (!reconnect) {\n        self.userAgent.register(options);\n    }\n    else {\n        if (!self.isConnected()) {\n            self.stop();\n            self.start(options);\n        }\n        else {\n            //This will be treated as abrupt disconnection and SIP.js will try to reconnect the WS\n            self.userAgent.transport.ws.close();\n        }\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.stop = function() {\n    if (this.userAgent instanceof SIP.UA) {\n        this.userAgent.stop();\n        this.userAgent = null;\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.call = function(number, inviteOptions) {\n    var self = this;\n    var options = {\n        media: {\n            constraints: {audio: true, video: false},\n            render: {\n                local: {\n                    audio: self.dom.localAudio\n                },\n                remote: {\n                    audio: self.dom.remoteAudio\n                }\n            }\n        },\n        RTCConstraints: {\n            \"optional\": [\n                {'DtlsSrtpKeyAgreement': 'true'}\n            ]\n        }\n    };\n    var fromNumber = inviteOptions.fromNumber;\n    var country = inviteOptions.country;\n\n    var headers = [];\n    if (fromNumber) {\n        headers.push('P-Asserted-Identity: sip:' + fromNumber + '@' + this.sipConfig.domain);\n    }\n    if (country) {\n        headers.push('P-rc-country-id: ' + country);\n    }\n\n    headers.push(self._x_userAgent);\n    headers.push(self._client_id);\n\n    extend(options, {\n        extraHeaders: headers\n    });\n    var session = this.userAgent.invite('' + number, options);\n    var line = self.__createLine(session, PhoneLine.types.outgoing);\n    this.eventEmitter.emit(EVENT_NAMES.outgoingCall, line);\n    return line;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.answer = function(line) {\n    return line && line.answer();\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n\nUserAgent.prototype.hangup = function(line) {\n    if (line) {\n        line.cancel();\n        delete this.lines[line.getId()];\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.on = function(eventName, cb) {\n    this.eventEmitter.on(eventName, cb);\n    return this;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.isConnected = function() {\n    return !!(this.userAgent && this.userAgent.transport && this.userAgent.transport.connected);\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.isConnecting = function() {\n    //websocket.readyState === CONNECTING (0)\n    return !this.isConnected() && !!(this.userAgent && this.userAgent.transport && this.userAgent.transport.ws && this.userAgent.transport.ws.readyState === 0);\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nUserAgent.prototype.forceDisconnect = function() {\n    console.warn(this.isConnecting(), this.isConnected())\n    if (this.isConnecting() || this.isConnected()) {\n        this.userAgent.transport.disconnect();\n        this.userAgent.stop();\n        this.userAgent = null;\n    }\n};\n\nmodule.exports = UserAgent;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/userAgent.js\n ** module id = 36\n ** module chunks = 0\n **/","var SIP = require('sip.js');\nvar utils = require('./utils');\nvar EVENT_NAMES = require('./eventNames');\n\nvar delay = utils.delay;\nvar extend = utils.extend;\n\nvar index = 0;\n\n/**\n * @param options\n * @constructor\n */\nvar PhoneLine = function(options) {\n\n    var self = this;\n    this.index = index++;\n\n    this.session = options.session;\n    this.userAgent = options.userAgent;\n    this.eventEmitter = options.eventEmitter;\n    this.instanceId = options.instanceId;\n    this.sessionId = this.session && this.session.id;\n\n    this.onCall = false;\n    this.onRecord = false;\n    this.contact = {};\n    this.muted = false;\n    this.bothMuted = false;\n    this.onHold = false;\n    this.timeCallStarted = null;\n\n    this.accepted = false;\n    this.type = options.type;\n\n    this._x_userAgent = options._x_userAgent;\n    this._client_id = options._client_id;\n\n    this.responseTimeout = 10000;\n\n    this.controlSender = {\n        messages: {\n            park: {reqid: 1, command: 'callpark'},\n            startRecord: {reqid: 2, command: 'startcallrecord'},\n            stopRecord: {reqid: 3, command: 'stopcallrecord'},\n            flip: {reqid: 3, command: 'callflip', target: ''},\n            monitor: {reqid: 4, command: 'monitor'},\n            barge: {reqid: 5, command: 'barge'},\n            whisper: {reqid: 6, command: 'whisper'},\n            takeover: {reqid: 7, command: 'takeover'}\n        },\n        send: function(command, options) {\n\n            options = options || {};\n            extend(command, options);\n\n            var cseq = null;\n\n            return new Promise(function(resolve, reject){\n\n                var headers = [];\n\n                headers.push('Content-Type: application/json;charset=utf-8');\n                headers.push(self._x_userAgent);\n                headers.push(self._client_id);\n\n                self.session.sendRequest(SIP.C.INFO, {\n                    body: JSON.stringify({\n                        request: command\n                    }),\n                    extraHeaders: headers,\n                    receiveResponse: function(response) {\n                        var timeout = null;\n                        if (response.status_code === 200) {\n                            cseq = response.cseq;\n                            function onInfo(request) {\n                                if (response.cseq === cseq) {\n                                    var body = request && request.body || '{}';\n                                    var obj;\n\n                                    try {\n                                        obj = JSON.parse(body);\n                                    }\n                                    catch (e) {\n                                        obj = {};\n                                    }\n\n                                    if (obj.response && obj.response.command === command.command) {\n                                        if (obj.response.result) {\n                                            if (obj.response.result.code == 0) {\n                                                resolve(obj.response.result);\n                                            }\n                                            else {\n                                                reject(obj.response.result);\n                                            }\n                                        }\n                                    }\n                                    timeout && clearTimeout(timeout);\n                                    self.eventEmitter.off('SIP_INFO', onInfo);\n                                    resolve(); //FIXME What to resolve\n                                }\n                            }\n\n                            timeout = setTimeout(function() {\n                                reject(new Error('Timeout: no reply'));\n                                self.eventEmitter.off('SIP_INFO', onInfo);\n                            }, self.responseTimeout);\n                            self.eventEmitter.on('SIP_INFO', onInfo);\n                        }\n                        else {\n                            reject(new Error('The INFO response status code is: ' + response.status_code + ' (waiting for 200)'));\n                        }\n                    }\n                });\n\n            });\n        }\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    var __receiveRequest = this.session.receiveRequest;\n    this.session.receiveRequest = function(request) {\n        switch (request.method) {\n            case SIP.C.INFO:\n                self.eventEmitter.emit('SIP_INFO', request);\n                //SIP.js does not support application/json content type, so we monkey override its behaviour in this case\n                if (this.status === SIP.Session.C.STATUS_CONFIRMED || this.status === SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n                    var contentType = request.getHeader('content-type');\n                    if (contentType.match(/^application\\/json/i)) {\n                        request.reply(200);\n                        return this;\n                    }\n                }\n                break;\n            //Refresh invite should not be rejected with 488\n            case SIP.C.INVITE:\n                var session = this;\n                if (session.status === SIP.Session.C.STATUS_CONFIRMED) {\n                    if (request.call_id && session.dialog && session.dialog.id && request.call_id == session.dialog.id.call_id) {\n                        //TODO: check that SDP did not change\n                        session.logger.log('re-INVITE received');\n                        var localSDP = session.mediaHandler.peerConnection.localDescription.sdp;\n                        request.reply(200, null, ['Contact: ' + self.contact], localSDP, function() {\n                            session.status = SIP.Session.C.STATUS_WAITING_FOR_ACK;\n                            session.setInvite2xxTimer(request, localSDP);\n                            session.setACKTimer();\n                        });\n                        return session;\n                    }\n                    //else will be rejected with 488 by SIP.js\n                }\n                break;\n            //We need to analize NOTIFY messages sometimes, so we fire an event\n            case SIP.C.NOTIFY:\n                self.eventEmitter.emit('SIP_NOTIFY', request);\n                break;\n        }\n        return __receiveRequest.apply(self.session, arguments);\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Fired when ICE is starting to negotiate between the peers.\n    this.session.on('connecting', function(e) {\n        self.eventEmitter.emit(EVENT_NAMES.callConnecting, self, e);\n        setTimeout(function() {\n            if (self.session.mediaHandler.onIceCompleted !== undefined) {\n                self.session.mediaHandler.onIceCompleted(self.session);\n            }\n            else {\n                self.session.mediaHandler.callOnIceCompleted = true;\n            }\n        }, self.userAgent.sipConfig['iceGatheringTimeout'] || 3000);\n    });\n\n    this.__hasEarlyMedia = false;\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n\n    //Monkey patching for handling early media and to delay ACKs\n    var __receiveInviteReponse = this.session.receiveInviteResponse,\n        __waitingForIce = false;\n    this.session.receiveResponse = this.session.receiveInviteResponse = function(response) {\n        var sessionSelf = this, args = arguments;\n        switch (true) {\n            case (/^1[0-9]{2}$/.test(response.status_code)):\n                //Let's not allow the library to send PRACK\n                if (self.hasEarlyMedia()) {\n                    this.emit('progress', response);\n                    return;\n                }\n                break;\n            case /^(2[0-9]{2})|(4\\d{2})$/.test(response.status_code):\n                if (!self.hasEarlyMedia()) break;\n\n                //Let's check the ICE connection state\n                if (self.session.mediaHandler.peerConnection.iceConnectionState === 'completed' && !__waitingForIce) {\n                    __waitingForIce = false;\n                    //if ICE is connected, then let the library to handle the ACK\n                    break;\n                }\n                else {\n                    //If ICE is not connected, then we should send ACK after it has been connected\n                    if (!__waitingForIce) {\n                        self.eventEmitter.once(EVENT_NAMES.ICECompleted, function() {\n                            //let the library handle the ACK after ICE connection is completed\n                            __waitingForIce = false;\n                            __receiveInviteReponse.apply(sessionSelf, args);\n                        });\n\n                        self.eventEmitter.once(EVENT_NAMES.ICEFailed, function() {\n                            //handle the ICE Failed situation\n                            __waitingForIce = false;\n                            self.session.acceptAndTerminate(response, null, 'ICE Connection Failed');\n                        });\n\n                        __waitingForIce = true;\n                    }\n                    return;\n                }\n                break;\n        }\n        return __receiveInviteReponse.apply(sessionSelf, args);\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Fired each time a provisional (100-199) response is received.\n    this.session.on('progress', function(e) {\n        self.onCall = true;\n\n        //Early media is supported by SIP.js library\n        //But in case it is sent without 100rel support we play it manually\n        //STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported\n        if (self.session.status !== SIP.Session.C.STATUS_EARLY_MEDIA && e.status_code === 183 && typeof(e.body) === 'string' && e.body.indexOf('\\n') !== -1) {\n            var session = self.session,\n                response = e;\n\n            if (session.hasOffer) {\n                if (!session.createDialog(response, 'UAC')) {\n                    return;\n                }\n                session.hasAnswer = true;\n                session.mediaHandler.setDescription(\n                    response.body,\n                    function() {\n                        session.dialog.pracked.push(response.getHeader('rseq'));\n                        session.status = SIP.Session.C.STATUS_EARLY_MEDIA;\n                        session.mute();\n                        self.__hasEarlyMedia = true;\n                        self.eventEmitter.emit(EVENT_NAMES.callProgress, self, e);\n                    },\n                    function(e) {\n                        session.logger.warn(e);\n                        session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n                        session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                    }\n                );\n            }\n        }\n    });\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Fired each time a successful final (200-299) response is received.\n    this.session.on('accepted', function(e) {\n        if (self.accepted === true) return;\n        self.onCall = true;\n        self.accepted = true;\n        self.timeCallStarted = new Date();\n        self.eventEmitter.emit(EVENT_NAMES.callStarted, self, e);\n    });\n\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function onEnd() {\n        self.onCall = false;\n        self.timeCallStarted = null;\n        self.accepted = true;\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n    //Fired each time an unsuccessful final (300-699) response is\n    //this will emit failed event\n    this.session.on('rejected', function(e) {\n        onEnd();\n        self.eventEmitter.emit(EVENT_NAMES.callRejected, self, e);\n        //terminated is not called by SIP.js when the call is rejected\n        //self.eventEmitter.emit(EVENT_NAMES.callTerminated, self, e);\n    });\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Fired when the session was canceled by the client\n    this.session.on('cancel', function(e) {\n        onEnd();\n        self.eventEmitter.emit(EVENT_NAMES.callEnded, self, e);\n    });\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Fired when a BYE is sent\n    this.session.on('bye', function(e) {\n        onEnd();\n        self.eventEmitter.emit(EVENT_NAMES.callEnded, self, e);\n    });\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Fired when the request fails, whether due to an unsuccessful final response or due to timeout, transport, or other error\n    this.session.on('failed', function(response, cause) {\n        this.terminated(null, cause);\n        onEnd();\n        self.eventEmitter.emit(EVENT_NAMES.callFailed, self, response, cause);\n        //SIP.js 0.6.x does not call terminated event sometimes, so we call it ourselves\n        if (cause === SIP.C.causes.REQUEST_TIMEOUT) {\n            //this === session\n            if (this.status !== SIP.Session.C.STATUS_CONFIRMED) {\n                this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n            }\n        }\n    });\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    this.session.on('terminated', function(response, cause) {\n        onEnd();\n        self.eventEmitter.emit(EVENT_NAMES.callTerminated, self, response, cause);\n    });\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function terminateCallOnDisconnected(reason) {\n        self.session.terminated(null, reason || SIP.C.causes.CONNECTION_ERROR);\n        onEnd();\n        self.eventEmitter.emit(EVENT_NAMES.callFailed, self, null, 'Connection error');\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n//FIXME: Explore if it can be replaced with ref: http://sipjs.com/api/0.7.0/mediaHandler/\n\n    //Monkey patching oniceconnectionstatechange because SIP.js 0.6.x does not have this event\n    var onStateChange = this.session.mediaHandler.peerConnection.oniceconnectionstatechange || function(){},\n        __doubleCompleted = false;\n    this.session.mediaHandler.peerConnection.oniceconnectionstatechange = function() {\n        //this === peerConnection\n        var state = this.iceConnectionState;\n        onStateChange.apply(this, arguments);\n\n        switch (state) {\n            case 'connected':\n                self.eventEmitter.emit(EVENT_NAMES.ICEConnected, self);\n                break;\n            case 'completed':\n                //this may be called twice, see: https://code.google.com/p/chromium/issues/detail?id=371804\n                if (!__doubleCompleted) {\n                    self.eventEmitter.emit(EVENT_NAMES.ICECompleted, self);\n                    __doubleCompleted = true;\n                }\n                break;\n            case 'disconnected':\n                terminateCallOnDisconnected();\n                self.eventEmitter.emit(EVENT_NAMES.ICEDisconnected, self);\n                break;\n            case 'failed':\n                self.eventEmitter.emit(EVENT_NAMES.ICEFailed, self);\n                break;\n        }\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    var __ignoreReinviteDuplicates = false;\n\n    //Monkey patching sendReinvite for better Hold handling\n    var __sendReinvite = this.session.sendReinvite;\n    this.session.sendReinvite = function() {\n        __ignoreReinviteDuplicates = false;\n        var res = __sendReinvite.apply(this, arguments);\n        var __reinviteSucceeded = this.reinviteSucceeded,\n            __reinviteFailed = this.reinviteFailed;\n        this.reinviteSucceeded = function() {\n            self.eventEmitter.emit(EVENT_NAMES.callReinviteSucceeded, self);\n            return __reinviteSucceeded.apply(this, []);\n        };\n        this.reinviteFailed = function() {\n            self.eventEmitter.emit(EVENT_NAMES.callReinviteFailed, self);\n            return __reinviteFailed.apply(this, []);\n        };\n        return res;\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //Monkey patching receiveReinviteResponse to ignore duplicates which may break Hold/Unhold\n    var __receiveReinviteResponse = this.session.receiveReinviteResponse;\n    this.session.receiveReinviteResponse = function(response) {\n        switch (true) {\n            case /^2[0-9]{2}$/.test(response.status_code):\n                if (__ignoreReinviteDuplicates) {\n                    this.sendRequest(SIP.C.ACK, {cseq: response.cseq});\n                    return;\n                }\n                __ignoreReinviteDuplicates = true;\n                break;\n        }\n        return __receiveReinviteResponse.apply(this, arguments);\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    //defining if the session is incoming or outgoing\n    if (this.type === PhoneLine.types.incoming) {\n        this.contact.name = this.session.request.from.uri.displayName;\n        this.contact.number = this.session.request.from.uri.user;\n\n    } else {\n        if (this.type === PhoneLine.types.outgoing) {\n            this.contact.name = this.session.request.to.uri.displayName;\n            this.contact.number = this.session.request.to.uri.user;\n        }\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.types = {\n    incoming: 'incoming',\n    outgoing: 'outgoing'\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.getId = function() {\n    return this.session.data.id;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.getSession = function() {\n    return this.session;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.cancel = function() {\n    var session = this.getSession();\n    return new Promise(function(resolve, reject) {\n        session.terminate({statusCode: 486});\n        resolve();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.record = function(val) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        if (self.onCall) {\n            var message = !!val\n                ? self.controlSender.messages.startRecord\n                : self.controlSender.messages.stopRecord;\n\n            if ((self.onRecord && !val) || (!self.onRecord && val)) {\n                return self.controlSender.send(message)\n                    .then(function(data) {\n                        self.onRecord = !!val;\n                        return data;\n                    });\n            }\n        }\n        else {\n            reject(new Error('No line or no active line'));\n        }\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.flip = function(target) {\n    var self = this;\n\n    return new Promise(function(resolve, reject){\n        if (!target) return;\n        if (self.onCall) {\n            return self.controlSender.send(self.controlSender.messages.flip, {\n                target: target\n            });\n        }\n        else {\n           reject(new Error('No line or no active line'));\n        }\n    });\n};\n\nPhoneLine.prototype.park = function() {\n\n    var self = this;\n    return new Promise(function(resolve, reject){\n        if (self.onCall) {\n            resolve(self.controlSender.send(self.controlSender.messages.park));\n        }\n        else\n            reject(new Error('No line or no active line'));\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n// Explore ref: http://sipjs.com/api/0.6.0/session/#dtmftone-options\n\nPhoneLine.prototype.sendDTMF = function(value, duration) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        if(self.onCall) {\n            duration = parseInt(duration) || 1000;\n            var peer = self.session.mediaHandler.peerConnection;\n            var stream = self.session.getLocalStreams()[0];\n            var dtmfSender = peer.createDTMFSender(stream.getAudioTracks()[0]);\n            if (dtmfSender !== undefined && dtmfSender.canInsertDTMF) {\n                dtmfSender.insertDTMF(value, duration);\n            }\n            resolve();\n        }\n        else\n            reject(new Error('No line or no active line'));\n    });\n};\n\n/*\nCurrently not supported\n */\nPhoneLine.prototype.sendInfoDTMF = function(value, duration) {\n    var session = this.session;\n    return new Promise(function(resolve, reject) {\n        duration = parseInt(duration) || 1000;\n        session.dtmf(value.toString(), {\n            duration: duration\n        });\n        resolve();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.blindTransfer = function(target, options) {\n    var session = this.session;\n    var self = this;\n    var extraHeaders = [];\n    var originalTarget = target;\n    options = options || {};\n\n    return new Promise(function(resolve, reject){\n        //Blind Transfer is taken from SIP.js source\n\n        // Check Session Status\n        if (session.status !== SIP.Session.C.STATUS_CONFIRMED) {\n            reject(new SIP.Exceptions.InvalidStateError(session.status));\n        }\n\n        // normalizeTarget allows instances of SIP.URI to pass through unaltered,\n        // so try to make one ahead of time\n        try {\n            target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n        } catch (e) {\n            session.logger.debug(\".refer() cannot parse Refer_To from\", target);\n            session.logger.debug(\"...falling through to normalizeTarget()\");\n        }\n\n        // Check target validity\n        target = session.ua.normalizeTarget(target);\n        if (!target) {\n            throw new TypeError('Invalid target: ' + originalTarget);\n        }\n\n        extraHeaders.push('Contact: ' + session.contact);\n        extraHeaders.push('Allow: ' + SIP.Utils.getAllowedMethods(session.ua));\n        extraHeaders.push('Refer-To: ' + target);\n        extraHeaders.push('x-user-agent:'+self._x_userAgent);\n        extraHeaders.push('client-id'+self._x_userAgent);\n\n\n        // Send the request\n        session.sendRequest(SIP.C.REFER, {\n            extraHeaders: extraHeaders,\n            body: options.body,\n            receiveResponse: function(response) {\n                var timeout = null;\n                if (response.status_code === 202) {\n                    var callId = response.call_id;\n\n                    function onNotify(request) {\n                        if (request.call_id === callId) {\n                            var body = request && request.body || '';\n                            switch (true) {\n                                case /1[0-9]{2}/.test(body):\n                                    request.reply(200);\n                                    break;\n                                case /2[0-9]{2}/.test(body):\n                                    self.session.terminate();\n                                    clearTimeout(timeout);\n                                    self.eventEmitter.off('SIP_NOTIFY', onNotify);\n                                    resolve();\n                                    break;\n                                default:\n                                    reject(body);\n                                    break;\n                            }\n                        }\n                    }\n\n                    timeout = setTimeout(function() {\n                        reject(new Error('Timeout: no reply'));\n                        self.eventEmitter.off('SIP_NOTIFY', onNotify);\n                    }, self.responseTimeout);\n                    self.eventEmitter.on('SIP_NOTIFY', onNotify);\n                }\n                else {\n                    reject(new Error('The response status code is: ' + response.status_code + ' (waiting for 202)'));\n                }\n            }\n        });\n\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.transfer = function(target, options) {\n    var self = this;\n    return (self.onHold ? Promise.resolve(null) : self.setHold(true)).then(function(){ return delay(300); }).then(function() {\n        return self.blindTransfer(target, options);\n    });\n};\n\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.forward = function(target, options) {\n    var self = this, interval = null;\n    return self.answer().then(function() {\n        return new Promise(function(resolve, reject){\n            interval = setInterval(function() {\n                if (self.session.status === 12) {\n                    clearInterval(interval);\n                    self.setMute(true);\n                    setTimeout(function() {\n                        self.transfer(target, options);\n                        resolve();\n                    }, 700);\n                }\n            }, 50);\n        });\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n//ref: http://sipjs.com/api/0.6.0/session/#acceptoptions\n//make var option = {}\n\nPhoneLine.prototype.answer = function() {\n    var self = this;\n\n    return new Promise(function(resolve, reject){\n\n        function onAnswered() {\n            resolve();\n            self.eventEmitter.off(EVENT_NAMES.callStarted, onAnswered);\n            self.eventEmitter.off(EVENT_NAMES.callFailed, onFail);\n        }\n\n        function onFail(e) {\n            reject(e);\n            self.eventEmitter.off(EVENT_NAMES.callStarted, onAnswered);\n            self.eventEmitter.off(EVENT_NAMES.callFailed, onFail);\n        }\n\n        self.eventEmitter.on(EVENT_NAMES.callStarted, onAnswered);\n        self.eventEmitter.on(EVENT_NAMES.callFailed, onFail);\n\n        self.eventEmitter.emit(EVENT_NAMES.callProgress, self);\n\n        self.session.accept({\n            media: {\n                constraints: {audio: true, video: false},\n                render: {\n                    local: {\n                        audio: self.userAgent.dom.localAudio\n                    },\n                    remote: {\n                        audio: self.userAgent.dom.remoteAudio\n                    }\n                }\n            }\n        });\n\n    });\n\n};\n\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//FIXME: Use SIPJS mute() and unmute() ref: http://sipjs.com/api/0.7.0/session/#muteoptions\n\nPhoneLine.prototype.setMute = function(val) {\n    var self = this;\n    return new Promise(function(resolve, reject) {\n        self.muted = !!val;\n        if (self.onCall) {\n            setStreamMute(self.session.getLocalStreams()[0], self.muted);\n            val ? self.eventEmitter.emit(EVENT_NAMES.callMute, self) : self.eventEmitter.emit(EVENT_NAMES.callUnmute, self);\n            resolve();\n        }\n        else\n            reject(new Error('No line or no active line'));\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//FIXME: Use SIPJS mute() and unmute() ref: http://sipjs.com/api/0.7.0/session/#muteoptions\n\nfunction setStreamMute(stream, val) {\n    var tracks = stream.getAudioTracks();\n    for (var i = 0; i < tracks.length; i++) {\n        tracks[i].enabled = !val;\n    }\n}\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n////FIXME: Use SIPJS mute() and unmute() ref: http://sipjs.com/api/0.7.0/session/#muteoptions\n\nPhoneLine.prototype.setMuteBoth = function(val) {\n    var self = this;\n    return new Promise(function(resolve, reject) {\n        self.bothMuted = !!val;\n        self.muted = !!val;\n        if (self.onCall) {\n            setStreamMute(self.session.getLocalStreams()[0], self.bothMuted);\n            setStreamMute(self.session.getRemoteStreams()[0], self.bothMuted);\n            val ? self.eventEmitter.emit(EVENT_NAMES.callMute, self) : self.eventEmitter.emit(EVENT_NAMES.callUnmute, self);\n            resolve();\n        }\n        else\n            reject(new Error('No line or no active line'));\n    });\n\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//FIXME: Explore send() ref: http://sipjs.com/api/0.7.0/transport/#sendmsg\n\n/* This is a direct and very tightly coupled code. Please, try to avoid using this method if possible */\nPhoneLine.prototype.sendRequest = function(method, body, options) {\n    var self = this;\n    options = options || {};\n\n    if (!this.session.dialog) return;\n\n    var request = new SIP.OutgoingRequest(\n        method,\n        self.session.dialog.remote_target,\n        self.session.ua,\n        {\n            cseq: options.cseq || (self.session.dialog.local_seqnum += 1),\n            call_id: self.session.dialog.id.call_id,\n            from_uri: self.session.dialog.local_uri,\n            from_tag: self.session.dialog.id.local_tag,\n            to_uri: self.session.dialog.remote_uri,\n            to_tag: self.session.dialog.id.remote_tag,\n            route_set: self.session.dialog.route_set,\n            statusCode: options.statusCode,\n            reasonPhrase: options.reasonPhrase\n        },\n        options.extraHeaders || [],\n        body || undefined\n    );\n\n    new SIP.RequestSender({\n        request: request,\n        onRequestTimeout: function() {\n            self.session.onRequestTimeout();\n        },\n        onTransportError: function() {\n            self.session.onTransportError();\n        },\n        receiveResponse: options.receiveResponse || function(response) {\n        }\n    }, self.session.ua).send();\n};\n\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n//FIXME: should be replaced with __hold()\n//This can be removed\n//Legacy hold uses direct in-dialog messages to trick SIP.js, try to avoid using this method if possible\nPhoneLine.prototype.__legacyHold = function(val) {\n    var self = this;\n    self.onHold = !!val;\n    return new Promise(function(resolve, reject){\n        if (self.onCall && self.session.dialog) {\n            var body = self.session.mediaHandler.peerConnection.localDescription.sdp;\n            if (self.onHold) {\n                //body = body.replace(/c=IN IP4 \\d+\\.\\d+.\\d+.\\d+/, \"c=IN IP4 0.0.0.0\");\n                body = body.replace(/a=sendrecv/, \"a=sendonly\");\n                self.session.mediaHandler.hold();\n                self.session.onhold('local');\n            }\n            else {\n                self.session.mediaHandler.unhold();\n                self.session.onunhold('local');\n            }\n\n            self.sendRequest(SIP.C.INVITE, body, {\n                extraHeaders: [\n                    \"Content-Type: application/sdp\",\n                    \"Contact: \" + self.session.contact,\n                    self._x_userAgent,\n                    self._client_id\n                ],\n                receiveResponse: function(response) {\n                    switch (true) {\n                        case /^1[0-9]{2}$/.test(response.status_code):\n                            break;\n                        case /^2[0-9]{2}$/.test(response.status_code):\n                            resolve();\n                            self.sendRequest(SIP.C.ACK, null, {\n                                cseq: response.cseq\n                            });\n                            break;\n                        default:\n                            reject('Status code is: ' + response.status_code);\n                            self.onHold = !self.onHold;\n                            break;\n                    }\n                }\n            });\n        }\n        else {\n            throw new Error('No line or no active line');\n        }\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\n\nPhoneLine.prototype.__hold = function(val) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        function onSucceeded() {\n            resolve();\n            self.eventEmitter.off(EVENT_NAMES.callReinviteFailed, onFailed);\n        }\n\n        function onFailed(e) {\n            reject(e);\n            self.eventEmitter.off(EVENT_NAMES.callReinviteSucceeded, onSucceeded);\n        }\n\n        self.eventEmitter.once(EVENT_NAMES.callReinviteSucceeded, onSucceeded);\n        self.eventEmitter.once(EVENT_NAMES.callReinviteFailed, onFailed);\n\n        val ? self.session.hold() : self.session.unhold();\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.setHold = function(val) {\n    var self = this;\n    return new Promise(function(resolve, reject){\n        self.onHold = !!val;\n        if (self.onCall) {\n            resolve(self.__hold(val).then(function(res) {\n                if (val) {\n                    self.eventEmitter.emit(EVENT_NAMES.callHold, self);\n                } else {\n                    self.eventEmitter.emit(EVENT_NAMES.callUnhold, self);\n                }\n                return res;\n            }).catch(function(e) {\n                self.onHold = !self.onHold;\n                throw e;\n            }));\n        }\n        else\n            reject(new Error('No line or no active line'));\n    });\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.isOnHold = function() {\n    return this.onHold;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.isOnMute = function() {\n    return this.muted || this.bothMuted;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.isOnRecord = function() {\n    return this.onRecord;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.getContact = function() {\n    return this.contact;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.getCallDuration = function() {\n    if (this.timeCallStarted) {\n        return (new Date()).getTime() - this.timeCallStarted.getTime();\n    }\n    else {\n        return 0;\n    }\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.isIncoming = function() {\n    return this.session.mediaHandler.peerConnection.signalingState !== \"closed\"\n        && !this.session.startTime;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.isClosed = function() {\n    return this.session.status === SIP.Session.C.STATUS_CANCELED || this.session.status === SIP.Session.C.STATUS_TERMINATED;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nPhoneLine.prototype.hasEarlyMedia = function() {\n    return this.__hasEarlyMedia;\n};\n\n/*--------------------------------------------------------------------------------------------------------------------*/\n\nmodule.exports = PhoneLine;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/phoneLine.js\n ** module id = 37\n ** module chunks = 0\n **/","module.exports = {\n\n    delay: function delay(ms) {\n        return new Promise(function(resolve, reject) {\n            setTimeout(resolve, ms);\n        });\n    },\n\n    defer: function defer() {\n        var deferred = {};\n        deferred.promise = new Promise(function(resolve, reject) {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n        return deferred;\n    },\n\n    extend: function extend(dst, src) {\n        src = src || {};\n        dst = dst || {};\n        Object.keys(src).forEach(function(k) {\n            dst[k] = src[k];\n        });\n        return dst;\n    },\n\n    copy: function(src){\n        return this.extend({}, src);\n    },\n\n    uuid: function uuid() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/utils.js\n ** module id = 38\n ** module chunks = 0\n **/","module.exports = {\n    'message': 'message',\n    'sipConnecting': 'sipConnecting',\n    'sipConnected': 'sipConnected',\n    'sipDisconnected': 'sipDisconnected',\n    'sipRegistered': 'sipRegistered',\n    'sipUnRegistered': 'sipUnregistered',\n    'sipRegistrationFailed': 'sipRegistrationFailed',\n    'incomingCall': 'incomingCall',                     //when incoming call is received\n    'sipIncomingCall': 'sipIncomingCall',               //same as incomingCall\n    'outgoingCall': 'outgoingCall',                     //when the outbound call is initiated\n    'callConnecting': 'callConnecting',                 //when ICE gathering is started\n    'callProgress': 'callProgress',                     //when 1xx provisional message is received (outbound only) or call is accepted, but ACK is still not sent (inbound only)\n    'callStarted': 'callStarted',                       //when ACK is sent\n    'callRejected': 'callRejected',                     //when the call is rejected by its party\n    'callEnded': 'callEnded',                           //when the call had ended without errors (BYE)\n    'callTerminated': 'callTerminated',                 //when the media is terminated, UNSTABLE in SIP.js 0.6.x\n    'callFailed': 'callFailed',                         //when the call is failed because of many different reasons (connection issues, 4xx errors, etc.)\n    'callHold': 'callHold',                             //when the call is put on hold\n    'callUnhold': 'callUnhold',                         //when the call is unholded\n    'callMute': 'callMute',                             //when the call is muted\n    'callUnmute': 'callUnmute',                         //when the call is unmuted\n    'callReplaced': 'callReplaced',                     //when the call has been replaced by an incoming invite\n    'sipRTCSession': 'sipRTCSession',\n    'sipConnectionFailed': 'sipConnectionFailed',\n    'ICEConnected': 'ICEConnected',\n    'ICECompleted': 'ICECompleted',\n    'ICEFailed': 'ICEFailed',\n    'ICEChecking': 'ICEChecking',\n    'ICEClosed': 'ICEClosed',\n    'ICEDisconnected': 'ICEDisconnected',\n    'callReinviteSucceeded': 'callReinviteSucceeded',\n    'callReinviteFailed': 'callReinviteFailed'\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/eventNames.js\n ** module id = 39\n ** module chunks = 0\n **/","var uuid = require('./utils').uuid;\n\nfunction DomAudio(){\n\n    /*\n     * We create audio containers here\n     * Sorry for DOM manipulations inside a service, but it is for the good :)\n     */\n    var LOCAL_AUDIO = document.createElement('video'),\n        REMOTE_AUDIO = document.createElement('video'),\n        LOCAL_AUDIO_ID = 'local_' + uuid(),\n        REMOTE_AUDIO_ID = 'remote_' + uuid();\n\n    LOCAL_AUDIO.setAttribute('id', LOCAL_AUDIO_ID);\n    LOCAL_AUDIO.setAttribute('autoplay', 'true');\n    LOCAL_AUDIO.setAttribute('hidden', 'true');\n    LOCAL_AUDIO.setAttribute('muted', '');\n\n    REMOTE_AUDIO.setAttribute('id', REMOTE_AUDIO_ID);\n    REMOTE_AUDIO.setAttribute('autoplay', 'true');\n    REMOTE_AUDIO.setAttribute('hidden', 'true');\n\n    document.body.appendChild(LOCAL_AUDIO);\n    document.body.appendChild(REMOTE_AUDIO);\n\n    LOCAL_AUDIO.volume = 0;\n\n    this.localAudio = LOCAL_AUDIO;\n    this.remoteAudio = REMOTE_AUDIO;\n    this.localAudioId = LOCAL_AUDIO_ID;\n    this.remoteAudioId = REMOTE_AUDIO_ID;\n\n}\n\nmodule.exports = DomAudio;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/dom.js\n ** module id = 40\n ** module chunks = 0\n **/","'use strict';\n\nvar audio = require('./audio');\n\n/**\n * @param {WebPhone} rcSIPUA\n * @param options\n * @constructor\n */\nfunction AudioHelper(rcSIPUA, options) {\n\n    var self = this;\n\n    options = options || {};\n\n    this._rcSIPUA = rcSIPUA;\n    this._incoming = options.incoming || 'audio/incoming.ogg';\n    this._outgoing = options.outgoing || 'audio/outgoing.ogg';\n    this._audio = {};\n\n    rcSIPUA.on(rcSIPUA.events.incomingCall, function() {\n        self.playIncoming(true);\n    });\n\n    rcSIPUA.on(rcSIPUA.events.outgoingCall, function() {\n        self.playOutgoing(true);\n    });\n\n    rcSIPUA.on(rcSIPUA.events.callProgress, function(session) {\n        if (session.hasEarlyMedia()) {\n            self.playOutgoing(false);\n        }\n    });\n\n    rcSIPUA.on([rcSIPUA.events.callStarted, rcSIPUA.events.callRejected, rcSIPUA.events.callEnded, rcSIPUA.events.callFailed], function() {\n        self.playIncoming(false);\n        self.playOutgoing(false);\n    });\n\n}\n\nAudioHelper.prototype._playSound = function(url, val, volume) {\n\n    if (!this._audio[url]) {\n        if (val) {\n            volume !== undefined && (audio.volume = volume);\n            this._audio[url] = audio.play(url, {loop: true});\n        }\n    } else {\n        if (val) {\n            this._audio[url].reset();\n        }\n        else {\n            this._audio[url].stop();\n        }\n    }\n\n};\n\nAudioHelper.prototype.playIncoming = function(val) {\n    this._playSound(this._incoming, val, 0.5);\n};\n\nAudioHelper.prototype.playOutgoing = function(val) {\n    this._playSound(this._outgoing, val, 1);\n};\n\nmodule.exports = AudioHelper;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/audioHelper.js\n ** module id = 41\n ** module chunks = 0\n **/","var error = console.error;\nvar EventEmitter = require('./emitter');\n\nmodule.exports = {\n\n    play: function(url, options) {\n\n        var emitter = new EventEmitter();\n\n        var audio = new Audio();\n\n        audio.volume = 1;\n\n        audio.addEventListener(\"timeupdate\", function(event) {\n            emitter.emit('progress', {\n                duration: audio.duration,\n                progress: audio.currentTime / audio.duration\n            });\n        });\n\n        audio.addEventListener(\"seeked\", function(event) {\n            emitter.emit('progress', {\n                    duration: audio.duration,\n                    progress: audio.currentTime / audio.duration\n            });\n        });\n        audio.addEventListener(\"ended\", function(event) {\n            emitter.emit('ended');\n        });\n        audio.addEventListener(\"pause\", function(event) {\n            emitter.emit('progress', {\n                    duration: audio.duration,\n                    paused: true,\n                    progress: audio.currentTime / audio.duration\n            });\n        });\n        audio.addEventListener(\"play\", function(event) {\n            emitter.emit('progress', {\n                    duration: audio.duration,\n                    resumed: true,\n                    progress: audio.currentTime / audio.duration\n            });\n        });\n        audio.addEventListener(\"error\", function() {\n            console.log(\"error\", audio.error); //FIXME\n            emitter.emit('error', audio.error);\n        });\n\n        emitter.stop = audio.pause.bind(audio);\n        emitter.pause = audio.pause.bind(audio);\n        emitter.resume = audio.play.bind(audio);\n        emitter.reset = function() {\n            audio.currentTime = 0;\n            audio.play();\n        };\n\n        emitter.duration = function() {\n            return Math.ceil(audio.duration);\n        };\n\n        audio.src = url;\n        audio.load(url);\n\n        if (options) { //FIXME angular.isObject\n            for (var prop in options) {\n                if (prop in audio) {\n                    audio[prop] = options[prop];\n                }\n            }\n        }\n\n        audio.play();\n\n        return emitter;\n\n    }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/audio.js\n ** module id = 42\n ** module chunks = 0\n **/"],"sourceRoot":"/source/"}